diff -urN linux-2.4.1/.cvsignore linux-2.4.1-korbit/.cvsignore
--- linux-2.4.1/.cvsignore	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/.cvsignore	Thu Feb  1 11:46:48 2001
@@ -0,0 +1 @@
+makekorbit.sh
diff -urN linux-2.4.1/KORBit.Announce linux-2.4.1-korbit/KORBit.Announce
--- linux-2.4.1/KORBit.Announce	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/KORBit.Announce	Thu Feb  1 11:46:48 2001
@@ -0,0 +1,62 @@
+From sabre@nondot.org Fri Dec  8 15:15:43 2000
+Date: Fri, 8 Dec 2000 17:10:47 -0600 (CST)
+From: Chris Lattner <sabre@nondot.org>
+To: linux-kernel@vger.kernel.org, orbit-list@gnome.org
+Cc: korbit-cvs@lists.sourceforge.net
+Subject: ANNOUNCE: Linux Kernel ORB: kORBit
+
+
+This email is here to announce the availability of a port of ORBit (the
+GNOME ORB) to the Linux kernel.  This ORB, named kORBit, is available from
+our sourceforge web site (http://korbit.sourceforge.net/).  A kernel ORB
+allows you to write kernel extensions in CORBA and have the kernel call
+into them, or to call into the kernel through CORBA.  This opens the door
+to a wide range of experiments/hacks:
+
+* We can now write device drivers in perl, and let them run on the iMAC
+  across the hall from you. :)
+* Through the use of a LD_PRELOAD'd syscall wrapper library, you can
+  forward system calls through CORBA to an arbitrary local/remote machine.
+* CORBA servers are implemented as Linux kernel modules, so they may be
+  dynamically loaded or unloaded from a running system at any time.  CORBA
+  servers expose their IOR's through a /proc/corba filesystem.
+* Filesystems may be implemented as remote CORBA objects and mounted on
+  the local machine, by using 'mount -t corbafs -o IOR:... none /mnt/corba'
+
+This are just some of the features available _RIGHT_NOW_ that are
+supported by kORBit.  I'm sure that YOU can think of many more.
+
+Implementation:
+We implemented this port by providing a user->kernel mapping layer that
+consists of providing standard system header files for the "user" code to
+#include.  In these header files, we do the mapping required.  For
+example, we implement a <stdio.h> that #defines printf to printk (as a
+trivial example).  Only user level code sees or uses these wrappers... all
+of our modifications to the Linux kernel are contained within the
+linux/net/korbit subdirectory.  
+
+This is currently implemented with a 2.4.0test10 kernel, although forward
+porting should be very easy.  This project was implemented as a cs423
+semester project by Chris Lattner, Fredrik Vraalsen, Andy Reitz, and Keith
+Wessel at the University of Illinois @ Urbana Champaign.
+
+Unresolved issues:
+* Our poll model is not optimial.  Currently we actually do a real poll on
+  a (struct socket *) set.  This causes relatively high latencies (on the
+  order 1 second, worst case) for CORBA requests.  Our waitqueues are not
+  working quite as well as they should.  :)
+* Security is completely unimplemented.  Someone could use corba
+  interfaces to read any file on your system, for example (if the
+  CORBA-FileServer module is installed).  Thus, this is really more for
+  prototyping and development than actual real world use. :)
+
+If you have any questions or comments, please feel free to contact us at:
+
+Chris Lattner, Fredrik Vraalsen, Andy Reitz, Keith Wessel
+<korbit-cvs@lists.sourceforge.net>
+
+btw, yes we are quite crazy, but what good is it to be normal and
+conformist afterall?  :)
+
+
+
diff -urN linux-2.4.1/Makefile linux-2.4.1-korbit/Makefile
--- linux-2.4.1/Makefile	Tue Jan 30 09:19:26 2001
+++ linux-2.4.1-korbit/Makefile	Thu Feb  1 15:48:45 2001
@@ -70,7 +70,7 @@
 # images.  Uncomment if you want to place them anywhere other than root.
 #
 
-#export	INSTALL_PATH=/boot
+export	INSTALL_PATH=/boot
 
 #
 # INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory
diff -urN linux-2.4.1/README.korbit linux-2.4.1-korbit/README.korbit
--- linux-2.4.1/README.korbit	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/README.korbit	Thu Feb  1 11:46:48 2001
@@ -0,0 +1,83 @@
+			 ====================
+			 KORBit: A CORBA ORB
+			 For The Linux Kernel
+			 ====================
+
+	       Submitted as a final project in CS423 by
+		  Chris Lattner <lattner@uiuc.edu>,
+		    Andy Reitz <areitz@uiuc.edu>,
+	      Fredrik Vraalsen <vraalsen@uiuc.edu>, and
+		   Keith Wessel <kwessel@uiuc.edu>
+
+			   December 8, 2000
+
+
+About:
+======
+KORBit is a port of the CORBA Object Request Broker ORBit to the Linux
+kernel.  For more information, see http://korbit.sourceforge.net/
+
+In order to use this code, you need to have ORBit-0.5.3 or later
+installed (including the development environment). The KORBit server
+modules make use of the ORBit IDL Compiler during the build process.
+
+Building The Code:
+==================
+In order to compile and run KORBit you need a recent 2.4.0-test
+version of the Linux kernel (KORBit is developed on 2.4.0-test10).
+
+To obtain a copy of the KORBit source code, see the webpage above.
+Once you have untar'ed the source code, copy the contents of the linux
+subdirectory of KORBit into the Linux root source directory
+(e.g. /usr/src/linux).
+
+Run your favourite configuration option for Linux (e.g. 'make
+menuconfig').  To enable KORBit support in the kernel, go into the
+'Networking options' section of the configuration and enable 'Kernel
+ORB'.  Then add the various CORBA services that you wish to run in the
+kernel.
+
+NOTE: The Kernel ORB *must* be compiled statically into the kernel
+(answer 'Y') and CORBA services *must* be compiled as modules (answer
+'M') at the moment.
+
+Then compile and install the Linux kernel in the standard way, e.g.:
+
+make dep ; make clean ; make bzImage ; make modules ; make modules_install
+
+Copy System.map and arch/<i386|whatever>/boot/bzImage to the proper
+places (/boot), edit your lilo.conf, run lilo and reboot.
+
+You should now be able to use CORBA in your Linux kernel!  Remember,
+this is *pre-alpha* software!  Use on your own risk!  Don't come to us
+crying if your machine blows up...
+
+Using Our Example KORBit Objects:
+=================================
+The "CORBA Echo Server" is effectively our "hello world" object. Once
+loaded into the kernel, module will instantiate an object that
+implements the "echoString()" interface. This method allows the client
+to send a string, which will be printed on the system console. Then,
+it will return a random number, which the client will print. Thus,
+after running this test, you will verify that two-way communication is
+working between KORBit and your ORB of choice.
+
+To insert this module into your newly-compiled kernel, type 
+
+insmod /lib/modules/2.4.0-test10/kernel/net/korbit/modules/Echo/server/corba-echo-server.o 
+
+Next verify that this module is actually loaded, by invoking
+"lsmod". You should see something like this:
+
+	Module			Size  Used by
+	corba-echo-server	3344   0 (unused)
+
+Now, you can grab the IOR to this object by typing "cat
+/proc/corba/echo-server". Now, you need to build the echo client,
+which will use this IOR in order to connect to the echo server. This
+can be accomplished by simply changing to the
+"/usr/src/linux/net/korbit/modules/Echo/client" directory, and then
+typing "make". Once finished, simply type "./echo-client `cat
+/proc/corba/echo-server`", and then cross your fingers!
+
+
diff -urN linux-2.4.1/Rules.make linux-2.4.1-korbit/Rules.make
--- linux-2.4.1/Rules.make	Sat Dec 30 00:07:19 2000
+++ linux-2.4.1-korbit/Rules.make	Thu Feb  1 15:46:07 2001
@@ -222,9 +222,9 @@
 
 $(MODINCL)/%.ver: %.c
 	@if [ ! -r $(MODINCL)/$*.stamp -o $(MODINCL)/$*.stamp -ot $< ]; then \
-		echo '$(CC) $(CFLAGS) -E -D__GENKSYMS__ $<'; \
+		echo '$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -E -D__GENKSYMS__ $<'; \
 		echo '| $(GENKSYMS) $(genksyms_smp_prefix) -k $(VERSION).$(PATCHLEVEL).$(SUBLEVEL) > $@.tmp'; \
-		$(CC) $(CFLAGS) -E -D__GENKSYMS__ $< \
+		$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -E -D__GENKSYMS__ $< \
 		| $(GENKSYMS) $(genksyms_smp_prefix) -k $(VERSION).$(PATCHLEVEL).$(SUBLEVEL) > $@.tmp; \
 		if [ -r $@ ] && cmp -s $@ $@.tmp; then echo $@ is unchanged; rm -f $@.tmp; \
 		else echo mv $@.tmp $@; mv -f $@.tmp $@; fi; \
diff -urN linux-2.4.1/korbit.patch linux-2.4.1-korbit/korbit.patch
--- linux-2.4.1/korbit.patch	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/korbit.patch	Thu Feb  1 11:46:48 2001
@@ -0,0 +1,43 @@
+--- linux/Rules.make.orig	Wed Jan 31 22:50:40 2001
++++ linux/Rules.make	Thu Feb  1 01:39:46 2001
+@@ -222,9 +222,9 @@
+ 
+ $(MODINCL)/%.ver: %.c
+ 	@if [ ! -r $(MODINCL)/$*.stamp -o $(MODINCL)/$*.stamp -ot $< ]; then \
+-		echo '$(CC) $(CFLAGS) -E -D__GENKSYMS__ $<'; \
++		echo '$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -E -D__GENKSYMS__ $<'; \
+ 		echo '| $(GENKSYMS) $(genksyms_smp_prefix) -k $(VERSION).$(PATCHLEVEL).$(SUBLEVEL) > $@.tmp'; \
+-		$(CC) $(CFLAGS) -E -D__GENKSYMS__ $< \
++		$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -E -D__GENKSYMS__ $< \
+ 		| $(GENKSYMS) $(genksyms_smp_prefix) -k $(VERSION).$(PATCHLEVEL).$(SUBLEVEL) > $@.tmp; \
+ 		if [ -r $@ ] && cmp -s $@ $@.tmp; then echo $@ is unchanged; rm -f $@.tmp; \
+ 		else echo mv $@.tmp $@; mv -f $@.tmp $@; fi; \
+--- linux/net/Config.in.orig	Wed Jan 31 22:39:32 2001
++++ linux/net/Config.in	Thu Feb  1 01:40:02 2001
+@@ -30,6 +30,7 @@
+    fi
+    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+       source net/khttpd/Config.in
++      source net/korbit/Config.in
+    fi
+ fi
+ if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- linux/net/Makefile.orig	Thu Feb  1 01:41:42 2001
++++ linux/net/Makefile	Thu Feb  1 01:41:35 2001
+@@ -7,7 +7,7 @@
+ 
+ O_TARGET :=	network.o
+ 
+-mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda atm netlink sched
++mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda atm netlink sched korbit
+ export-objs :=	netsyms.o
+ 
+ subdir-y :=	core ethernet
+@@ -27,6 +27,7 @@
+ endif
+ 
+ subdir-$(CONFIG_KHTTPD)		+= khttpd
++subdir-$(CONFIG_KORBIT)		+= korbit
+ subdir-$(CONFIG_NETLINK)	+= netlink
+ subdir-$(CONFIG_PACKET)		+= packet
+ subdir-$(CONFIG_NET_SCHED)	+= sched
diff -urN linux-2.4.1/makekorbit.sh linux-2.4.1-korbit/makekorbit.sh
--- linux-2.4.1/makekorbit.sh	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/makekorbit.sh	Thu Feb  1 11:46:48 2001
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+make CFLAGS="-D__KERNEL__ -I`pwd`/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -march=k6  -DHAVE_CONFIG_H -DHAVE_UNISTD_H -I. -I.. -I../include -nostdinc" -C  net/korbit TOPDIR=`pwd`
+
diff -urN linux-2.4.1/net/CVS/Entries linux-2.4.1-korbit/net/CVS/Entries
--- linux-2.4.1/net/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/CVS/Entries	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+D
diff -urN linux-2.4.1/net/CVS/Entries.Log linux-2.4.1-korbit/net/CVS/Entries.Log
--- linux-2.4.1/net/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/CVS/Entries.Log	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+A D/korbit////
diff -urN linux-2.4.1/net/CVS/Repository linux-2.4.1-korbit/net/CVS/Repository
--- linux-2.4.1/net/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/CVS/Repository	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net
diff -urN linux-2.4.1/net/CVS/Root linux-2.4.1-korbit/net/CVS/Root
--- linux-2.4.1/net/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/CVS/Root	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/Config.in linux-2.4.1-korbit/net/Config.in
--- linux-2.4.1/net/Config.in	Tue Oct 10 19:33:52 2000
+++ linux-2.4.1-korbit/net/Config.in	Thu Feb  1 15:46:07 2001
@@ -30,6 +30,7 @@
    fi
    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       source net/khttpd/Config.in
+      source net/korbit/Config.in
    fi
 fi
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
diff -urN linux-2.4.1/net/Makefile linux-2.4.1-korbit/net/Makefile
--- linux-2.4.1/net/Makefile	Sat Dec 30 00:07:24 2000
+++ linux-2.4.1-korbit/net/Makefile	Thu Feb  1 15:46:07 2001
@@ -7,7 +7,7 @@
 
 O_TARGET :=	network.o
 
-mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda atm netlink sched
+mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda atm netlink sched korbit
 export-objs :=	netsyms.o
 
 subdir-y :=	core ethernet
@@ -27,6 +27,7 @@
 endif
 
 subdir-$(CONFIG_KHTTPD)		+= khttpd
+subdir-$(CONFIG_KORBIT)		+= korbit
 subdir-$(CONFIG_NETLINK)	+= netlink
 subdir-$(CONFIG_PACKET)		+= packet
 subdir-$(CONFIG_NET_SCHED)	+= sched
diff -urN linux-2.4.1/net/korbit/CVS/Entries linux-2.4.1-korbit/net/korbit/CVS/Entries
--- linux-2.4.1/net/korbit/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/CVS/Entries	Thu Feb  1 11:46:49 2001
@@ -0,0 +1,6 @@
+/Config.in/1.3/Thu Feb  1 09:46:49 2001//
+/Makefile/1.7/Thu Feb  1 09:46:49 2001//
+/config.h/1.2/Thu Feb  1 09:46:49 2001//
+/exported_symbols.c/1.8/Thu Feb  1 09:46:49 2001//
+/korbit.h/1.2/Thu Feb  1 09:46:49 2001//
+D
diff -urN linux-2.4.1/net/korbit/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/CVS/Entries.Log
--- linux-2.4.1/net/korbit/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/CVS/Entries.Log	Thu Feb  1 11:47:15 2001
@@ -0,0 +1,7 @@
+A D/IIOP////
+A D/ORBitutil////
+A D/include////
+A D/kglib////
+A D/modules////
+A D/orb////
+A D/sup////
diff -urN linux-2.4.1/net/korbit/CVS/Repository linux-2.4.1-korbit/net/korbit/CVS/Repository
--- linux-2.4.1/net/korbit/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/CVS/Repository	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit
diff -urN linux-2.4.1/net/korbit/CVS/Root linux-2.4.1-korbit/net/korbit/CVS/Root
--- linux-2.4.1/net/korbit/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/CVS/Root	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/Config.in linux-2.4.1-korbit/net/korbit/Config.in
--- linux-2.4.1/net/korbit/Config.in	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/Config.in	Thu Feb  1 11:46:49 2001
@@ -0,0 +1,8 @@
+#
+# KORBit
+#
+
+#tristate '  Kernel ORB (EXPERIMENTAL)' CONFIG_KORBIT
+bool '  Kernel ORB (EXPERIMENTAL)' CONFIG_KORBIT
+
+source net/korbit/modules/Config.in
diff -urN linux-2.4.1/net/korbit/IIOP/CVS/Entries linux-2.4.1-korbit/net/korbit/IIOP/CVS/Entries
--- linux-2.4.1/net/korbit/IIOP/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/CVS/Entries	Thu Feb  1 11:46:51 2001
@@ -0,0 +1,15 @@
+/IIOP-config.h/1.1.1.1/Thu Feb  1 09:46:50 2001//
+/IIOP-design.txt/1.1.1.1/Thu Feb  1 09:46:50 2001//
+/IIOP-private.h/1.2/Thu Feb  1 09:46:50 2001//
+/IIOP-types.h/1.1.1.1/Thu Feb  1 09:46:50 2001//
+/IIOP.h/1.1.1.1/Thu Feb  1 09:46:50 2001//
+/Makefile/1.4/Thu Feb  1 09:46:51 2001//
+/connection.c/1.19/Thu Feb  1 09:46:51 2001//
+/encoders.c/1.1.1.1/Thu Feb  1 09:46:51 2001//
+/giop-msg-buffer.c/1.12/Thu Feb  1 09:46:51 2001//
+/giop-msg-buffer.h/1.1.1.1/Thu Feb  1 09:46:51 2001//
+/iiop-encoders.h/1.1.1.1/Thu Feb  1 09:46:51 2001//
+/iiop-endian.c/1.1.1.1/Thu Feb  1 09:46:51 2001//
+/iiop-endian.h/1.1.1.1/Thu Feb  1 09:46:51 2001//
+/iiop-endianP.h/1.1.1.1/Thu Feb  1 09:46:51 2001//
+D
diff -urN linux-2.4.1/net/korbit/IIOP/CVS/Repository linux-2.4.1-korbit/net/korbit/IIOP/CVS/Repository
--- linux-2.4.1/net/korbit/IIOP/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/CVS/Repository	Thu Feb  1 11:46:50 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/IIOP
diff -urN linux-2.4.1/net/korbit/IIOP/CVS/Root linux-2.4.1-korbit/net/korbit/IIOP/CVS/Root
--- linux-2.4.1/net/korbit/IIOP/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/CVS/Root	Thu Feb  1 11:46:49 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/IIOP/IIOP-config.h linux-2.4.1-korbit/net/korbit/IIOP/IIOP-config.h
--- linux-2.4.1/net/korbit/IIOP/IIOP-config.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/IIOP-config.h	Thu Feb  1 11:46:50 2001
@@ -0,0 +1,5 @@
+/* The size of the chunks that are used for indirect pieces of messages.
+   Too low, and you'll have a lot of malloc overhead. Too high, and you'll
+   get wasted mem.
+*/
+#define GIOP_INDIRECT_CHUNK_SIZE 1024
diff -urN linux-2.4.1/net/korbit/IIOP/IIOP-design.txt linux-2.4.1-korbit/net/korbit/IIOP/IIOP-design.txt
--- linux-2.4.1/net/korbit/IIOP/IIOP-design.txt	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/IIOP-design.txt	Thu Feb  1 11:46:50 2001
@@ -0,0 +1,14 @@
+
+void Hello_hello(CORBA_Object anobj, const char *arg1, CORBA_Environment *ev)
+
+If we're doing a local call (i.e. shared library object activation),
+just do it.
+
+If we're doing a remote call, we need to setup generic header
+(utilfunc), setup request header (utilfunc), encode arguments (stubs),
+send the message headers & body (utilfunc) and wait for a reply (XXX
+define more clearly).  When we get the reply, we need to read the
+reply(utilfunc), decode the return value & out/inout arguments(stubs)
+& fill them in (or decode the exception that resulted (utilfunc)), and 
+return.
+
diff -urN linux-2.4.1/net/korbit/IIOP/IIOP-private.h linux-2.4.1-korbit/net/korbit/IIOP/IIOP-private.h
--- linux-2.4.1/net/korbit/IIOP/IIOP-private.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/IIOP-private.h	Thu Feb  1 11:46:50 2001
@@ -0,0 +1,46 @@
+#ifndef IIOP_PRIVATE_H
+#define IIOP_PRIVATE_H 1
+
+
+#include "config.h"
+
+#if defined(HAVE_POLL) && defined(I_WANT_POLL)
+#define USE_POLL
+#else
+#undef USE_POLL
+#endif
+
+#ifdef HAVE_SYS_POLL_H
+#include <sys/poll.h>
+#endif
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <glib.h>
+
+typedef struct {
+  GList *list;
+  gboolean connection_list_changed;
+#ifndef __KORBIT__
+  GPtrArray *fd_to_connection_mapping;
+#else /* __KORBIT__ */
+  GHashTable *fd_to_connection_mapping;
+#endif /* __KORBIT__ */
+#  ifdef USE_POLL
+  GArray *pollset;
+#  else
+  fd_set selectset_rd, selectset_ex;
+#  endif
+  int max_fd;
+} GIOPConnectionList;
+
+extern GIOPConnectionList giop_connection_list;
+
+/* If you get a buffer that you didn't want, add it to the list! */
+void giop_received_list_push(GIOPRecvBuffer *recv_buffer);
+GIOPRecvBuffer *giop_received_list_pop(void);
+
+
+#endif
diff -urN linux-2.4.1/net/korbit/IIOP/IIOP-types.h linux-2.4.1-korbit/net/korbit/IIOP/IIOP-types.h
--- linux-2.4.1/net/korbit/IIOP/IIOP-types.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/IIOP-types.h	Thu Feb  1 11:46:50 2001
@@ -0,0 +1,76 @@
+#ifndef IIOP_TYPES_H
+#define IIOP_TYPES_H 1
+
+/* XXX todo sync this up with basic_types.h if needed */
+#include <unistd.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+
+#include <ORBitutil/basic_types.h>
+
+typedef enum {
+  GIOP_CONNECTION_SERVER, /* Not a real connection to any place - just
+			     listening */
+  GIOP_CONNECTION_CLIENT
+} GIOPConnectionClass;
+
+typedef struct _GIOPConnection GIOPConnection;
+struct _GIOPConnection {
+  enum { GIOP_CONNECTION_NONE, GIOP_CONNECTION_IIOP } connection_type;
+  void (*destroy_func)(GIOPConnection *connection);
+
+  gint refcount;
+  GIOPConnectionClass connection_class;
+
+  int fd;
+
+  /* You can access these if you wish. */
+  gpointer orb_data;
+  gpointer user_data;
+  /* end accessable stuff */
+
+  guchar is_valid, was_initiated, is_auth;
+
+  gpointer incoming_msg; /* GIOPRecvBuffer */
+};
+
+#define GIOP_CONNECTION(x) ((GIOPConnection *)(x))
+#define GIOP_CONNECTION_GET_FD(x) (GIOP_CONNECTION((x))->fd)
+
+typedef enum { IIOP_IPV4, IIOP_IPV6, IIOP_USOCK } IIOPConnectionType;
+
+typedef struct {
+  GIOPConnection giop_connection;
+
+  gboolean is_serversock;
+  IIOPConnectionType icnxtype;
+  union {
+    struct {
+      char *hostname;
+      struct sockaddr_in location;
+    } ipv4;
+    struct sockaddr_un usock;
+    /* Yes this is a config.h define, and no it doesn't matter,
+       because this structure should only be used internally anyways */
+#ifdef HAVE_IPV6
+    struct {
+      char *hostname;
+      struct sockaddr_in6 location;
+    } ipv6;
+#endif
+  } u;
+} IIOPConnection;
+
+#define IIOP_CONNECTION(x) ((IIOPConnection *)(x))
+
+#if defined(DEBUG_sopwith_connection_refcounting)
+#define giop_connection_ref(x) G_STMT_START{ (GIOP_CONNECTION(x)->refcount++); g_print("!   reffing fd %d in " __PRETTY_FUNCTION__ ":%d to %d\n", GIOP_CONNECTION_GET_FD(x), __LINE__, GIOP_CONNECTION(x)->refcount); }G_STMT_END
+
+#define giop_connection_unref(x) G_STMT_START{ GIOP_CONNECTION(x)->refcount--; g_print("!   dereffing fd %d in " __PRETTY_FUNCTION__ ":%d to %d\n", GIOP_CONNECTION_GET_FD(x), __LINE__, GIOP_CONNECTION(x)->refcount); if(GIOP_CONNECTION(x)->refcount <= 0) giop_connection_free(x); }G_STMT_END
+#else
+#define giop_connection_ref(x) G_STMT_START{ (GIOP_CONNECTION(x)->refcount++); }G_STMT_END
+
+#define giop_connection_unref(x) G_STMT_START{ GIOP_CONNECTION(x)->refcount--; if(GIOP_CONNECTION(x)->refcount <= 0) giop_connection_free(x); }G_STMT_END
+#endif
+
+#endif /* IIOP_TYPES_H */
diff -urN linux-2.4.1/net/korbit/IIOP/IIOP.h linux-2.4.1-korbit/net/korbit/IIOP/IIOP.h
--- linux-2.4.1/net/korbit/IIOP/IIOP.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/IIOP.h	Thu Feb  1 16:19:47 2001
@@ -0,0 +1,52 @@
+#ifndef IIOP_H
+#define IIOP_H 1
+
+#include <unistd.h>
+#include <ORBitutil/util.h>
+#include "IIOP-config.h"
+#include "IIOP-types.h"
+#include "giop-msg-buffer.h"
+#include "iiop-encoders.h"
+#include "iiop-endian.h"
+
+/* We don't speak GIOP 1.0, sosumi */
+#define GIOP_1_1
+
+
+void giop_init(const char *argv0);
+
+/* You use this to get a pointer to a new (or existing) connection
+   that has the specified host/port characteristics */
+IIOPConnection *iiop_connection_get(const char *host, gushort port,
+				    gboolean existing_only);
+/* Similar, but for UNIX sockets */
+IIOPConnection *iiop_connection_unix_get(const char *sockpath,
+					 gboolean existing_only);
+
+/* gives us a local socket that other people can connect to... */
+IIOPConnection *iiop_connection_server(void);
+IIOPConnection *iiop_connection_server_ipv6(void);
+IIOPConnection *iiop_connection_server_unix(const char *sockpath);
+
+void giop_main_quit(void);
+void giop_main(void); /* main loop for the program if none other is given,
+			 and also used while waiting for a reply */
+void giop_main_iterate(gboolean blocking);
+void giop_main_handle_connection(GIOPConnection *connection);
+void giop_main_handle_connection_exception(GIOPConnection *connection);
+GIOPRecvBuffer *giop_main_next_message(gboolean blocking);
+GIOPRecvBuffer *giop_main_next_message_2(gboolean blocking,
+					 GIOPConnection *monitor);
+GIOPConnection *giop_check_connections(gboolean block_for_reply);
+
+/* This assumes that the appropriate GIOP_CLOSECONNECTION message
+   has been sent to the peer */
+void giop_connection_free(GIOPConnection *connection);
+
+/* Called when a connection is created */
+extern void (*IIOPAddConnectionHandler)(GIOPConnection *newcnx);
+/* Called when a connection is about to be destroyed */
+extern void (*IIOPRemoveConnectionHandler)(GIOPConnection *oldcnx);
+extern void (*IIOPIncomingMessageHandler)(GIOPRecvBuffer *recv_buffer);
+
+#endif /* IIOP_H */
diff -urN linux-2.4.1/net/korbit/IIOP/Makefile linux-2.4.1-korbit/net/korbit/IIOP/Makefile
--- linux-2.4.1/net/korbit/IIOP/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/Makefile	Thu Feb  1 11:46:51 2001
@@ -0,0 +1,18 @@
+#
+# Makefile for KORBit/IIOP
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .o file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := IIOPlib.o
+
+#obj-m := $(O_TARGET)
+obj-y := connection.o encoders.o giop-msg-buffer.o iiop-endian.o
+
+
+EXTRA_CFLAGS = -D__KORBIT__ -DHAVE_CONFIG_H -I. -I.. -I../include -I../kglib -I../ORBitutil -nostdinc
+
+include $(TOPDIR)/Rules.make
diff -urN linux-2.4.1/net/korbit/IIOP/connection.c linux-2.4.1-korbit/net/korbit/IIOP/connection.c
--- linux-2.4.1/net/korbit/IIOP/connection.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/connection.c	Thu Feb  1 19:26:07 2001
@@ -0,0 +1,1565 @@
+#include "config.h"
+
+#if defined(HAVE_POLL) && defined(I_WANT_POLL)
+#define USE_POLL
+#else
+#undef USE_POLL
+#endif
+
+#ifndef _XOPEN_SOURCE_EXTENDED
+#   define _XOPEN_SOURCE_EXTENDED 1
+#   define WE_DEFINED_XOPEN_SOURCE_EXTENDED 1
+#endif
+#include "iiop-endianP.h"
+#ifdef WE_DEFINED_XOPEN_SOURCE_EXTENDED
+#   undef _XOPEN_SOURCE_EXTENDED
+#endif
+#include "IIOP.h"
+#include "IIOP-private.h"
+#include "giop-msg-buffer.h"
+#include <stdlib.h>
+#include <unistd.h>
+#ifdef ORBIT_DEBUG
+#include <errno.h>
+#endif
+#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#ifndef _XOPEN_SOURCE_EXTENDED
+#   define _XOPEN_SOURCE_EXTENDED 1
+#endif
+#include <arpa/inet.h>
+#include <netdb.h>
+#ifdef WE_DEFINED_XOPEN_SOURCE_EXTENDED
+#   undef _XOPEN_SOURCE_EXTENDED
+#endif
+#include <ctype.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <signal.h>
+#include <syslog.h>
+#include <stdio.h>
+
+/*
+#ifdef O_NONBLOCK
+#undef O_NONBLOCK
+#endif
+#define O_NONBLOCK 0
+*/
+
+#if defined(HAVE_TCPD_H) && defined(HAVE_HOSTS_ACCESS)
+#include <tcpd.h>
+#endif
+
+#if 0
+#include <malloc.h>
+
+static struct mallinfo mi1, mi2;
+
+#define AM() mi1 = mallinfo();
+#define PM(x) mi2 = mallinfo(); printf(x ": used %d, now %d\n", \
+mi2.uordblks - mi1.uordblks, mi2.uordblks);
+#endif
+
+#ifdef HAVE_POLL
+#include <sys/poll.h>
+#endif
+
+#ifndef SUN_LEN
+/* This system is not POSIX.1g.  */
+#define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path)  \
+                      + strlen ((ptr)->sun_path))
+#endif
+
+void (*IIOPAddConnectionHandler)(GIOPConnection *newcnx) = NULL;
+void (*IIOPRemoveConnectionHandler)(GIOPConnection *oldcnx) = NULL;
+void (*IIOPIncomingMessageHandler)(GIOPRecvBuffer *recv_buffer) = NULL;
+
+static void giop_connection_add_to_list         (GIOPConnection *cnx);
+static void giop_connection_remove_from_list    (GIOPConnection *cnx);
+
+static void iiop_init                           (void);
+static void iiop_connection_server_accept       (GIOPConnection *connection);
+static void iiop_connection_destroy   		(IIOPConnection *connection);
+static IIOPConnection *iiop_connection_new      (const char *host, gushort port);
+static IIOPConnection *iiop_connection_unix_new (const char *sockpath);
+static void iiop_unlink_unix_sockets            (void);
+
+DEFINE_LOCK(giop_connection_list);
+GIOPConnectionList giop_connection_list;
+static GSList *iiop_unix_socket_list = NULL;
+
+#if defined(HAVE_HOSTS_ACCESS) && defined (HAVE_TCPD_H)
+static const char *argv0_val = NULL;
+#endif
+
+struct fd_hash_elem
+{
+        guint fd;
+        GIOPConnection *cnx;
+};
+
+static guint fd_hash_func(gconstpointer key)
+{
+        const guint *key_ptr = (guint *)key;
+        guint result = *key_ptr >> 2;
+        return result;
+}
+
+static gint fd_compare_func(gconstpointer a, gconstpointer b)
+{
+        const guint *a_ptr = (guint *)a;
+        const guint *b_ptr = (guint *)b;
+        return *a_ptr == *b_ptr;
+}
+
+static gboolean fd_hash_clear(gpointer key, gpointer value, gpointer user_data)
+{
+        struct fd_hash_elem *el = (struct fd_hash_elem *)value;
+        g_free(el);
+        return TRUE;
+}
+
+/*
+ * giop_init
+ *
+ *    Inputs: None
+ *    Outputs: None
+ *
+ *    Side effects: Initializes giop_connection_list
+ *    Global data structures used: giop_connection_list
+ *
+ *    Description: Initializes giop_connection_list. Calls
+ *                 giop_message_buffer_init() to initialize the
+ *                 message_buffer subsystem. Calls iiop_init()
+ *		   to perform IIOP-specific initialization.
+ */
+
+void giop_init(const char *argv0)
+{
+#ifndef __KERNEL__
+  struct sigaction mypipe;
+#endif
+  g_assert(sizeof(GIOPMessageHeader) == 12);
+
+#if defined(HAVE_HOSTS_ACCESS) && defined (HAVE_TCPD_H)
+  argv0_val = g_strdup(g_basename(argv0)); /* For TCP wrappers */
+#endif
+
+#ifndef __KERNEL__
+  memset(&mypipe, '\0', sizeof(mypipe));
+  mypipe.sa_handler = SIG_IGN;
+
+  sigaction(SIGPIPE, &mypipe, NULL);
+#endif
+
+  giop_message_buffer_init();
+
+  INIT_LOCK(giop_connection_list);
+
+  giop_connection_list.list = NULL;
+  giop_connection_list.connection_list_changed = FALSE;
+
+#ifdef USE_POLL
+  giop_connection_list.pollset = g_array_new(FALSE, FALSE,
+					     sizeof(struct pollfd));
+#else
+  FD_ZERO(&giop_connection_list.selectset_rd);
+  FD_ZERO(&giop_connection_list.selectset_ex);
+#endif
+
+#ifndef __KORBIT__
+  giop_connection_list.fd_to_connection_mapping = g_ptr_array_new();
+#else
+  giop_connection_list.fd_to_connection_mapping = 
+          g_hash_table_new(&fd_hash_func,
+                           &fd_compare_func);
+#endif
+
+  /*
+   * This also needs to do any transport-specific initialization
+   * as appropriate
+   */
+  iiop_init();
+}
+
+/*** giop_connection_init
+ *
+ *   Inputs: 'giop_connection' - memory region allocated for use as a
+ *                               GIOPConnection.
+ *           'cnxclass'        - the class of connection that will be stored
+ *                               here (SERVER, CLIENT)
+ *
+ *   Outputs: None
+ *
+ *   Side effects: Initializes 'giop_connection'.
+ *
+ *   Description: Basic setup of a GIOPConnection.
+ *                Sets is_valid to FALSE because it is the responsibility of
+ *	          the transport-specific initialization routine to make
+ *	          a connection valid.
+ */
+
+static void giop_connection_init(GIOPConnection *giop_connection,
+				 GIOPConnectionClass cnxclass)
+{
+  giop_connection->connection_type = GIOP_CONNECTION_NONE;
+  giop_connection->refcount = 0;
+  giop_connection->connection_class = cnxclass;
+  giop_connection->is_valid = FALSE;
+  giop_connection->is_auth = FALSE;
+  giop_connection->was_initiated = FALSE;
+}
+
+/*
+ * giop_connection_free
+ *    Inputs: 'connection'
+ *    Outputs: None
+ *    Side effects: Makes the 'connection' invalid as a GIOPConnection
+ *                  and as a gpointer.
+ *
+ *    Description: Calls giop_connection_remove_from_list() to
+ *                 stop the connection from being used for incoming.
+ *
+ *	           If a transport-specific finalization function has
+ *	           been provided, call it.
+ *	           
+ *	           Free the memory block at '*connection'.
+ *
+ */
+void giop_connection_free(GIOPConnection *connection)
+{
+  g_return_if_fail(connection != NULL);
+  giop_connection_remove_from_list(connection);
+
+  if(connection->is_valid && connection->destroy_func)
+    connection->destroy_func(connection);
+
+  connection->is_valid = FALSE;
+
+  if(connection->incoming_msg) {
+    GIOPRecvBuffer *buf;
+
+    buf = connection->incoming_msg;
+    connection->incoming_msg = NULL;
+    giop_recv_buffer_unuse(buf);
+  }
+
+  g_free(connection);
+}
+
+/*
+ * giop_connection_list_recreate
+ *
+ *    Inputs: None
+ *    Outputs: None
+ *
+ *    Side effects: giop_connection_list changes.
+ *
+ *    Global data structures used: giop_connection_list
+ *
+ *    Description:
+ *         When new connections are added to giop_connection_list.list,
+ *     	   the data structures passed to poll() or select() (OS-dependant)
+ *     	   must be recreated to match this list.
+ *     	   
+ *     	   [We do this at add-connection/remove-connection time
+ *     	    instead of every time a poll/select is done in order to
+ *     	    speed things up a little]
+ *     	   
+ *     	   This function reinitializes the OS-specific file
+ *     	   descriptor data structure and then adds all the file
+ *     	   descriptors in the list to it.
+ *     	  
+ *     	   It also regenerates the array that maps file descriptors
+ *     	   into GIOPConnection*'s
+ *
+ */
+static void
+giop_connection_list_recreate(void)
+{
+  int curfd;
+  GList *item;
+  GIOPConnection *cnx;
+#ifdef USE_POLL
+  struct pollfd new_poll;
+
+  new_poll.revents = 0;
+#endif
+
+  giop_connection_list.max_fd = 0;
+  for(item = giop_connection_list.list; item; item = g_list_next(item))
+    {
+      cnx = item->data;
+      curfd = GIOP_CONNECTION_GET_FD(cnx);
+
+      if(curfd > giop_connection_list.max_fd)
+	giop_connection_list.max_fd = curfd;
+  }
+
+#ifndef __KORBIT__
+  g_ptr_array_set_size(giop_connection_list.fd_to_connection_mapping,
+		       giop_connection_list.max_fd + 1);
+#else
+  g_hash_table_foreach_remove(giop_connection_list.fd_to_connection_mapping,
+                              fd_hash_clear,
+                              NULL);
+#endif
+
+#ifdef USE_POLL
+  g_array_set_size(giop_connection_list.pollset, 0);
+#else
+  FD_ZERO(&giop_connection_list.selectset_rd);
+  FD_ZERO(&giop_connection_list.selectset_ex);
+#endif
+
+  for(item = giop_connection_list.list; item; item = g_list_next(item))
+    {
+            struct fd_hash_elem *el;
+            
+      cnx = item->data;
+      curfd = GIOP_CONNECTION_GET_FD(cnx);
+
+#ifndef __KORBIT__
+      giop_connection_list.fd_to_connection_mapping->pdata[curfd] = cnx;
+#else
+      el = g_new(struct fd_hash_elem, 1);
+      el->fd = curfd;
+      el->cnx = cnx;
+      g_hash_table_insert(giop_connection_list.fd_to_connection_mapping,
+                          &(el->fd),
+                          el);
+#endif
+
+#     ifdef USE_POLL
+      new_poll.fd = curfd;
+      new_poll.events = POLLIN|POLLPRI;
+      g_array_append_val(giop_connection_list.pollset, 
+			 new_poll);
+#     else
+      FD_SET(curfd, &giop_connection_list.selectset_rd);
+      FD_SET(curfd, &giop_connection_list.selectset_ex);
+#     endif
+  }
+}
+
+/*
+ * giop_connection_add_to_list
+ *
+ *    Inputs: 'cnx' - a GIOPConnection that the user wishes added to the list
+ *    Outputs: None
+ *
+ *    Side effects: Modifies giop_connection_list
+ *    Global data structures used: giop_connection_list
+ *    Bugs: Does not check for duplicate additions.
+ *
+ *    Description:
+ *         Adds a connection to the list of active connections.
+ */
+static void
+giop_connection_add_to_list(GIOPConnection *cnx)
+{
+  g_return_if_fail(cnx->is_valid == FALSE);
+
+  cnx->is_valid = TRUE;
+
+  GET_LOCK(giop_connection_list);
+  giop_connection_list.list = g_list_prepend(giop_connection_list.list, cnx);
+
+  giop_connection_list_recreate();
+
+  RELEASE_LOCK(giop_connection_list);
+
+  if(IIOPAddConnectionHandler)
+    IIOPAddConnectionHandler(cnx);
+
+  giop_connection_ref(cnx);
+}
+
+/*
+ * giop_connection_remove_from_list
+ *
+ *    Inputs: 'cnx' - a GIOPConnection that the user wishes
+ *    Outputs: None
+ *
+ *    Side effects: Modifies giop_connection_list
+ *    Global data structures used: giop_connection_list
+ *
+ *    Description:
+ *         Removes a connection from the list of active connections.
+ *         Calls the library user's "I removed connection" handler if it
+ *         exists.
+ *
+ *    Bugs: Does not check for duplicate removals. This may not be "bad" though.
+ */
+void
+giop_connection_remove_from_list(GIOPConnection *cnx)
+{
+  GList *link;
+
+  GET_LOCK(giop_connection_list);
+
+  link = g_list_find(giop_connection_list.list, cnx);
+
+  if(!link)
+    goto out;
+
+  if(IIOPRemoveConnectionHandler && cnx->is_valid)
+    IIOPRemoveConnectionHandler(cnx);
+
+  giop_connection_list.list = g_list_remove_link(giop_connection_list.list,
+						 link);
+  g_list_free_1(link);
+
+  giop_connection_unref(cnx);
+
+  giop_connection_list_recreate();
+ out:
+  RELEASE_LOCK(giop_connection_list);
+}
+
+/************************************************
+ * Routines specific to the IIOP/IPv4 transport *
+ ************************************************/
+
+/*
+ * iiop_init
+ *
+ *    Inputs: None
+ *    Outputs: None
+ *
+ *    Side effects: Initializes iiop_unix_socket_list
+ *    Global data structures used: iiop_unix_socket_list
+ *
+ *    Description: Initializes iiop_unix_socket_list.
+ *                 Registers Unix domain sockets for
+ *                 removal at server termination.
+ */
+static void
+iiop_init(void)
+{
+#ifndef __KERNEL__
+  g_atexit(iiop_unlink_unix_sockets);
+#endif
+}
+
+/*
+ * iiop_connection_init
+ *
+ *    Inputs: 'connection' - a memory region that needs to be initialized as
+ *                           an 'IIOPConnection'.
+ *
+ *    Side effects: initializes 'connection'
+ *
+ *    Description: Performs the IIOP-specific initialization of an
+ *                 IIOPConnection. giop_connection_init is called.
+ *
+ */
+void
+iiop_connection_init(IIOPConnection *connection,
+		     GIOPConnectionClass cnxclass,
+		     IIOPConnectionType iioptype)
+{
+  giop_connection_init(GIOP_CONNECTION(connection), cnxclass);
+
+  GIOP_CONNECTION(connection)->connection_type =
+    GIOP_CONNECTION_IIOP;
+
+  GIOP_CONNECTION(connection)->destroy_func =
+    (void (*)(GIOPConnection *))iiop_connection_destroy;
+
+  connection->icnxtype = iioptype;
+}
+
+/*
+ * iiop_connection_from_fd
+ *
+ *    Inputs: 'fd' - a file descriptor that attention should be paid to
+ *    Outputs: 'fd_cnx' - the created connection 
+ *
+ *    Description: This is intended to be used on a file descriptor
+ *	           that has been accept()'d. It creates the connection
+ *	           and fills in the connection information, then adds
+ *	           it to the active list.
+ */
+IIOPConnection *
+iiop_connection_from_fd(int fd, IIOPConnection *parent)
+{
+  IIOPConnection *fd_cnx;
+  struct hostent *hent;
+  socklen_t n;
+
+  g_assert(fd >= 0);
+
+  fd_cnx = g_new0(IIOPConnection, 1);
+
+  iiop_connection_init(fd_cnx, GIOP_CONNECTION_CLIENT, parent->icnxtype);
+
+  GIOP_CONNECTION(fd_cnx)->fd = fd;
+
+  switch(parent->icnxtype) {
+  case IIOP_IPV4:
+    n = sizeof(struct sockaddr_in);
+    if(getpeername(GIOP_CONNECTION_GET_FD(fd_cnx), (struct sockaddr *)&fd_cnx->u.ipv4.location, &n))
+      {
+	fd_cnx->u.ipv4.hostname = g_strdup("");
+      }
+    else
+      {
+	hent = gethostbyaddr((const char *)&fd_cnx->u.ipv4.location.sin_addr.s_addr, 4, AF_INET);
+	if(hent)
+	  {
+	    fd_cnx->u.ipv4.hostname = g_strdup(hent->h_name);
+	  }
+	else
+	  {
+	    fd_cnx->u.ipv4.hostname = inet_ntoa(*((struct in_addr *)&fd_cnx->u.ipv4.location.sin_addr));
+	  }
+      }
+    break;
+
+  case IIOP_USOCK:
+    n = sizeof(struct sockaddr_un);
+    fd_cnx->u.usock.sun_family = AF_UNIX;
+    getpeername(GIOP_CONNECTION_GET_FD(fd_cnx),
+	(struct sockaddr *)&fd_cnx->u.usock, &n);
+    break;
+
+#ifdef HAVE_IPV6
+  case IIOP_IPV6:
+    n = sizeof(struct sockaddr_in6);
+    getpeername(GIOP_CONNECTION_GET_FD(fd_cnx),
+	(struct sockaddr *)&fd_cnx->u.ipv6.location, &n);
+    hent = gethostbyaddr((const char *)&fd_cnx->u.ipv6.location.sin6_addr, 
+			 sizeof(fd_cnx->u.ipv6.location.sin6_addr), AF_INET6);
+    fd_cnx->u.ipv6.hostname = g_strdup(hent->h_name);
+    break;
+#endif
+
+  default:
+    g_error("Unsupported connection type %d", parent->icnxtype);
+  }
+
+  fcntl(GIOP_CONNECTION_GET_FD(fd_cnx), F_SETFD,
+	fcntl(GIOP_CONNECTION_GET_FD(fd_cnx), F_GETFD, 0)
+	| FD_CLOEXEC);
+  fcntl(GIOP_CONNECTION_GET_FD(fd_cnx), F_SETFL,
+	fcntl(GIOP_CONNECTION_GET_FD(fd_cnx), F_GETFL, 0)
+	| O_NONBLOCK);
+
+  ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug,
+	      "iiop_connection_from_fd connect [%d]\n",
+	      GIOP_CONNECTION_GET_FD(fd_cnx));
+
+  giop_connection_add_to_list(GIOP_CONNECTION(fd_cnx));
+
+  return fd_cnx;
+}
+
+/*
+ * iiop_connection_server
+ *
+ *   Outputs: 'server_cnx'
+ *
+ *    Description: Creates a special IIOPConnection on which incoming
+ *                 connections come.
+ */
+IIOPConnection *
+iiop_connection_server(void)
+{
+  struct hostent *hent;
+  char hn_tmp[65];
+  socklen_t n;
+  IIOPConnection *server_cnx = g_new0(IIOPConnection, 1);
+
+  iiop_connection_init(server_cnx, GIOP_CONNECTION_SERVER, IIOP_IPV4);
+
+  server_cnx->is_serversock = TRUE;
+  GIOP_CONNECTION(server_cnx)->fd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
+
+  if(GIOP_CONNECTION_GET_FD(server_cnx) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_server: socket_error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  server_cnx->u.ipv4.location.sin_family = AF_INET;
+  server_cnx->u.ipv4.location.sin_addr.s_addr = INADDR_ANY;
+  bind(GIOP_CONNECTION_GET_FD(server_cnx),
+       (struct sockaddr *)&server_cnx->u.ipv4.location,
+       sizeof(struct sockaddr_in));
+
+  fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_SETFD,
+	fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_GETFD, 0)
+	| FD_CLOEXEC);
+  fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_SETFL,
+	fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_GETFL, 0)
+	| O_NONBLOCK);
+
+  n = sizeof(struct sockaddr_in);
+  getsockname(GIOP_CONNECTION_GET_FD(server_cnx),
+	      (struct sockaddr *)&server_cnx->u.ipv4.location, &n);
+
+  gethostname(hn_tmp, sizeof(hn_tmp) - 1);
+
+  hent = gethostbyname(hn_tmp);
+  if(hent) 
+    {
+      if (strchr (hent->h_name, '.'))
+	server_cnx->u.ipv4.hostname = g_strdup(hent->h_name);
+      else
+	{
+	  struct in_addr * addr = (struct in_addr *) hent->h_addr_list[0];
+	  g_assert (hent->h_length == sizeof (struct in_addr) && addr);
+	  server_cnx->u.ipv4.hostname = g_strdup (inet_ntoa (*addr));
+	}
+    }
+  else
+    server_cnx->u.ipv4.hostname = g_strdup(hn_tmp);
+
+  listen(GIOP_CONNECTION_GET_FD(server_cnx), 5);
+
+  giop_connection_add_to_list(GIOP_CONNECTION(server_cnx));
+
+  return server_cnx;
+
+failed:
+  close(GIOP_CONNECTION_GET_FD(server_cnx));
+  GIOP_CONNECTION(server_cnx)->fd = -1;
+  giop_connection_free(GIOP_CONNECTION(server_cnx));
+  server_cnx = NULL;
+  /*
+   * FIXME: GET_LOCK and DEFINE_LOCK never called for server_cnx
+  RELEASE_LOCK(server_cnx);
+   */
+  return NULL;
+}
+
+/*
+ * iiop_connection_server_ipv6
+ *   Outputs: 'server_cnx'
+ *
+ *    Description: Create a special IIOPConnection on which incoming
+ *                 connections come.
+ */
+IIOPConnection *
+iiop_connection_server_ipv6(void)
+{
+#ifdef HAVE_IPV6
+  struct hostent *hent, *hent2;
+
+  char hn_tmp[65];
+  int n;
+  IIOPConnection *server_cnx;
+
+  g_error("IPv6 support is baroquen! (Actually just never worked)");
+
+  server_cnx = g_new0(IIOPConnection, 1);
+  
+  iiop_connection_init(server_cnx, GIOP_CONNECTION_SERVER, IIOP_IPV6);
+  
+  server_cnx->is_serversock = TRUE;
+  GIOP_CONNECTION(server_cnx)->fd = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
+
+  if(GIOP_CONNECTION_GET_FD(server_cnx) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_server_ipv6: socket_error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  server_cnx->u.ipv6.location.sin6_family = AF_INET6;
+  bind(GIOP_CONNECTION_GET_FD(server_cnx),
+       (struct sockaddr *)&server_cnx->u.ipv6.location,
+       sizeof(struct sockaddr_in6));
+  
+  fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_SETFD,
+	fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_GETFD, 0)
+	| FD_CLOEXEC);
+  fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_SETFL,
+	fcntl(GIOP_CONNECTION_GET_FD(server_cnx), F_GETFL, 0)
+	| O_NONBLOCK);
+
+  n = sizeof(struct sockaddr_in6);
+  getsockname(GIOP_CONNECTION_GET_FD(server_cnx), &server_cnx->u.ipv6.location, &n);
+
+  gethostname(hn_tmp, sizeof(hn_tmp) - 1);
+
+  hent = gethostbyname(hn_tmp);
+  if(hent) {
+    hent2 = gethostbyaddr(hent->h_addr, sizeof(server_cnx->u.ipv6.location.sin6_addr), AF_INET6);
+    if(hent2)
+      server_cnx->hostname = g_strdup(hent2->h_name);
+    else
+      server_cnx->hostname = g_strdup(hn_tmp);
+  } else
+    server_cnx->hostname = g_strdup(hn_tmp);
+
+  listen(GIOP_CONNECTION_GET_FD(server_cnx), 5);
+
+  giop_connection_add_to_list(GIOP_CONNECTION(server_cnx));
+
+  return server_cnx;
+
+failed:
+  close(GIOP_CONNECTION_GET_FD(server_cnx));
+  GIOP_CONNECTION(server_cnx)->fd = -1;
+  giop_connection_free(GIOP_CONNECTION(server_cnx));
+  server_cnx = NULL;
+  /*
+   * FIXME: GET_LOCK and DEFINE_LOCK never called for server_cnx
+  RELEASE_LOCK(server_cnx);
+   */
+#endif
+  return NULL;
+}
+
+/*
+ * iiop_connection_server_unix
+ *
+ *   Outputs: 'server_cnx_unix'
+ *
+ *    Side effects: Initializes 'server_cnx_unix' if not initialized.
+ *
+ *    Description: Return a special IIOPConnection on which incoming connections
+ *                 come. If not already initialized, it creates the connection,
+ *	           otherwise it returns the existing one.
+ *	           This is
+ */
+IIOPConnection *
+iiop_connection_server_unix(const char *sockpath)
+{
+  IIOPConnection *server_cnx_unix;
+
+  g_assert(sockpath && *sockpath);
+
+  server_cnx_unix = g_new0(IIOPConnection, 1);
+
+  iiop_connection_init(server_cnx_unix, GIOP_CONNECTION_SERVER, IIOP_USOCK);
+
+  server_cnx_unix->is_serversock = TRUE;
+  GIOP_CONNECTION(server_cnx_unix)->fd = socket(AF_UNIX, SOCK_STREAM, 0);
+
+  if(GIOP_CONNECTION_GET_FD(server_cnx_unix) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_server_unix: socket_error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  strcpy(server_cnx_unix->u.usock.sun_path, sockpath);
+
+  server_cnx_unix->u.usock.sun_family = AF_UNIX;
+  if(bind(GIOP_CONNECTION_GET_FD(server_cnx_unix),
+	  (struct sockaddr *)&server_cnx_unix->u.usock,
+	  SUN_LEN(&server_cnx_unix->u.usock)) != 0) {
+    /* see the comment in iiop_connection_destroy switch as to why we
+       close it here. bad hack */
+    close(GIOP_CONNECTION_GET_FD(server_cnx_unix));
+    GIOP_CONNECTION(server_cnx_unix)->fd = -1;
+    goto failed;
+  }
+
+  fcntl(GIOP_CONNECTION_GET_FD(server_cnx_unix), F_SETFD,
+	fcntl(GIOP_CONNECTION_GET_FD(server_cnx_unix), F_GETFD, 0)
+	| FD_CLOEXEC);
+  fcntl(GIOP_CONNECTION_GET_FD(server_cnx_unix), F_SETFL,
+	fcntl(GIOP_CONNECTION_GET_FD(server_cnx_unix), F_GETFL, 0)
+	| O_NONBLOCK);
+
+  if(listen(GIOP_CONNECTION_GET_FD(server_cnx_unix), 5) != 0)
+    goto failed;
+
+  giop_connection_add_to_list(GIOP_CONNECTION(server_cnx_unix));
+  iiop_unix_socket_list = g_slist_prepend(iiop_unix_socket_list,
+					  server_cnx_unix);
+
+  /*
+   * FIXME: GET_LOCK and DEFINE_LOCK never called for server_cnx_unix
+  RELEASE_LOCK(server_cnx_unix);
+   */
+
+  return server_cnx_unix;
+
+failed:
+  close(GIOP_CONNECTION_GET_FD(server_cnx_unix));
+  GIOP_CONNECTION(server_cnx_unix)->fd = -1;
+  giop_connection_free(GIOP_CONNECTION(server_cnx_unix));
+  server_cnx_unix = NULL;
+  /*
+   * FIXME: GET_LOCK and DEFINE_LOCK never called for server_cnx_unix
+  RELEASE_LOCK(server_cnx_unix);
+   */
+  return NULL;
+}
+
+/*
+ * iiop_unlink_unix_sockets(void)
+ *
+ *    Inputs: None
+ *    Outputs: None
+ *
+ *    Side effects: Modifies iiop_unix_socket_list
+ *    Global data structures used: iiop_unix_socket_list
+ *
+ *    Description:
+ *         Unlinks any Unix server sockets created.
+ *         Called during program termination.
+ */
+static void
+iiop_unlink_unix_sockets(void)
+{
+  GSList *item;
+
+  for (item = iiop_unix_socket_list;
+       item; item = g_slist_next(item)) {
+    GIOPConnection *cnx;
+
+    cnx = GIOP_CONNECTION(item->data);
+    if(cnx->connection_class == GIOP_CONNECTION_SERVER)
+      unlink(IIOP_CONNECTION(cnx)->u.usock.sun_path);
+  }
+
+  if (iiop_unix_socket_list) {
+    g_slist_free(iiop_unix_socket_list);
+    iiop_unix_socket_list = NULL;
+  }
+}
+
+/*
+ * iiop_connection_get
+ *
+ * Inputs: 'host' - the hostname (or dotted quad) of the remote host that
+ *                  will be connected
+ *         'port' - the port number on the above host to connect to.
+ *         'existing_only' - don't create a new connection if
+ *                           an existing one with the specified host:port
+ *                           doesn't exist.
+ *
+ * Outputs: 'cnx' - the connection to the specified host:port, or
+ *                  NULL upon error.
+ *
+ * Description: Returns an IIOPConnection that is connected to the
+ *              specified host:port. If a connection already exists to the
+ *	 	host:port, just returns it. Otherwise, calls
+ *	 	'iiop_connection_new' to create a new connection
+ *	 	to host:port.
+ */
+IIOPConnection *
+iiop_connection_get(const char *host, gushort port, gboolean existing_only)
+{
+  IIOPConnection *cnx = NULL, *tmp;
+  GList *link;
+
+  g_assert(host);
+  g_assert(port);
+
+  GET_LOCK(giop_connection_list);
+  for(link = giop_connection_list.list; link; link = link->next)
+    {
+      tmp = IIOP_CONNECTION(link->data);
+      if(GIOP_CONNECTION(tmp)->connection_type != GIOP_CONNECTION_IIOP)
+	continue;
+
+      if(!GIOP_CONNECTION(tmp)->is_valid)
+	continue;
+
+      if(GIOP_CONNECTION(tmp)->connection_class != GIOP_CONNECTION_CLIENT)
+	continue;
+
+      if(IIOP_CONNECTION(tmp)->icnxtype != IIOP_IPV4)
+	continue;
+
+      if(!strcmp(host, tmp->u.ipv4.hostname)
+	 && htons(port) == tmp->u.ipv4.location.sin_port) {
+	cnx = tmp;
+	break;
+      }
+    }
+  RELEASE_LOCK(giop_connection_list);
+
+  if(!cnx && !existing_only)
+    cnx = iiop_connection_new(host, port);
+
+  return cnx;
+}
+
+
+/*
+ * iiop_connection_new
+ *
+ * Inputs: same meanings as in 'iiop_connection_get'
+ * Outputs: 'retval' - newly created IIOPConnection
+ *
+ * Description: Allocates and initializes a new IIOPConnection,
+ *              turns 'host' into an IP address, and then makes a TCP
+ *              connection to host:port. Adds it to the list of active
+ *              connections.
+ */
+IIOPConnection *
+iiop_connection_new(const char *host, gushort port)
+{
+  IIOPConnection *retval;
+
+  g_return_val_if_fail(host != NULL && port != 0, NULL);
+
+  retval = g_new0(IIOPConnection, 1);
+
+  iiop_connection_init(retval, GIOP_CONNECTION_CLIENT, IIOP_IPV4);
+
+  GIOP_CONNECTION(retval)->fd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
+  if(GIOP_CONNECTION_GET_FD(retval) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_new: socket_error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  retval->u.ipv4.hostname = g_strdup(host);
+
+  retval->u.ipv4.location.sin_port = htons(port);
+  retval->u.ipv4.location.sin_family = AF_INET;
+  if(!inet_aton(host, &retval->u.ipv4.location.sin_addr))
+    {
+      struct hostent *hent;
+      hent = gethostbyname(host);
+      if(!hent) {
+	/* a (char *)h_strerror(int) function would be nice here */
+	ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_new: gethostbyname error: %d\n", h_errno);
+	goto failed;
+      }
+      memcpy(&retval->u.ipv4.location.sin_addr, hent->h_addr, (size_t) sizeof(retval->u.ipv4.location.sin_addr));
+    }
+  if(connect(GIOP_CONNECTION_GET_FD(retval), (struct sockaddr *)&retval->u.ipv4.location, sizeof(retval->u.ipv4.location)) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_new: connect error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug,
+	      "iiop_connection_new connect [%d] to %s:%d\n",
+	      GIOP_CONNECTION_GET_FD(retval),
+	      host, (guint)port);
+
+
+  fcntl(GIOP_CONNECTION_GET_FD(retval), F_SETFD, FD_CLOEXEC);
+  fcntl(GIOP_CONNECTION_GET_FD(retval), F_SETFL,
+	fcntl(GIOP_CONNECTION_GET_FD(retval), F_GETFL, 0)
+	| O_NONBLOCK);
+
+  GIOP_CONNECTION(retval)->was_initiated = TRUE;
+  GIOP_CONNECTION(retval)->is_auth = TRUE;
+
+  giop_connection_add_to_list(GIOP_CONNECTION(retval));
+
+  return retval;
+
+failed:
+  close(GIOP_CONNECTION_GET_FD(retval));
+  GIOP_CONNECTION(retval)->fd = -1;
+  giop_connection_free(GIOP_CONNECTION(retval));
+  return NULL;
+}
+
+/*
+ * iiop_connection_unix_get
+ *
+ *   Inputs: 'sockpath' - Of the format 'path'
+ *
+ *   Outputs: 'cnx' - the connection to the specified path, or
+ *             NULL upon error.
+ *
+ *    Description: Returns an IIOPConnection that is connected to the
+ *                 specified UNIX socket, if possible. If a connection
+ *                 already exists, just returns it. Otherwise,
+ *                 calls 'iiop_connection_unix_new' to create a new
+ *                 connection to sockpath.
+ */
+IIOPConnection *
+iiop_connection_unix_get(const char *sockpath, gboolean existing_only)
+{
+  IIOPConnection *cnx = NULL, *tmp;
+  GList *link;
+
+  GET_LOCK(giop_connection_list);
+  for(link = giop_connection_list.list; link; link = link->next)
+    {
+      tmp = IIOP_CONNECTION(link->data);
+
+      if(GIOP_CONNECTION(tmp)->connection_type != GIOP_CONNECTION_IIOP)
+	continue;
+
+      if(!GIOP_CONNECTION(tmp)->is_valid)
+	continue;
+
+      if(GIOP_CONNECTION(tmp)->connection_class != GIOP_CONNECTION_CLIENT)
+	continue;
+
+      if(IIOP_CONNECTION(tmp)->icnxtype != IIOP_USOCK)
+	continue;
+
+      if(!strcmp(sockpath, tmp->u.usock.sun_path)) {
+	cnx = tmp;
+	break;
+      }
+    }
+  RELEASE_LOCK(giop_connection_list);
+
+  if(!cnx && !existing_only)
+    cnx = iiop_connection_unix_new(sockpath);
+
+  return cnx;
+}
+
+/*
+ * iiop_connection_unix_new
+ *
+ *   Inputs:
+ *
+ *    Outputs: 'retval' - newly created IIOPConnection, or NULL upon error
+ *
+ *    Description: Creates a connection to a UNIX socket (if possible)
+ *                 Adds it to the list of active connections.
+ */
+static IIOPConnection *
+iiop_connection_unix_new(const char *sockpath)
+{
+  IIOPConnection *retval;
+
+  retval = g_new0(IIOPConnection, 1);
+
+  retval->u.usock.sun_family = AF_UNIX;
+
+  g_snprintf(retval->u.usock.sun_path,
+	     sizeof(retval->u.usock.sun_path), "%s", sockpath);
+
+  iiop_connection_init(retval, GIOP_CONNECTION_CLIENT, IIOP_USOCK);
+
+  GIOP_CONNECTION(retval)->fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if(GIOP_CONNECTION_GET_FD(retval) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_new: socket_error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  if(connect(GIOP_CONNECTION_GET_FD(retval), (struct sockaddr *)&retval->u.usock, SUN_LEN(&retval->u.usock)) < 0) {
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug, "iiop_connection_new: connect error: %s\n", strerror(errno));
+    goto failed;
+  }
+
+  GIOP_CONNECTION(retval)->was_initiated = TRUE;
+  GIOP_CONNECTION(retval)->is_auth = TRUE;
+
+  fcntl(GIOP_CONNECTION_GET_FD(retval), F_SETFD, FD_CLOEXEC);
+  fcntl(GIOP_CONNECTION_GET_FD(retval), F_SETFL,
+	fcntl(GIOP_CONNECTION_GET_FD(retval), F_GETFL, 0)
+	| O_NONBLOCK);
+
+  giop_connection_add_to_list(GIOP_CONNECTION(retval));
+
+  ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug,
+	      "iiop_connection_unix_new connect [%d] to %s\n",
+	      GIOP_CONNECTION_GET_FD(retval),
+	      sockpath);
+
+  return retval;
+
+failed:
+  close(GIOP_CONNECTION_GET_FD(retval));
+  GIOP_CONNECTION(retval)->fd = -1;
+  giop_connection_free(GIOP_CONNECTION(retval));
+  return NULL;
+}
+
+/*
+ * iiop_connection_server_accept
+ *    Inputs: 'connection' - a server IIOPConnection.
+ *
+ *    Description: Performs accept(), TCP wrapper, access checking and related
+ *                 duties on a connection
+ */
+int allow_severity = LOG_INFO, deny_severity = LOG_NOTICE;
+
+#if defined(HAVE_HOSTS_ACCESS) && defined(HAVE_TCPD_H)
+DEFINE_LOCK(tcp_wrappers_usage);
+
+#endif
+static void
+iiop_connection_server_accept(GIOPConnection *connection)
+{
+  struct sockaddr sock;
+  socklen_t n;
+  int newfd;
+  GIOPConnection *newcnx;
+
+//  printk("iiop_conncetion_server_accept( %d )\n", 
+//         GIOP_CONNECTION_GET_FD(connection));
+
+  n = sizeof(sock);
+
+  switch(IIOP_CONNECTION(connection)->icnxtype) {
+  case IIOP_IPV4: sock.sa_family = AF_INET; break;
+  case IIOP_USOCK: sock.sa_family = AF_UNIX; break;
+  case IIOP_IPV6:
+#ifdef HAVE_IPV6
+    sock.sa_family = AF_INET6;
+#endif
+    break;
+  }
+
+  newfd = accept(GIOP_CONNECTION_GET_FD(connection), &sock, &n);
+
+#if defined(HAVE_HOSTS_ACCESS) && defined(HAVE_TCPD_H)
+  /* tcp wrappers access checking */
+  switch(IIOP_CONNECTION(connection)->icnxtype) {
+  case IIOP_IPV4:
+    {
+      struct request_info request;
+
+      GET_LOCK(tcp_wrappers_usage);
+
+      request_init(&request, RQ_DAEMON, argv0_val, RQ_FILE, newfd, 0);
+
+      fromhost(&request);
+      if(!hosts_access(&request)) {
+	syslog(deny_severity, "[orbit] refused connect from %s", eval_client(&request));
+	close(newfd); newfd = -1;
+      } else
+	syslog(allow_severity, "[orbit] connect from %s", eval_client(&request));
+
+      RELEASE_LOCK(tcp_wrappers_usage);
+    }
+    break;
+  default:
+    /* No access controls for these transports */
+    break;
+  }
+#endif
+
+  if(newfd >= 0) {
+    newcnx = GIOP_CONNECTION(iiop_connection_from_fd(newfd,
+						     IIOP_CONNECTION(connection)));
+    GIOP_CONNECTION(newcnx)->orb_data = connection->orb_data;
+    switch(IIOP_CONNECTION(connection)->icnxtype) {
+    case IIOP_USOCK: newcnx->is_auth = TRUE; break;
+    default:
+      break;
+    }
+  }
+}
+
+/*
+ * iiop_connection_destroy
+ *
+ *    Inputs: 'iiop_connection' - an IIOPConnection to be finalized
+ *
+ *    Side effects: invalidates 'iiop_connection' for use as an IIOPConnection
+ *
+ *    Description: Performs the IIOP-specific parts of connection shutdown,
+ *    including sending a CLOSECONNECTION message to the remote side.
+ */
+static void
+iiop_connection_destroy(IIOPConnection *iiop_connection)
+{
+  const GIOPMessageHeader mh = {"GIOP", {1,0}, FLAG_ENDIANNESS,
+				GIOP_CLOSECONNECTION, 0};
+
+  switch(iiop_connection->icnxtype) {
+  case IIOP_IPV4:
+    ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug,
+		"iiop_connection_destroy connect [%d] of %s:%d\n",
+		GIOP_CONNECTION_GET_FD(iiop_connection),
+		iiop_connection->u.ipv4.hostname,
+		ntohs(iiop_connection->u.ipv4.location.sin_port));
+    g_free(iiop_connection->u.ipv4.hostname);
+    break;
+  case IIOP_IPV6:
+#ifdef HAVE_IPV6
+    g_free(iiop_connection->u.ipv6.hostname);
+#else
+    g_warning("IPv6 unsupported, can't free it!");
+#endif
+    break;
+  case IIOP_USOCK:
+    /* why do we check if fd is > 0 here?
+       the orb code tries to reuse existing socket connection points.
+       If binding to any of those fails because another process is using it,
+       we don't want to unlink the other server's socket!
+       if the bind fails, iiop_connection_server_unix closes the fd for us */
+    if(GIOP_CONNECTION(iiop_connection)->connection_class == GIOP_CONNECTION_SERVER
+       && GIOP_CONNECTION(iiop_connection)->fd >= 0)
+      unlink(iiop_connection->u.usock.sun_path);
+    break;
+  default:
+    break;
+  }
+
+  if(GIOP_CONNECTION_GET_FD(iiop_connection) >= 0) {
+    if(GIOP_CONNECTION(iiop_connection)->is_valid
+       && !GIOP_CONNECTION(iiop_connection)->was_initiated)
+      {
+	write(GIOP_CONNECTION_GET_FD(iiop_connection), &mh, sizeof(mh));
+      }
+
+    shutdown(GIOP_CONNECTION_GET_FD(iiop_connection), 2);
+    close(GIOP_CONNECTION_GET_FD(iiop_connection));
+    GIOP_CONNECTION(iiop_connection)->fd = -1;
+  }
+}
+
+static int giop_nloops = 0;
+
+void giop_main_quit(void) { giop_nloops--; }
+
+void
+giop_main(void)
+{
+  int looplevel;
+
+  looplevel = ++giop_nloops;
+
+  while(giop_nloops > 0) {
+
+    giop_main_iterate(TRUE);
+
+    if(giop_nloops != looplevel) {
+      giop_nloops = --looplevel;
+      return;
+    }
+  }
+}
+
+GIOPRecvBuffer *
+giop_main_next_message(gboolean blocking)
+{
+  return giop_main_next_message_2(blocking, NULL);
+}
+
+GIOPRecvBuffer *
+giop_main_next_message_2(gboolean blocking,
+			 GIOPConnection *monitor)
+{
+    GIOPConnection *connection;
+    GIOPRecvBuffer *recv_buffer = NULL;
+
+    do {
+      recv_buffer = giop_received_list_pop();
+//      printk("giop_main_next_message_2 : recv_buffer = 0x%08X\n", recv_buffer);
+      if(recv_buffer)
+	break;
+
+      connection = giop_check_connections(blocking);
+//      printk("giop_main_next_message_2 : connection = 0x%08X\n", connection);
+      if(!connection) 
+      {
+              return NULL;
+      }
+      
+      if(GIOP_CONNECTION_GET_FD(connection) < 0) {
+	g_assert(!"connection has -ve fd!");
+      }
+
+//      printk("giop_main_next_message_2 : connection class = %d\n", 
+//             connection->connection_class);
+      if(connection->connection_class == GIOP_CONNECTION_SERVER)
+	iiop_connection_server_accept(connection);
+      else
+	recv_buffer = giop_recv_message_buffer_use(connection);
+
+      if(monitor && !monitor->is_valid) 
+      {
+              return NULL;
+      }
+
+    } while(!recv_buffer);
+
+    return recv_buffer;
+}
+
+void
+giop_main_handle_connection(GIOPConnection *connection)
+{
+  GIOPRecvBuffer *recv_buffer;
+
+  //printk("giop_main_handle_connection\n");
+
+  g_return_if_fail(connection != NULL);
+  g_return_if_fail(connection->is_valid);
+
+  if(connection->connection_class == GIOP_CONNECTION_SERVER) {
+    iiop_connection_server_accept(connection);
+    return;
+  } else
+    recv_buffer = giop_recv_message_buffer_use(connection);
+
+  if(recv_buffer) {
+    if(IIOPIncomingMessageHandler)
+      IIOPIncomingMessageHandler(recv_buffer);
+    else
+      giop_received_list_push(recv_buffer);
+  }
+}
+
+/*
+ * giop_main_handle_connection_exception
+ *
+ * Input: GIOPConnection *connection
+ *
+ * Output:
+ *
+ * Side effects: invalidates connection
+ *
+ * Description:
+ *     When poll() or select() indicates that a file descriptor
+ *     has been closed at the remote end, we must invalidate the associated
+ *     GIOPConnection structure.
+ */
+void
+giop_main_handle_connection_exception(GIOPConnection *connection)
+{
+  g_return_if_fail(connection != NULL);
+  g_return_if_fail(connection->is_valid);
+
+//  printk("giop_main_handle_connection_exception(0x%X)\n", GIOP_CONNECTION_GET_FD(connection));
+
+  giop_connection_ref(connection);
+
+  giop_connection_remove_from_list(connection);
+
+  shutdown(GIOP_CONNECTION_GET_FD(connection), 2);
+  close(GIOP_CONNECTION_GET_FD(connection));
+  GIOP_CONNECTION(connection)->fd = -1;
+  connection->is_valid = FALSE;
+
+  if(connection->incoming_msg) {
+    giop_recv_buffer_unuse(connection->incoming_msg);
+    connection->incoming_msg = NULL;
+  }
+
+  giop_connection_unref(connection);
+}
+
+/*
+ * giop_main_iterate
+ *
+ *    Input: 'blocking' - flag to indicate whether to wait for incoming
+ *           messages (TRUE), or whether to return immediately if no
+ *           incoming messages are available (FALSE).
+ *    Output: None
+ *    Description:
+ *           Gets the next message into recv_buffer (see
+ *           giop_main_next_message) If we have a handler for incoming
+ *           messages, then pass recv_buffer to the handler (handler
+ *           becomes the new owner of recv_buffer's contents). Otherwise,
+ *           tosses it onto the list of received-but-unprocessed buffers.
+ *
+ *    Warnings:
+ *           If you don't have an IIOPIncomingMessageHandler set, you're
+ *           probably really screwed in the long run.
+ */
+void
+giop_main_iterate(gboolean blocking)
+{
+  GIOPRecvBuffer *recv_buffer;
+
+//  printk("giop_main_iterate: blocking: %d\n", blocking);
+schedule();
+
+  recv_buffer = giop_main_next_message(blocking);
+
+//  printk("giop_main_iterate: recv_buffer = 0x%08X\n", recv_buffer);
+
+  if(recv_buffer) {
+    if(IIOPIncomingMessageHandler)
+      IIOPIncomingMessageHandler(recv_buffer);
+    else
+      giop_received_list_push(recv_buffer);
+  }
+}
+
+/*
+ * giop_check_connections
+ *
+ *    Inputs: 'block_for_reply' - If no incoming data is immediately available
+ *            should this routine wait for incoming data (TRUE) or return
+ *            immediately (FALSE).
+ *
+ *    Outputs: 'connection' - the first connection that has incoming
+ *             data available for reading (supposedly a GIOP message, but
+ *             could be anything).
+ *
+ *    Side effects: Removes closed connections from the active list.
+ *
+ *    Global data structures used: giop_connection_list
+ *    
+ *    Description: Does a poll or select (OS-dependant) on the list of file
+ *                 descriptors in giop_connection_list.
+ *
+ * 		   If a file descriptor has been closed, call
+ * 		   giop_connection_handle_exception() on it and (as
+ * 		   appropriated by 'block_for_reply') either return
+ * 		   NULL or do another poll/select.
+ * 	  
+ * 		   If a file descriptor has data available for
+ * 		   reading, find the associated GIOPConnection (using
+ * 		   giop_connection_list.fd_to_connection_mapping) and
+ * 		   return that.
+ * 		  
+ */
+GIOPConnection *
+giop_check_connections(gboolean block_for_reply)
+{
+  GIOPConnection *connection = NULL;
+  int pollret;
+  int numcnx_checks;
+  int i;
+#ifndef USE_POLL
+  fd_set selectset_rd, selectset_ex;
+
+  struct timeval immediate_timeout = {0,0};
+#endif
+
+//  printk("giop_check_connections\n");
+  
+ do_read_msg:
+
+  if(!giop_connection_list.list) 
+  {
+//          printk("giop_check_connections : list = NULL\n");
+	  BUG();
+          return NULL;
+  }
+  
+#if 0
+  giop_connection_list_recreate(); /* easiest way to get valid
+				      select sets... */
+#endif
+
+#ifdef USE_POLL
+  numcnx_checks = giop_connection_list.pollset->len;
+#else
+  memcpy(&selectset_rd, &giop_connection_list.selectset_rd,
+	 sizeof(selectset_rd));
+  memcpy(&selectset_ex, &giop_connection_list.selectset_ex,
+	 sizeof(selectset_ex));
+
+  numcnx_checks = giop_connection_list.max_fd+1;
+#endif
+
+ restart:
+#ifdef USE_POLL
+  pollret = poll((struct pollfd *)giop_connection_list.pollset->data,
+		 giop_connection_list.pollset->len,
+		 block_for_reply?-1:0);
+
+#if KORBIT_DEBUG_WRITING
+{
+  int ix;
+  struct pollfd *fds = (struct pollfd *)giop_connection_list.pollset->data;
+//  printk("back from poll(#fds = %d, block = %d) = %d)\n", giop_connection_list.pollset->len, block_for_reply, pollret);
+//  for (ix = 0; ix < giop_connection_list.pollset->len; ix++)
+ //   printk("  [fd = 0x%X, event = 0x%X, revent = 0x%X]\n", 
+//           fds[ix].fd, fds[ix].events, fds[ix].revents);
+
+}
+#endif /* KORBIT_DEBUG_WRITING */
+
+
+#     else /* !USE_POLL */
+
+  {
+    pollret = select (giop_connection_list.max_fd + 1,
+		      &selectset_rd,
+		      NULL, &selectset_ex,
+		      block_for_reply?NULL:&immediate_timeout);
+  }
+#     endif /* !USE_POLL */
+
+//  printk("giop_check_connections : pollret == %d\n", pollret);
+  if(pollret <= 0) {
+    if(pollret < 0) {
+      if(errno == EINTR)
+	goto restart;
+      else
+	g_warning("Error code from select/poll: %s", g_strerror(errno));
+    } else
+      return NULL;
+  }
+
+  /* Check for data to be read on the fd's.
+     Note we have to do the hangup/exception checking in a separate loop,
+     because there may be data waiting to be read on a connection that the
+     other end has closed. */
+  for(i = 0; i < numcnx_checks; i++) {
+          struct fd_hash_elem *el;
+          
+#ifdef USE_POLL
+    struct pollfd *p = 
+      &g_array_index(giop_connection_list.pollset,
+		     struct pollfd, 
+		     i);
+    g_assert(p->fd <= giop_connection_list.max_fd);
+#ifndef __KORBIT__
+    connection = giop_connection_list.fd_to_connection_mapping->pdata[p->fd];
+#else
+    el = g_hash_table_lookup(giop_connection_list.fd_to_connection_mapping,
+                             &(p->fd));
+    if (el)
+            connection = el->cnx;
+#endif
+    if(p->revents & POLLIN)
+      goto got_connection;
+#else
+#ifndef __KORBIT__
+    connection = giop_connection_list.fd_to_connection_mapping->pdata[i];
+#else
+    el = g_hash_table_lookup(giop_connection_list.fd_to_connection_mapping,
+                             &i);
+    if (el)
+            connection = el->cnx;
+#endif
+    if (FD_ISSET(i, &selectset_rd)) {
+      goto got_connection;
+    }
+#endif    
+  }
+
+  /* Handle fd exceptions */
+  for(i = 0; i < numcnx_checks; i++)
+    {
+              struct fd_hash_elem *el;
+#ifdef USE_POLL
+      struct pollfd *p = 
+      &g_array_index(giop_connection_list.pollset,
+		     struct pollfd, 
+		     i);
+
+      g_assert(p->fd <= giop_connection_list.max_fd);
+      if(p->revents & (POLLHUP|POLLNVAL)) {
+#ifndef __KORBIT__
+	connection = giop_connection_list.fd_to_connection_mapping->pdata[p->fd];
+#else
+        el = g_hash_table_lookup(giop_connection_list.fd_to_connection_mapping,
+                                 &(p->fd));
+        if (el)
+                connection = el->cnx;
+#endif
+	giop_main_handle_connection_exception(connection);
+      }
+#else /* !USE_POLL */
+      if(FD_ISSET(i, &selectset_ex)) {
+#ifndef __KORBIT__
+	connection = giop_connection_list.fd_to_connection_mapping->pdata[i];
+#else
+        el = g_hash_table_lookup(giop_connection_list.fd_to_connection_mapping,
+                                 &i);
+        if (el)
+                connection = el->cnx;
+#endif
+	giop_main_handle_connection_exception(connection);
+      }
+#endif /* !USE_POLL */
+    }
+
+  /* Only reached if we didn't find a connection to read data from */
+  if(block_for_reply)
+    goto do_read_msg;
+
+ got_connection:
+//  printk("giop_check_connections : got connection\n");
+  return connection;
+}
+
diff -urN linux-2.4.1/net/korbit/IIOP/encoders.c linux-2.4.1-korbit/net/korbit/IIOP/encoders.c
--- linux-2.4.1/net/korbit/IIOP/encoders.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/encoders.c	Thu Feb  1 11:46:51 2001
@@ -0,0 +1,46 @@
+#include "config.h"
+#include <string.h>
+#include "IIOP.h"
+
+ENCODER_DEC(IOP_ServiceContext)
+{
+  APA(&mem->context_id, sizeof(mem->context_id));
+  ENCODER_CALL(CORBA_sequence_octet, &mem->context_data);
+}
+
+ENCODER_DEC(IOP_ServiceContextList)
+{
+  int i;
+
+  if(!mem)
+    {
+      APA((gpointer)giop_scratch_space, sizeof(mem->_length));
+      return;
+    }
+
+  APA(&mem->_length, sizeof(mem->_length));
+
+  for(i = 0; i < mem->_length; i++)
+    ENCODER_CALL(IOP_ServiceContext, &mem->_buffer[i]);
+}
+
+ENCODER_DEC(CORBA_sequence_octet)
+{
+  if(!mem)
+    {
+      APA((gpointer)giop_scratch_space, sizeof(mem->_length));
+      return;
+    }
+
+  APIA(&mem->_length, sizeof(mem->_length));
+  if(mem->_length > 0)
+    AP(mem->_buffer, mem->_length);
+}
+
+ENCODER_DEC(CORBA_char)
+{
+  GIOP_unsigned_long len = strlen(mem) + 1;
+
+  APIA(&len, sizeof(len));
+  AP(mem, len);
+}
diff -urN linux-2.4.1/net/korbit/IIOP/giop-msg-buffer.c linux-2.4.1-korbit/net/korbit/IIOP/giop-msg-buffer.c
--- linux-2.4.1/net/korbit/IIOP/giop-msg-buffer.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/giop-msg-buffer.c	Fri Feb  2 01:23:46 2001
@@ -0,0 +1,1443 @@
+/* The big picture:
+ * For every outgoing request, we have to have the network-ready data
+ * somewhere in memory.
+ *
+ * Using writev, any pieces that do not need endian conversion can
+ * be written in-place.
+ *
+ * The pieces that do need endian conversion can be put into one or more
+ * buffers.
+ *
+ * WHOA WHOA newsflash
+ * Because IIOP lets the message sender specify the endianness,
+ * we do not need to do endian conversion _ever_! The receiver can do all
+ * conversions if need be, or if they are the same endianness as sender they
+ * can just pull it in right off the wire :)
+ * 
+ */
+
+#include "config.h"
+#include "iiop-endianP.h"
+#include <string.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <string.h>
+
+#ifdef HAVE_POLL
+#  include <sys/poll.h>
+#else
+#  include <sys/types.h>
+#  include <sys/time.h>
+#endif
+#include "IIOP.h"
+#include "IIOP-private.h"
+
+#ifdef HAVE_LIMITED_WRITEV
+#define writev g_writev
+#endif
+
+/*
+#ifdef O_NONBLOCK
+#undef O_NONBLOCK
+#endif
+#define O_NONBLOCK 0
+*/
+
+
+/* type defs */
+
+#ifdef        __GNUC__
+#define       PACKED __attribute__((packed))
+#else
+#define       PACKED
+#endif
+
+/*
+ * Overlaps with struct _GIOPMessageHeader on purpose
+ *  - we save time because this stuff never changes
+ */
+struct _GIOPMessageHeaderConstants {
+  GIOP_char magic[4];
+  GIOP_char GIOP_version[2];
+  GIOP_octet flags;
+} PACKED;
+
+/* functions */
+static gint giop_recv_decode_message(GIOPRecvBuffer *buf);
+static gboolean num_on_list(GIOP_unsigned_long num,
+			    const GIOP_unsigned_long *request_ids,
+			    GIOP_unsigned_long req_count);
+static gint giop_recv_reply_decode_message(GIOPRecvBuffer *buf);
+static gint giop_recv_request_decode_message(GIOPRecvBuffer *buf);
+static gint giop_recv_locate_reply_decode_message(GIOPRecvBuffer *buf);
+static gint giop_recv_locate_request_decode_message(GIOPRecvBuffer *buf);
+static GIOPRecvBuffer *giop_received_list_check_reply(GIOP_unsigned_long request_id);
+
+#ifdef NOT_REENTRANT
+extern DEFINE_LOCK(iiop_connection_list);
+#endif
+GList *iiop_connection_list = NULL;
+
+/* global variables */
+char giop_scratch_space[2048];
+
+static const struct _GIOPMessageHeaderConstants
+giop_message_header_constants = {
+  "GIOP",
+  {1,0},
+  FLAG_ENDIANNESS,
+};
+
+struct iovec
+giop_first_message_vec = {NULL,
+			  sizeof(struct _GIOPMessageHeaderConstants)};
+
+DEFINE_LOCK(sendbufferlist);
+GSList *sendbufferlist = NULL;
+
+DEFINE_LOCK(recvbufferlist);
+GSList *recvbufferlist = NULL;
+
+DEFINE_LOCK(incoming_bufs);
+GList *incoming_bufs = NULL; /* List of incoming messages that had to be
+				shunted aside */
+
+DEFINE_LOCK(sendbuffers);
+DEFINE_LOCK(recvbuffers);
+GMemChunk *sendbuffers = NULL, *recvbuffers = NULL;
+
+DEFINE_LOCK(request_id_counter);
+GIOP_unsigned_long request_id_counter;
+
+#if 0
+inline
+void giop_message_buffer_append_iovec(GIOPMessageBuffer *msgbuf,
+				      const struct iovec *iovec)
+{
+  /* g_print("Appending iovec %d bytes @ %p\n", iovec->iov_len, iovec->iov_base); */
+  g_array_append_val(msgbuf->iovecs, *iovec);
+}
+#else
+#define giop_message_buffer_append_iovec(msgbuf, iovec) g_array_append_val((msgbuf)->iovecs, *(iovec))
+#endif
+
+void
+giop_message_buffer_init(void)
+{
+  giop_first_message_vec.iov_base = (gpointer)&giop_message_header_constants;
+  INIT_LOCK(sendbufferlist);
+  INIT_LOCK(recvbufferlist);
+  request_id_counter = 1;
+  INIT_LOCK(request_id_counter);
+
+  INIT_LOCK(sendbuffers);
+  sendbuffers = g_mem_chunk_create(GIOPSendBuffer, 2, G_ALLOC_ONLY);
+  INIT_LOCK(recvbuffers);
+  recvbuffers = g_mem_chunk_create(GIOPRecvBuffer, 2, G_ALLOC_ONLY);
+}
+
+static void
+giop_message_buffer_new(GIOPMessageBuffer *buf)
+{
+  buf->iovecs = g_array_new(FALSE, FALSE, sizeof(struct iovec));
+}
+
+#define STRUCT_OFFSET(t, f) ((int) ((char*) &((t*) 0)->f))
+
+/* Send buffers only */
+static GIOPSendBuffer *
+giop_send_buffer_new(void)
+{
+  GIOPSendBuffer *msgbuf;
+  struct iovec firstvec;
+
+  GET_LOCK(sendbuffers);
+  msgbuf = g_chunk_new(GIOPSendBuffer, sendbuffers);
+  RELEASE_LOCK(sendbuffers);
+
+  giop_message_buffer_new(GIOP_MESSAGE_BUFFER(msgbuf));
+
+  giop_message_buffer_append_iovec(GIOP_MESSAGE_BUFFER(msgbuf),
+				   &giop_first_message_vec);
+
+  firstvec.iov_base = &(GIOP_MESSAGE_BUFFER(msgbuf)->message_header.message_type);
+  firstvec.iov_len = sizeof(GIOPMessageHeader)
+    - STRUCT_OFFSET(GIOPMessageHeader, message_type);
+  GIOP_MESSAGE_BUFFER(msgbuf)->message_header.message_size = 0;
+
+  msgbuf->indirects = g_mem_chunk_create(char[GIOP_INDIRECT_CHUNK_SIZE],
+					 2, G_ALLOC_ONLY);
+
+  giop_message_buffer_append_iovec(GIOP_MESSAGE_BUFFER(msgbuf), &firstvec);
+
+  return msgbuf;
+}
+
+gint
+giop_send_buffer_write(GIOPSendBuffer *send_buffer)
+{
+  gulong nvecs;
+  glong res, sum, t;
+  struct iovec *curvec;
+  int fd;
+  GIOPConnection *cnx;
+  gint retval = -1;
+
+//  printf("giop_send_buffer_write\n");
+
+  cnx = GIOP_MESSAGE_BUFFER(send_buffer)->connection;
+  if(!cnx->is_valid)
+    return -1;
+
+  fd = GIOP_CONNECTION_GET_FD(cnx);
+  nvecs = GIOP_MESSAGE_BUFFER(send_buffer)->iovecs->len;
+  curvec = (struct iovec *)GIOP_MESSAGE_BUFFER(send_buffer)->iovecs->data;
+
+#if defined(ORBIT_DEBUG) && 0
+  g_print("Message of length %d looks like:\n",
+	  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_size);
+{ int i = 0;
+  for(sum = 0; i < nvecs; i++) {
+    sum += curvec[i].iov_len;
+    g_print("    [%p, %d]: %d\n", curvec[i].iov_base, curvec[i].iov_len,
+	    sum);
+  }
+}
+#endif
+
+  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
+  res = writev(fd, curvec, nvecs);
+//  printk("writev wrote %d byte\n", res);
+
+  sum = (GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_size + sizeof(GIOPMessageHeader));
+  if(res < sum) {
+    if(res < 0) {
+//printf("writev returned %d\n", res);
+      if(errno != EAGAIN) {
+	giop_main_handle_connection_exception(cnx);
+	goto out;
+      }
+
+      res = 0;
+    }
+
+    /* wrote 7, iovecs 3, 2, 2, 4:
+       0 + 3 !> 7
+       3 + 2 !> 7
+       5 + 2 !> 7
+     */
+
+    for(t = 0; ; t += curvec->iov_len, curvec++, nvecs--) {
+      if((t + curvec->iov_len) > res)
+	break;
+    }
+    if((res - t) > 0) {
+      curvec->iov_len -= (res - t);
+      curvec->iov_base = (gpointer)((char *)curvec->iov_base + (res - t));
+    }
+
+
+    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
+    t = writev(fd, curvec, nvecs);
+
+    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
+
+    if((t < 0) || ((res + t) < sum)) {
+//printf("crap, t = %d   res = %d   sum = %d\n", t, res, sum);
+	giop_main_handle_connection_exception(cnx);
+	goto out;
+    }
+  }
+
+  retval = 0;
+
+ out:
+
+  return retval;
+}
+
+static GIOPSendBuffer *
+giop_send_buffer_use(GIOPConnection *connection)
+{
+  GIOPSendBuffer *retval;
+
+  if(!connection->is_valid)
+    return NULL;
+
+  GET_LOCK(sendbufferlist);
+
+  if(sendbufferlist)
+    {
+      GSList *head;
+
+      retval = sendbufferlist->data;
+
+      head = sendbufferlist;
+      sendbufferlist = g_slist_remove_link(sendbufferlist, sendbufferlist);
+      g_slist_free_1 (head);
+
+      g_array_set_size(GIOP_MESSAGE_BUFFER(retval)->iovecs, 2);
+      GIOP_MESSAGE_BUFFER(retval)->message_header.message_size = 0;
+    }
+  else
+    retval = giop_send_buffer_new();
+
+  RELEASE_LOCK(sendbufferlist);
+  
+  giop_connection_ref(connection);
+  GIOP_MESSAGE_BUFFER(retval)->connection = connection;
+
+  g_mem_chunk_reset(retval->indirects);
+  retval->indirect = g_chunk_new(gpointer, retval->indirects);
+#ifdef ORBIT_DEBUG
+  memset(retval->indirect, '\xFE', GIOP_INDIRECT_CHUNK_SIZE);
+#endif
+  retval->indirect_used = 0;
+
+  return retval;
+}
+
+GIOPSendBuffer *
+giop_send_reply_buffer_use(GIOPConnection *connection,
+			   const IOP_ServiceContextList *service_context,
+			   GIOP_unsigned_long request_id,
+			   GIOPReplyStatusType reply_status)
+{
+  GIOPSendBuffer *send_buffer;
+
+  send_buffer = giop_send_buffer_use(connection);
+
+  if(!send_buffer)
+    return NULL;
+
+  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_type = GIOP_REPLY;
+
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(GIOP_unsigned_long));
+  if(!service_context) {
+    static const GIOP_unsigned_long sc_zero_int = 0;
+    AP(&sc_zero_int, sizeof(service_context->_length));
+  } else {
+    int i, n;
+    n = service_context->_length;
+    AP(&service_context->_length, sizeof(service_context->_length));
+    for(i = 0; i < n; i++) {
+      int j, o;
+      CORBA_sequence_octet *seqo;
+
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				       sizeof(GIOP_unsigned_long));
+      AP(&service_context->_buffer[i].context_id,
+	 sizeof(service_context->_buffer[i].context_id));
+      seqo = &service_context->_buffer[i].context_data;
+      o = seqo->_length;
+      AP(&seqo->_length, sizeof(GIOP_unsigned_long));
+      for(j = 0; j < o; j++)
+	AP(seqo->_buffer, seqo->_length);
+    }
+  }
+  send_buffer->message.u.reply.request_id = request_id;
+  send_buffer->message.u.reply.reply_status = reply_status;
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(GIOP_unsigned_long));
+  AP(&send_buffer->message.u.reply.request_id,
+     sizeof(GIOP_unsigned_long));
+  AP(&send_buffer->message.u.reply.reply_status,
+     sizeof(GIOP_unsigned_long));
+
+  return send_buffer;
+}
+
+GIOPSendBuffer *
+giop_send_locate_reply_buffer_use(GIOPConnection *connection,
+			   GIOP_unsigned_long request_id,
+			   GIOPLocateStatusType locate_reply_status)
+{
+  GIOPSendBuffer *send_buffer;
+
+  send_buffer = giop_send_buffer_use(connection);
+
+  if(!send_buffer)
+    return NULL;
+
+  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_type = GIOP_LOCATEREPLY;
+
+  APIA(&request_id, sizeof(request_id));
+  APIA(&locate_reply_status, sizeof(locate_reply_status));
+
+  return send_buffer;
+}
+
+GIOPSendBuffer *
+giop_send_request_buffer_use(GIOPConnection *connection,
+			     const IOP_ServiceContextList *service_context,
+			     GIOP_unsigned_long request_id,
+			     GIOP_boolean response_expected,
+			     const struct iovec *object_key_vec,
+			     const struct iovec *operation_vec,
+			     const struct iovec *principal_vec)
+{
+  GIOPSendBuffer *send_buffer;
+#if 0
+  static const struct {
+    CORBA_unsigned_long _length;
+    char _buffer[7];
+  } default_principal = { sizeof("nobody"), "nobody" };
+  static const struct iovec default_principal_vec =
+  {(void *)&default_principal,
+   sizeof(CORBA_unsigned_long) + sizeof("nobody")};
+#endif
+
+  if (!connection)
+    return NULL;
+  if(!object_key_vec)
+    return NULL;
+  if(!operation_vec)
+    return NULL;
+
+  ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug,
+	      "Sending request %s id %d to %s\n",
+	      ((guchar *)operation_vec->iov_base) + 4,
+	      request_id, ((guchar *)object_key_vec->iov_base) + 4);
+
+  send_buffer = giop_send_buffer_use(connection);
+
+  if (!send_buffer)
+    return NULL;
+
+  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_type = GIOP_REQUEST;
+
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(GIOP_unsigned_long));
+  if(!service_context) {
+    static const GIOP_unsigned_long sc_zero_int = 0;
+    AP(&sc_zero_int, sizeof(GIOP_unsigned_long));
+  } else {
+    int i, n;
+    n = service_context->_length;
+    AP(&service_context->_length, sizeof(service_context->_length));
+    for(i = 0; i < n; i++) {
+      int j, o;
+      CORBA_sequence_octet *seqo;
+
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				       sizeof(GIOP_unsigned_long));
+      AP(&service_context->_buffer[i].context_id,
+	 sizeof(service_context->_buffer[i].context_id));
+      seqo = &service_context->_buffer[i].context_data;
+      o = seqo->_length;
+      AP(&seqo->_length, sizeof(GIOP_unsigned_long));
+      for(j = 0; j < o; j++)
+	AP(seqo->_buffer, seqo->_length);
+    }
+  }
+  send_buffer->message.u.request.request_id = request_id;
+  send_buffer->message.u.request.response_expected = response_expected;
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(GIOP_unsigned_long));
+  AP(&send_buffer->message.u.request.request_id,
+     sizeof(GIOP_unsigned_long));
+  AP(&send_buffer->message.u.request.response_expected,
+     sizeof(GIOP_boolean));
+#if 0
+  API(&response_expected, 1);
+  AP((gpointer)giop_scratch_space, 3);
+#endif
+
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(CORBA_unsigned_long));
+  giop_message_buffer_append_iovec(GIOP_MESSAGE_BUFFER(send_buffer),
+				   object_key_vec);
+  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_size +=
+    object_key_vec->iov_len;
+
+  /*
+   * We can know the length at compile time - don't calculate it at runtime
+   * if we can help it :)
+   */
+  /* ENCODER_CALL(CORBA_string, (CORBA_string *)operation); */
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(CORBA_unsigned_long));
+  giop_message_buffer_append_iovec(GIOP_MESSAGE_BUFFER(send_buffer),
+				   operation_vec);
+  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_size +=
+    operation_vec->iov_len;
+
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   sizeof(CORBA_unsigned_long));
+  giop_message_buffer_append_iovec(GIOP_MESSAGE_BUFFER(send_buffer),
+				   principal_vec);
+  GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_size +=
+    principal_vec->iov_len;
+
+  return send_buffer;
+}
+
+GIOPSendBuffer *
+giop_send_locate_request_buffer_use(GIOPConnection *connection,
+			     GIOP_unsigned_long request_id,
+			     const struct iovec *object_key_vec)
+{
+	GIOPSendBuffer *send_buffer;
+
+	if (!connection)
+		return NULL;
+	if (!object_key_vec)
+		return NULL;
+
+	ORBit_Trace(TraceMod_IIOP, TraceLevel_Debug,
+		"Sending locate request id %d to %s\n",
+		request_id, ((guchar *)object_key_vec->iov_base) + 4);
+
+	send_buffer = giop_send_buffer_use(connection);
+
+	if (!send_buffer)
+		return NULL;
+
+	GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_type = GIOP_LOCATEREQUEST;
+
+	APIA(&request_id, sizeof(request_id));
+
+	giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+		sizeof(CORBA_unsigned_long));
+	giop_message_buffer_append_iovec(GIOP_MESSAGE_BUFFER(send_buffer),
+		object_key_vec);
+	GIOP_MESSAGE_BUFFER(send_buffer)->message_header.message_size +=
+		object_key_vec->iov_len;
+
+	return send_buffer;
+}
+
+void
+giop_send_buffer_unuse(GIOPSendBuffer *send_buffer)
+{
+  if (send_buffer == NULL)
+    return;
+
+  giop_connection_unref(GIOP_MESSAGE_BUFFER(send_buffer)->connection);
+
+  GET_LOCK(sendbufferlist);
+  sendbufferlist = g_slist_prepend(sendbufferlist, send_buffer);
+  RELEASE_LOCK(sendbufferlist);
+}
+
+gulong
+giop_message_buffer_do_alignment(GIOPMessageBuffer *buffer,
+				 gulong align_for)
+{
+  struct iovec newvec;
+  struct iovec *lastvec;
+  guint alignme;
+  gulong real_msgsize;
+  gulong align_diff;
+
+  if(align_for < 2) return 0;
+  if(align_for >
+     MAX(sizeof(GIOP_long_long),sizeof(GIOP_long_double)))
+    align_for = MAX(sizeof(GIOP_long_long), sizeof(GIOP_long_double));
+
+  real_msgsize = buffer->message_header.message_size+sizeof(GIOPMessageHeader);
+
+  alignme = (gulong)ALIGN_ADDRESS(real_msgsize, align_for);
+
+  align_diff = alignme - real_msgsize;
+  if(align_diff > 0)
+    {
+      lastvec = (struct iovec *)(buffer->iovecs->data) 
+				 + buffer->iovecs->len - 1;
+
+      if(lastvec->iov_base == giop_scratch_space)
+	{
+	  newvec.iov_len = align_diff;
+	  lastvec->iov_len += align_diff;
+	  buffer->message_header.message_size += align_diff;
+	}
+      else
+	{
+	  newvec.iov_base = (gpointer)giop_scratch_space;
+	  newvec.iov_len = align_diff;
+	  buffer->message_header.message_size += align_diff;
+	  giop_message_buffer_append_iovec(buffer, &newvec);
+	}
+      return newvec.iov_len;
+    }
+  else
+    return 0;
+}
+
+void 
+giop_message_buffer_append_mem_a(GIOPMessageBuffer *buffer,
+				 gconstpointer mem_region,
+				 gulong mem_region_length)
+{
+  struct iovec newvec;
+  struct iovec *lastvec;
+  gint alignfor;
+
+  alignfor = giop_message_buffer_do_alignment(buffer, mem_region_length);
+
+  lastvec = (struct iovec *)(buffer->iovecs->data) + 
+			     + buffer->iovecs->len - 1;
+
+  if((mem_region == giop_scratch_space && lastvec->iov_base == giop_scratch_space)
+     || (alignfor == 0 && (((guchar *)lastvec->iov_base) + lastvec->iov_len) == mem_region))
+    {
+      lastvec->iov_len += mem_region_length;
+    }
+  else
+    {
+      newvec.iov_base = (gpointer)mem_region;
+      newvec.iov_len = mem_region_length;
+      giop_message_buffer_append_iovec(buffer, &newvec);
+    }
+
+  buffer->message_header.message_size += mem_region_length;
+}
+
+void 
+giop_message_buffer_append_mem(GIOPMessageBuffer *buffer,
+			       gconstpointer mem_region,
+			       gulong mem_region_length)
+{
+  struct iovec newvec;
+  struct iovec *lastvec;
+
+  lastvec = (struct iovec *)(buffer->iovecs->data)
+			     + buffer->iovecs->len - 1;
+
+  if((mem_region == giop_scratch_space
+      && lastvec->iov_base == giop_scratch_space)
+     || ((((guchar *)lastvec->iov_base) + lastvec->iov_len) == mem_region))
+    {
+      lastvec->iov_len += mem_region_length;
+    }
+  else
+    {
+      newvec.iov_base = (gpointer)mem_region;
+      newvec.iov_len = mem_region_length;
+      giop_message_buffer_append_iovec(buffer, &newvec);
+    }
+
+  buffer->message_header.message_size += mem_region_length;
+}
+
+/* I think we need a WE_WANT_NEW_CRAPPY_BUGGY_CODE ifdef here - this
+   tiny routine seems to be horribly hard to get right.
+
+   Basically we have to paste the whole of 'mem_region' into our
+   memory chunks, possibly subdividing it up to fit it into multiple
+   1K chunks. Because we have to return the first paste point in case
+   the client wants to manipulate it afterwards, if mem_region_length
+   >= sizeof(CORBA_unsigned_long), we also have to guarantee that the
+   pasted stuff doesn't get divided on a finer boundary than
+   sizeof(CORBA_unsigned_long).
+*/
+gpointer
+giop_send_buffer_append_mem_indirect(GIOPSendBuffer *send_buffer,
+				     gconstpointer mem_region,
+				     gulong mem_region_length)
+{
+  gulong offset = 0, thisblock_size;
+  gpointer blockstart = NULL;
+
+  while(offset < mem_region_length) {
+    thisblock_size = MIN(mem_region_length - offset,
+			 GIOP_INDIRECT_CHUNK_SIZE - send_buffer->indirect_used);
+
+    if((thisblock_size >= sizeof(CORBA_unsigned_long))
+       || (mem_region_length - offset) < sizeof(CORBA_unsigned_long)) {
+      if (!blockstart)
+	blockstart =
+	  ((guchar*) send_buffer->indirect) + send_buffer->indirect_used;
+
+      memcpy((guchar*)send_buffer->indirect + send_buffer->indirect_used,
+	     (guchar*)mem_region + offset, thisblock_size);
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(send_buffer),
+				     (guchar*)send_buffer->indirect +
+				     send_buffer->indirect_used,
+				     thisblock_size);
+      offset += thisblock_size;
+      send_buffer->indirect_used += thisblock_size;
+    }
+
+    if(send_buffer->indirect_used >= (GIOP_INDIRECT_CHUNK_SIZE - sizeof(CORBA_unsigned_long))) {
+#ifdef I_CANT_FIGURE_OUT_WHAT_THIS_LOGIC_WAS_MEANT_TO_DO
+       || (thisblock_size >= sizeof(CORBA_unsigned_long)
+	   && (mem_region_length - offset) > 0)) {
+#endif
+	  send_buffer->indirect_used = 0;
+	  send_buffer->indirect = g_chunk_new(gpointer,
+					      send_buffer->indirects);
+    }
+  }
+
+  return blockstart;
+}
+
+#ifdef WE_WANT_OLD_DEAD_CRAPPY_BUGGY_CODE
+gpointer
+_giop_send_buffer_append_mem_indirect(GIOPSendBuffer *send_buffer,
+				     gconstpointer mem_region,
+				     gulong mem_region_length)
+{
+  gpointer blockstart = NULL;
+  gulong offset, new_offset;
+
+  for(offset = new_offset = 0; new_offset < mem_region_length;)
+    {
+      new_offset =
+	MIN(mem_region_length - offset,
+	    GIOP_INDIRECT_CHUNK_SIZE - send_buffer->indirect_used);
+
+      if((new_offset - offset) > sizeof(CORBA_unsigned_long)
+	 || mem_region_length >= sizeof(CORBA_unsigned_long)) {
+
+	if(!blockstart)
+	  blockstart = send_buffer->indirect + send_buffer->indirect_used;
+      }
+	
+      memcpy(send_buffer->indirect + send_buffer->indirect_used,
+	     mem_region + offset, new_offset - offset);
+	
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(send_buffer),
+				     send_buffer->indirect + send_buffer->indirect_used,
+				     new_offset - offset);
+
+      send_buffer->indirect_used += new_offset - offset;
+
+      offset = new_offset;
+
+      if(new_offset >= GIOP_INDIRECT_CHUNK_SIZE)
+	{
+	  send_buffer->indirect_used = 0;
+	  send_buffer->indirect = g_chunk_new(gpointer,
+					      send_buffer->indirects);
+#ifdef ORBIT_DEBUG
+	  memset(send_buffer->indirect, '\xFE', GIOP_INDIRECT_CHUNK_SIZE);
+#endif
+	}
+    }
+
+  return blockstart;
+}
+#endif
+
+gpointer
+giop_send_buffer_append_mem_indirect_a(GIOPSendBuffer *send_buffer,
+				       gconstpointer mem_region,
+				       gulong mem_region_length)
+{
+  giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(send_buffer),
+				   mem_region_length);
+  return giop_send_buffer_append_mem_indirect(send_buffer,
+					      mem_region, mem_region_length);
+}
+
+GIOP_unsigned_long
+giop_get_request_id(void)
+{
+  GIOP_unsigned_long retval;
+  GET_LOCK(request_id_counter);
+  retval = request_id_counter++;
+  RELEASE_LOCK(request_id_counter);
+  return retval;
+}
+
+/****************************************************
+ * GIOPRecvBuffer routines
+ ****************************************************/
+
+static GIOPRecvBuffer *
+giop_recv_buffer_new(void)
+{
+  GIOPRecvBuffer *msgbuf;
+
+  GET_LOCK(recvbuffers);
+  msgbuf = g_chunk_new(GIOPRecvBuffer, recvbuffers);
+  RELEASE_LOCK(recvbuffers);
+
+  giop_message_buffer_new(GIOP_MESSAGE_BUFFER(msgbuf));
+  msgbuf->message_body = NULL;
+
+  return msgbuf;
+}
+
+void
+giop_recv_buffer_unuse(GIOPRecvBuffer *buffer)
+{
+  if (buffer == NULL)
+    return;
+
+  if(buffer->message_body) {
+    buffer->message_body = ((guchar *)buffer->message_body)
+      - sizeof(GIOPMessageHeader);
+    
+    g_free(buffer->message_body);
+    buffer->message_body = NULL;
+  }
+
+  if(GIOP_MESSAGE_BUFFER(buffer)->connection->incoming_msg == buffer)
+    GIOP_MESSAGE_BUFFER(buffer)->connection->incoming_msg = NULL;
+
+  giop_connection_unref(GIOP_MESSAGE_BUFFER(buffer)->connection);
+
+  GET_LOCK(recvbufferlist);
+  recvbufferlist = g_slist_prepend(recvbufferlist, buffer);
+  RELEASE_LOCK(recvbufferlist);
+}
+
+static GIOPRecvBuffer *
+giop_recv_buffer_use(GIOPConnection *connection)
+{
+  GIOPRecvBuffer *retval;
+
+  if(!connection || !connection->is_valid)
+    return NULL;
+
+  GET_LOCK(recvbufferlist);
+
+  if(recvbufferlist)
+    {
+      GSList *head;
+
+      retval = recvbufferlist->data;
+
+      head = recvbufferlist;
+      recvbufferlist = g_slist_remove_link(recvbufferlist, recvbufferlist);
+      g_slist_free_1 (head);
+
+      GIOP_MESSAGE_BUFFER(retval)->message_header.message_size = 0;
+      retval->message_body = NULL;
+    }
+  else
+    retval = giop_recv_buffer_new();
+
+  retval->state = GIOP_MSG_READING_HEADER;
+  retval->left_to_read = sizeof(GIOPMessageHeader);
+
+  RELEASE_LOCK(recvbufferlist);
+  
+  giop_connection_ref(connection);
+  GIOP_MESSAGE_BUFFER(retval)->connection = connection;
+
+  return retval;
+}
+
+GIOPRecvBuffer *
+giop_recv_message_buffer_use(GIOPConnection *connection)
+{
+  GIOPRecvBuffer *retval;
+  char *bptr;
+  int sysret;
+  guint message_size;
+  
+//  printf("giop_recv_message_buffer_use: connection = 0x%X\n", connection);
+
+  if(!connection || !connection->is_valid)
+    return NULL;
+
+  if(connection->incoming_msg)
+    retval = connection->incoming_msg;
+  else {
+    retval = giop_recv_buffer_use(connection);
+    connection->incoming_msg = retval;
+  }
+
+  if(!retval) return NULL;
+
+  do {
+    switch(retval->state) {
+    case GIOP_MSG_READING_HEADER:
+      bptr = ((char *)&(GIOP_MESSAGE_BUFFER(retval)->message_header));
+      bptr += sizeof(GIOP_MESSAGE_BUFFER(retval)->message_header)
+	- retval->left_to_read;
+      break;
+    case GIOP_MSG_READING_BODY:
+      bptr = retval->cur; /* Reason for not using retval->message_body:
+			     See note XXX1 below */
+      bptr += GIOP_MESSAGE_BUFFER(retval)->message_header.message_size;
+      bptr -= retval->left_to_read;
+      break;
+    default:
+      bptr = NULL;
+    }
+
+//printf("#1p1: READ %d bytes: errno %d state = %d\n", retval->left_to_read, errno, retval->state);
+    sysret = read(GIOP_CONNECTION_GET_FD(connection), bptr,
+		  retval->left_to_read);
+
+    if((sysret == 0)
+       || ((sysret < 0) && (errno != EAGAIN))) {
+//printf("#1: sysret = %d bptr = 0x%X errno = %d\n", sysret, bptr, errno);
+      goto errout;
+    }
+
+    if(sysret > 0)
+      retval->left_to_read -= sysret;
+
+    if(retval->left_to_read == 0) {
+      /* we change states here */
+
+      switch(retval->state) {
+      case GIOP_MSG_READING_HEADER:
+	/* Check the magic stuff */
+	if(strncmp(GIOP_MESSAGE_BUFFER(retval)->message_header.magic, "GIOP", 4)
+	   || GIOP_MESSAGE_BUFFER(retval)->message_header.GIOP_version[0] != 1) {
+//printf("#2: Not a GIOP thinger? '%s'\n", GIOP_MESSAGE_BUFFER(retval)->message_header.magic);
+	  goto errout;
+        }
+	if(GIOP_MESSAGE_BUFFER(retval)->message_header.message_size == 0
+	   && GIOP_MESSAGE_BUFFER(retval)->message_header.message_type != GIOP_CLOSECONNECTION) {
+//	  printf("Unexpected 0-length IIOP message\n");
+	  goto errout;
+	}
+
+	if(giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(retval))) {
+	  CORBA_unsigned_long t = GIOP_MESSAGE_BUFFER(retval)->message_header.message_size;
+	  retval->decoder = (void (*)(gpointer, gpointer, gulong))iiop_byteswap;
+
+	  iiop_byteswap((gpointer)&GIOP_MESSAGE_BUFFER(retval)->message_header.message_size,
+			(gpointer)&t, sizeof(t));
+	} else {
+#ifdef __KERNEL__
+	  retval->decoder = (void (*)(gpointer,gpointer,gulong))__memcpy;
+#else
+	  retval->decoder = (void (*)(gpointer,gpointer,gulong))memcpy;
+#endif
+	}
+
+	message_size = GIOP_MESSAGE_BUFFER(retval)->message_header.message_size;
+	if(!connection->is_auth
+	   && message_size > 131072) {
+//	  printf("message size is bigger than 128k (%d)\n", message_size);
+	  goto errout;
+	}
+
+	retval->message_body = g_malloc(message_size+sizeof(GIOPMessageHeader));
+	/* XXX1 This is a lame hack to work with the fact that
+	   alignment is relative to the MessageHeader, not the RequestHeader */
+	retval->message_body = ((guchar *)retval->message_body) + sizeof(GIOPMessageHeader);
+	retval->cur = retval->message_body;
+	retval->state = GIOP_MSG_READING_BODY;
+	retval->left_to_read = message_size;
+	break;
+      case GIOP_MSG_READING_BODY:
+	if(giop_recv_decode_message(retval)) {
+//printf("giop_recv_decode_message FAILURE!\n");
+	  goto errout;
+	}
+	connection->incoming_msg = NULL;
+	retval->state = GIOP_MSG_READY;
+	break;
+      default:
+        break;
+      }
+    } else if(retval->left_to_read < 0) {
+//      printf("Whoa, we overstepped the number of bytes we were supposed to read by %d\n", -retval->left_to_read);
+      goto errout;
+    } else /* retval->left_to_read > 0 */ {
+      /* couldn't read the whole piece, save it */
+      retval = NULL;
+    }
+  } while(retval && retval->state != GIOP_MSG_READY);
+  
+  return retval;
+
+ errout:
+  giop_recv_buffer_unuse(retval);
+  giop_main_handle_connection_exception(connection);
+  return NULL;
+}
+
+void
+giop_received_list_push(GIOPRecvBuffer *recv_buffer)
+{
+  GET_LOCK(incoming_bufs);
+  incoming_bufs = g_list_prepend(incoming_bufs, recv_buffer);
+  RELEASE_LOCK(incoming_bufs);
+}
+
+GIOPRecvBuffer *giop_received_list_pop(void)
+{
+  GList *head;
+  GIOPRecvBuffer *retval;
+
+  GET_LOCK(incoming_bufs);
+
+  head = incoming_bufs;
+
+  if(!head)
+    return NULL;
+
+  retval = head->data;
+  incoming_bufs = g_list_remove_link(incoming_bufs, head);
+  g_list_free_1 (head);
+
+  RELEASE_LOCK(incoming_bufs);
+
+  return retval;
+}
+
+static GIOPRecvBuffer *
+giop_received_list_check_reply(GIOP_unsigned_long request_id)
+{
+  GIOPRecvBuffer *retval = NULL;
+  GList *item = NULL;
+
+  GET_LOCK(incoming_bufs);
+
+  for(item = incoming_bufs; item; item = g_list_next(item))
+    {
+      if(GIOP_MESSAGE_BUFFER(item->data)->message_header.message_type == GIOP_REPLY
+	 && GIOP_RECV_BUFFER(item->data)->message.u.reply.request_id == request_id) {
+	retval = item->data;
+	break;
+      }
+    }
+
+  if(retval)
+    incoming_bufs = g_list_remove(incoming_bufs, retval);
+
+  RELEASE_LOCK(incoming_bufs);
+
+  return retval;
+}
+
+/** giop_recv_reply_buffer_use_multiple
+ */
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use_multiple(GArray *request_ids,
+				    gboolean block_for_reply)
+{
+  return giop_recv_reply_buffer_use_multiple_2(NULL, request_ids, block_for_reply);
+}
+
+/* here is how it will be:
+   one routine for getting next message with a specified reply ID.
+ */
+
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use_multiple_2(GIOPConnection *request_cnx,
+				      GArray *request_ids,
+				      gboolean block_for_reply)
+{
+  int i;
+  GIOPRecvBuffer *retval = NULL;
+  GSList *pushme = NULL;
+
+  do {
+    /*
+     * We _do_ want to put this inside the loop,
+     * because we may call ourselves recursively for different request_id's
+     */
+    for(i = 0; i < request_ids->len && !retval; i++)
+      retval = giop_received_list_check_reply(g_array_index(request_ids, GIOP_unsigned_long, i));
+
+    if(retval)
+      break;
+
+    retval = giop_main_next_message_2(block_for_reply, request_cnx);
+
+    if(retval) {
+      if(GIOP_MESSAGE_BUFFER(retval)->message_header.message_type == GIOP_REPLY) {
+	 if(num_on_list(retval->message.u.reply.request_id,
+			(GIOP_unsigned_long *)request_ids->data,
+			request_ids->len))
+	   break;
+	 else {
+	   pushme = g_slist_prepend(pushme, retval); retval = NULL;
+	 }
+      } else {
+	if(IIOPIncomingMessageHandler)
+	  IIOPIncomingMessageHandler(retval);
+	else {
+	  pushme = g_slist_prepend(pushme, retval); retval = NULL;
+	}
+	retval = NULL;
+      }
+    } else
+      return NULL;
+
+  } while(!retval && block_for_reply);
+
+  g_slist_foreach(pushme, (GFunc)giop_received_list_push, NULL);
+  g_slist_free(pushme);
+
+  return retval;
+}
+
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use(GIOP_unsigned_long request_id,
+			   gboolean block_for_reply)
+{
+  return giop_recv_reply_buffer_use_2(NULL, request_id, block_for_reply);
+}
+
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use_2(GIOPConnection *request_cnx,
+			     GIOP_unsigned_long request_id,
+			     gboolean block_for_reply)
+{
+  GArray fakeme;
+
+  fakeme.len = 1;
+  fakeme.data = (gpointer)&request_id;
+
+  return giop_recv_reply_buffer_use_multiple_2(request_cnx,
+					       &fakeme,
+					       block_for_reply);
+}
+
+GIOPRecvBuffer *
+giop_recv_locate_reply_buffer_use(GIOP_unsigned_long request_id,
+				  gboolean block_for_reply)
+{
+  GIOPRecvBuffer *retval = NULL;
+
+  do {
+    /*
+     * We _do_ want to put this inside the loop,
+     * because we may call ourselves recursively for different request_id's
+     */
+    retval = giop_received_list_check_reply(request_id);
+
+    if(retval)
+      break;
+
+    retval = giop_main_next_message_2(TRUE, NULL);
+
+    if(retval) {
+      if(GIOP_MESSAGE_BUFFER(retval)->message_header.message_type == GIOP_LOCATEREPLY
+	 && retval->message.u.locate_reply.request_id == request_id)
+	break;
+      else {
+	if(IIOPIncomingMessageHandler)
+	  IIOPIncomingMessageHandler(retval);
+	else
+	  giop_received_list_push(retval);
+	retval = NULL;
+      }
+    } else
+      return NULL;
+  } while(!retval && block_for_reply);
+
+  return retval;
+}
+
+static gint
+giop_recv_decode_message(GIOPRecvBuffer *buf)
+{
+  switch(GIOP_MESSAGE_BUFFER(buf)->message_header.message_type)
+    {
+    case GIOP_REPLY:
+      return giop_recv_reply_decode_message(buf);
+      break;
+    case GIOP_REQUEST:
+      return giop_recv_request_decode_message(buf);
+      break;
+    case GIOP_LOCATEREQUEST:
+      return(giop_recv_locate_request_decode_message(buf));
+      break;
+    case GIOP_LOCATEREPLY:
+      return(giop_recv_locate_reply_decode_message(buf));
+      break;
+    case GIOP_CLOSECONNECTION:
+      return 0;
+      break;
+    default:
+//      printf("Don't know how to decode message type %d\n",
+//		GIOP_MESSAGE_BUFFER(buf)->message_header.message_type);
+      return -1;
+    }
+}
+
+/* if(currptr+len > end || currptr + len < currptr) */
+
+/* This whole mess needs redoing. */
+#define CHECK_NEW_POS(buf, requested_increment) \
+if(!( (( ((guchar*)GIOP_RECV_BUFFER(buf)->cur) \
+		        + (requested_increment) ) \
+		       <= ( ((guchar *)GIOP_RECV_BUFFER(buf)->message_body) \
+			   + GIOP_MESSAGE_BUFFER(buf)->message_header.message_size)) \
+		      && ( ( ((guchar*)GIOP_RECV_BUFFER(buf)->cur) \
+			    + (requested_increment) ) \
+			  >= ((guchar*)GIOP_RECV_BUFFER(buf)->cur) ))) goto out;
+
+#define NEW_POS_OUT out: return -1
+
+#define SAFE_ALIGN_ADDRESS(buf, amt) G_STMT_START { \
+guchar *newval; \
+newval = ALIGN_ADDRESS(GIOP_RECV_BUFFER(buf)->cur, amt); \
+CHECK_NEW_POS(buf, newval-((guchar *)GIOP_RECV_BUFFER(buf)->cur)); \
+GIOP_RECV_BUFFER(buf)->cur = newval; \
+} G_STMT_END
+
+#define GET_ULONG(x) G_STMT_START{					\
+                (x) = GUINT32_SWAP_LE_BE((*(CORBA_unsigned_long *)buf->cur)); \
+                CHECK_NEW_POS(buf, sizeof(CORBA_unsigned_long));        \
+		buf->cur = ((guchar *)buf->cur) + sizeof(CORBA_unsigned_long);	\
+	}G_STMT_END
+
+#define GET_ULONG_NC(x) G_STMT_START{ \
+			*(x) = (*((CORBA_unsigned_long *)(buf->cur))); \
+                        CHECK_NEW_POS(buf, sizeof(CORBA_unsigned_long)); \
+			buf->cur = ((guchar *)buf->cur) + sizeof(CORBA_unsigned_long); \
+		}G_STMT_END
+
+/* There be dragons in here. */
+static gint
+giop_recv_reply_decode_message(GIOPRecvBuffer *buf)
+{
+  /*
+	  enum ReplyStatusType {
+		NO_EXCEPTION,
+		USER_EXCEPTION,
+		SYSTEM_EXCEPTION,
+		LOCATION_FORWARD
+	};
+
+	struct ReplyHeader {
+		IOP::ServiceContextList service_context;
+		unsigned long request_id;
+		ReplyStatusType reply_status;
+	};
+  */
+  int i;
+
+  buf->message.u.reply.service_context._maximum = 0;
+  if(giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(buf))) 
+    {
+      GET_ULONG(buf->message.u.reply.service_context._length);
+/* XXX bad hardcoded hack until someone gives a "right answer" to how to
+solve this problem */
+      if(buf->message.u.reply.service_context._length > 128) return -1;
+      buf->message.u.reply.service_context._buffer =
+	g_new(IOP_ServiceContext, buf->message.u.reply.service_context._length);
+
+      for(i = 0; i < buf->message.u.reply.service_context._length; i++)
+	{
+	  SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+	  GET_ULONG(buf->message.u.reply.service_context._buffer[i].context_id);
+	  GET_ULONG(buf->message.u.reply.service_context._buffer[i].context_data._length);
+	  buf->message.u.reply.service_context._buffer[i].context_data._buffer =
+	    buf->cur;
+	  CHECK_NEW_POS(buf, buf->message.u.reply.service_context._buffer[i].context_data._length);
+	  buf->cur = ((guchar *)buf->cur) + buf->message.u.reply.service_context._buffer[i].context_data._length;
+	}
+      GET_ULONG(buf->message.u.reply.request_id);
+      GET_ULONG(buf->message.u.reply.reply_status);
+    }
+  else
+    {
+
+      GET_ULONG_NC(&buf->message.u.reply.service_context._length);
+/* XXX bad hardcoded hack until someone gives a "right answer" to how to
+solve this problem */
+      if(buf->message.u.reply.service_context._length > 128) return -1;
+      buf->message.u.reply.service_context._buffer =
+	g_new(IOP_ServiceContext, buf->message.u.reply.service_context._length);
+
+      for(i = 0; i < buf->message.u.reply.service_context._length; i++)
+	{
+	  SAFE_ALIGN_ADDRESS(buf, sizeof(CORBA_unsigned_long));
+	  GET_ULONG_NC(&buf->message.u.reply.service_context._buffer[i].context_id);
+	  GET_ULONG_NC(&buf->message.u.reply.service_context._buffer[i].context_data._length);
+	  buf->message.u.reply.service_context._buffer[i].context_data._buffer =
+	    buf->cur;
+	  CHECK_NEW_POS(buf, buf->message.u.reply.service_context._buffer[i].context_data._length);
+	  buf->cur = ((guchar *)buf->cur) + buf->message.u.reply.service_context._buffer[i].context_data._length;
+	}
+      GET_ULONG_NC(&buf->message.u.reply.request_id);
+      GET_ULONG_NC(&buf->message.u.reply.reply_status);
+    }
+
+#if 0
+  g_message("[%d] Received reply %d size %d to request %d",
+	    getpid(),
+	    buf->message.u.reply.reply_status,
+	    GIOP_MESSAGE_BUFFER(buf)->message_header.message_size,
+	    buf->message.u.reply.request_id);
+#endif
+
+  return 0;
+
+  NEW_POS_OUT;
+}
+
+static gint
+giop_recv_locate_reply_decode_message(GIOPRecvBuffer *buf)
+{
+  if(giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(buf))) 
+    {
+      GET_ULONG(buf->message.u.locate_reply.request_id);
+      GET_ULONG(buf->message.u.locate_reply.locate_status);
+    }
+  else
+    {
+      GET_ULONG_NC(&buf->message.u.locate_reply.request_id);
+      GET_ULONG_NC(&buf->message.u.locate_reply.locate_status);
+    }
+
+  return 0;
+  NEW_POS_OUT;
+}
+
+static gint
+giop_recv_request_decode_message(GIOPRecvBuffer *buf)
+{
+  GIOP_unsigned_long len;
+  int i;
+
+  buf->message.u.request.service_context._maximum = 0;
+  if(giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(buf))) 
+    {
+      GET_ULONG(buf->message.u.request.service_context._length);
+
+      /* XXX bad hardcoded hack until someone gives a "right answer"
+	 to how to solve this problem */
+
+      if(buf->message.u.request.service_context._length > 128) return -1;
+      buf->message.u.request.service_context._buffer =
+	g_new(IOP_ServiceContext, buf->message.u.request.service_context._length);
+
+      for(i = 0; i < buf->message.u.request.service_context._length; i++)
+	{
+	  SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+	  GET_ULONG(buf->message.u.request.service_context._buffer[i].context_id);
+	  GET_ULONG(buf->message.u.request.service_context._buffer[i].context_data._length);
+	  buf->message.u.request.service_context._buffer[i].context_data._buffer =
+	    buf->cur;
+	  CHECK_NEW_POS(buf, buf->message.u.request.service_context._buffer[i].context_data._length);
+	  buf->cur = ((guchar *)buf->cur) + buf->message.u.request.service_context._buffer[i].context_data._length;
+	}
+
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG(buf->message.u.request.request_id);
+      buf->message.u.request.response_expected = *((GIOP_boolean *)buf->cur);
+      CHECK_NEW_POS(buf, sizeof(GIOP_boolean));
+      buf->cur = ((guchar *)buf->cur) + sizeof(GIOP_boolean);
+
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG(buf->message.u.request.object_key._length);
+      buf->message.u.request.object_key._buffer = buf->cur;
+
+      CHECK_NEW_POS(buf, buf->message.u.request.object_key._length);
+      buf->cur = ((guchar *)buf->cur) + buf->message.u.request.object_key._length;
+
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG(len);
+      buf->message.u.request.operation = buf->cur;
+
+      CHECK_NEW_POS(buf, len);
+      buf->cur = ((guchar *)buf->cur) + len;
+
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG(buf->message.u.request.requesting_principal._length);
+      buf->message.u.request.requesting_principal._buffer = buf->cur;
+
+      CHECK_NEW_POS(buf, buf->message.u.request.requesting_principal._length);
+      buf->cur = ((guchar *)buf->cur) + buf->message.u.request.requesting_principal._length;
+    }
+  else
+    {
+      GET_ULONG_NC(&buf->message.u.request.service_context._length);
+
+      /* XXX bad hardcoded hack until someone gives a "right answer"
+	 to how to solve this problem */
+      if(buf->message.u.request.service_context._length > 128) return -1;
+      buf->message.u.request.service_context._buffer =
+	g_new(IOP_ServiceContext, buf->message.u.request.service_context._length);
+
+      for(i = 0; i < buf->message.u.request.service_context._length; i++)
+	{
+	  SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+	  GET_ULONG_NC(&buf->message.u.request.service_context._buffer[i].context_id);
+	  GET_ULONG_NC(&buf->message.u.request.service_context._buffer[i].context_data._length);
+	  buf->message.u.request.service_context._buffer[i].context_data._buffer =
+	    buf->cur;
+	  CHECK_NEW_POS(buf, buf->message.u.request.service_context._buffer[i].context_data._length);
+	  buf->cur = ((guchar *)buf->cur) + buf->message.u.request.service_context._buffer[i].context_data._length;
+	}
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG_NC(&buf->message.u.request.request_id);
+      buf->message.u.request.response_expected = *((GIOP_boolean *)buf->cur);
+      CHECK_NEW_POS(buf, sizeof(GIOP_boolean));
+      buf->cur = ((guchar *)buf->cur) + sizeof(GIOP_boolean);
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG_NC(&buf->message.u.request.object_key._length);
+      buf->message.u.request.object_key._buffer = buf->cur;
+      CHECK_NEW_POS(buf, buf->message.u.request.object_key._length);
+      buf->cur = ((guchar *)buf->cur) + buf->message.u.request.object_key._length;
+
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG_NC(&len);
+      buf->message.u.request.operation = buf->cur;
+      CHECK_NEW_POS(buf, len);
+      buf->cur = ((guchar *)buf->cur) + len;
+
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG_NC(&buf->message.u.request.requesting_principal._length);
+      buf->message.u.request.requesting_principal._buffer = buf->cur;
+      CHECK_NEW_POS(buf, buf->message.u.request.requesting_principal._length);
+      buf->cur = ((guchar *)buf->cur) + buf->message.u.request.requesting_principal._length;
+    }
+
+#if 0
+  g_message("[%d] Received request %s size %d ID %d",
+	    getpid(),
+	    buf->message.u.request.operation,
+	    GIOP_MESSAGE_BUFFER(buf)->message_header.message_size,
+	    buf->message.u.request.request_id);
+#endif
+
+  return 0;
+
+  NEW_POS_OUT;
+}
+
+static gint
+giop_recv_locate_request_decode_message(GIOPRecvBuffer *buf)
+{
+  if(giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(buf))) 
+    {
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG(buf->message.u.locate_request.request_id);
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG(buf->message.u.locate_request.object_key._length);
+      buf->message.u.locate_request.object_key._buffer = buf->cur;
+      CHECK_NEW_POS(buf, buf->message.u.locate_request.object_key._length);
+      buf->cur = ((guchar *)buf->cur) + buf->message.u.locate_request.object_key._length;
+    }
+  else
+    {
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG_NC(&buf->message.u.locate_request.request_id);
+      SAFE_ALIGN_ADDRESS(buf, sizeof(GIOP_unsigned_long));
+      GET_ULONG_NC(&buf->message.u.locate_request.object_key._length);
+      buf->message.u.locate_request.object_key._buffer = buf->cur;
+      CHECK_NEW_POS(buf, buf->message.u.locate_request.object_key._length);
+      buf->cur = ((guchar *)buf->cur) + buf->message.u.locate_request.object_key._length;
+    }
+
+  return 0;
+
+  NEW_POS_OUT;
+}
+
+gboolean
+num_on_list(GIOP_unsigned_long num,
+	    const GIOP_unsigned_long *request_ids,
+	    GIOP_unsigned_long req_count)
+{
+  int i;
+  for(i = 0; i < req_count; i++)
+    {
+      if(num == request_ids[i])
+	return TRUE;
+    }
+
+  return FALSE;
+}
diff -urN linux-2.4.1/net/korbit/IIOP/giop-msg-buffer.h linux-2.4.1-korbit/net/korbit/IIOP/giop-msg-buffer.h
--- linux-2.4.1/net/korbit/IIOP/giop-msg-buffer.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/giop-msg-buffer.h	Thu Feb  1 16:19:47 2001
@@ -0,0 +1,228 @@
+#ifndef GIOP_MSG_BUFFER_H
+#define GIOP_MSG_BUFFER_H 1
+
+#include "IIOP.h"
+/* For struct iovec */
+#include <sys/uio.h>
+
+typedef enum {
+  GIOP_REQUEST,
+  GIOP_REPLY,
+  GIOP_CANCELREQUEST,
+  GIOP_LOCATEREQUEST,
+  GIOP_LOCATEREPLY,
+  GIOP_CLOSECONNECTION,
+  GIOP_MESSAGEERROR,
+  GIOP_FRAGMENT
+} GIOPMsgType;
+
+/* GIOP message header */
+typedef struct _GIOPMessageHeader {
+  GIOP_char magic[4];
+  GIOP_char GIOP_version[2];
+  GIOP_octet flags;
+
+  /*
+   * We should really use GIOPMsgType
+   * but that enum winds up being an int...
+   */
+  GIOP_octet message_type;
+
+  GIOP_unsigned_long message_size;
+} GIOPMessageHeader;
+
+#define GIOP_MESSAGE_BUFFER(x) ((GIOPMessageBuffer *)x)
+typedef struct _GIOPMessageBuffer
+{
+  /* The connection that this message will go out over... */
+  GIOPConnection *connection; 
+				 
+  GArray *iovecs;
+  GIOPMessageHeader message_header;
+} GIOPMessageBuffer;
+
+#include "../orb/iop.h"
+
+/* GIOP_REQUEST header */
+typedef enum {
+  GIOP_NO_EXCEPTION,
+  GIOP_USER_EXCEPTION,
+  GIOP_SYSTEM_EXCEPTION,
+  GIOP_LOCATION_FORWARD
+} GIOPReplyStatusType;
+
+typedef struct _GIOPMessageRequest {
+  IOP_ServiceContextList service_context;
+  GIOP_unsigned_long request_id;
+  GIOP_boolean response_expected;
+  CORBA_sequence_octet object_key;
+  CORBA_char *operation;
+  CORBA_Principal requesting_principal;
+} GIOPMessageRequest;
+
+typedef struct _GIOPMessageReply {
+  IOP_ServiceContextList service_context;
+  GIOP_unsigned_long request_id;
+  GIOPReplyStatusType reply_status;
+} GIOPMessageReply;
+
+typedef struct _GIOPMessageCancelRequest {
+  GIOP_unsigned_long request_id;
+} GIOPMessageCancelRequest;
+
+typedef struct _GIOPMessageLocateRequest {
+  GIOP_unsigned_long request_id;
+  CORBA_sequence_octet object_key;
+} GIOPMessageLocateRequest;
+
+typedef enum {
+  GIOP_UNKNOWN_OBJECT,
+  GIOP_OBJECT_HERE,
+  GIOP_OBJECT_FORWARD
+} GIOPLocateStatusType;
+
+typedef struct _GIOPMessageLocateReply {
+  GIOP_unsigned_long request_id;
+  GIOPLocateStatusType locate_status;
+} GIOPMessageLocateReply;
+
+typedef struct _GIOPMessage
+{
+  union {
+    GIOPMessageRequest request;
+    GIOPMessageReply reply;
+    GIOPMessageCancelRequest cancel_request;
+    GIOPMessageLocateRequest locate_request;
+    GIOPMessageLocateReply locate_reply;
+  } u;
+} GIOPMessage;
+
+typedef enum {
+  GIOP_MSG_READING_HEADER,
+  GIOP_MSG_READING_BODY,
+  GIOP_MSG_READY
+} GIOPMessageBufferState;
+
+#define GIOP_SEND_BUFFER(x) ((GIOPSendBuffer *)x)
+typedef struct _GIOPSendBuffer
+{
+  GIOPMessageBuffer message_buffer;
+
+  gpointer indirect;
+
+  GMemChunk *indirects; /* Request buffers only (at present) */
+  gulong indirect_used;
+
+  GIOPMessage message;
+  CORBA_unsigned_long scontext_tmp;
+} GIOPSendBuffer;
+
+#define GIOP_RECV_BUFFER(x) ((GIOPRecvBuffer *)x)
+typedef struct _GIOPRecvBuffer
+{
+  GIOPMessageBuffer message_buffer;
+  GIOPMessage message;
+
+  gpointer message_body;
+  gpointer cur;
+
+  void (*decoder)(gpointer dest, gpointer src, gulong len);
+
+  GIOPMessageBufferState state;
+  gint left_to_read;
+} GIOPRecvBuffer;
+
+/* This function needs to be called before useful things happen */
+void giop_message_buffer_init(void);
+
+gint giop_send_buffer_write(GIOPSendBuffer *request_buffer);
+
+void 
+giop_message_buffer_append_mem_a(GIOPMessageBuffer *request_buffer,
+				 gconstpointer mem_region,
+				 gulong mem_region_length);
+void 
+giop_message_buffer_append_mem(GIOPMessageBuffer *request_buffer,
+			       gconstpointer mem_region,
+			       gulong mem_region_length);
+
+/*
+ * This copies the value into a request-specific buffer before
+ * adding it to the list
+ */
+gpointer
+giop_send_buffer_append_mem_indirect_a(GIOPSendBuffer *request_buffer,
+				       gconstpointer mem_region,
+				       gulong mem_region_length);
+gpointer
+giop_send_buffer_append_mem_indirect(GIOPSendBuffer *request_buffer,
+				     gconstpointer mem_region,
+				     gulong mem_region_length);
+
+GIOPSendBuffer *
+giop_send_request_buffer_use(GIOPConnection *connection,
+			     const IOP_ServiceContextList *service_context,
+			     GIOP_unsigned_long request_id,
+			     GIOP_boolean response_expected,
+			     const struct iovec *object_key_vec,
+			     const struct iovec *operation_vec,
+			     const struct iovec *principal_vec);
+GIOPSendBuffer *
+giop_send_reply_buffer_use(GIOPConnection *connection,
+			   const IOP_ServiceContextList *service_context,
+			   GIOP_unsigned_long request_id,
+			   GIOPReplyStatusType reply_status);
+GIOPSendBuffer *
+giop_send_locate_request_buffer_use(GIOPConnection *connection,
+			     GIOP_unsigned_long request_id,
+			     const struct iovec *object_key_vec);
+GIOPSendBuffer *
+giop_send_locate_reply_buffer_use(GIOPConnection *connection,
+			   GIOP_unsigned_long request_id,
+			   GIOPLocateStatusType reply_status);
+
+void giop_send_buffer_unuse(GIOPSendBuffer *send_buffer);
+
+GIOP_unsigned_long giop_get_request_id(void);
+
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use(GIOP_unsigned_long request_id,
+			   gboolean block_for_reply);
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use_2(GIOPConnection *request_cnx,
+			     GIOP_unsigned_long request_id,
+			     gboolean block_for_reply);
+
+/* For DII - hands back the first received request matching an id on the list */
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use_multiple(GArray *request_ids,
+				    gboolean block_for_reply);
+GIOPRecvBuffer *
+giop_recv_reply_buffer_use_multiple_2(GIOPConnection *request_cnx,
+				      GArray *request_ids,
+				      gboolean block_for_reply);
+
+GIOPRecvBuffer *
+giop_recv_locate_reply_buffer_use(GIOP_unsigned_long request_id,
+				  gboolean block_for_reply);
+
+/*
+ * For server-side use. It's the responsibility of the caller to do
+ * any select()ion desired
+ */
+GIOPRecvBuffer *
+giop_recv_message_buffer_use(GIOPConnection *connection);
+
+void giop_recv_buffer_unuse(GIOPRecvBuffer *buffer);
+
+/*
+ * This is used for sending (and recving, if we ever
+ *  get zero-copy receives implemented) alignment bytes
+ */ 
+extern char giop_scratch_space[2048];
+gulong giop_message_buffer_do_alignment(GIOPMessageBuffer *buffer,
+					gulong align_for);
+
+#define giop_msg_conversion_needed(msgbuf) (conversion_needed(GIOP_MESSAGE_BUFFER(msgbuf)->message_header.flags & 1))
+
+#endif /* GIOP_MSG_BUFFER_H */
diff -urN linux-2.4.1/net/korbit/IIOP/iiop-encoders.h linux-2.4.1-korbit/net/korbit/IIOP/iiop-encoders.h
--- linux-2.4.1/net/korbit/IIOP/iiop-encoders.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/iiop-encoders.h	Thu Feb  1 11:46:51 2001
@@ -0,0 +1,25 @@
+#ifndef ENCODERS_H
+#define ENCODERS_H 1
+
+#define ENCODER_DEC(typename) \
+void giop_encoder_##typename##(GIOPSendBuffer *send_buffer, \
+			       const typename *mem)
+
+#define ENCODER_CALL(typename, mem) \
+giop_encoder_##typename##(send_buffer, mem)
+
+#define AP(m, l) giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(send_buffer), m, l)
+#define APA(m, l) giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(send_buffer), m, l)
+
+#define API(m, l) giop_send_buffer_append_mem_indirect(send_buffer, m, l)
+#define APIA(m, l) giop_send_buffer_append_mem_indirect_a(send_buffer, m, l)
+
+ENCODER_DEC(IOP_ServiceContext);
+ENCODER_DEC(IOP_ServiceContextList);
+ENCODER_DEC(CORBA_sequence_octet);
+ENCODER_DEC(CORBA_Principal);
+#define giop_encoder_CORBA_Principal(rb, mem) \
+	giop_encoder_CORBA_sequence_octet(rb, mem)
+ENCODER_DEC(CORBA_char);
+
+#endif /* ENCODERS_H */
diff -urN linux-2.4.1/net/korbit/IIOP/iiop-endian.c linux-2.4.1-korbit/net/korbit/IIOP/iiop-endian.c
--- linux-2.4.1/net/korbit/IIOP/iiop-endian.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/iiop-endian.c	Thu Feb  1 11:46:51 2001
@@ -0,0 +1,12 @@
+#define IIOP_DO_NOT_INLINE_IIOP_BYTESWAP
+#include "iiop-endian.h"
+
+void iiop_byteswap(guchar *outdata,
+		   const guchar *data,
+		   gulong datalen)
+{
+  const guchar *source_ptr = data;
+  guchar *dest_ptr = (guchar *)outdata + datalen - 1;
+  while(dest_ptr >= outdata)
+    *dest_ptr-- = *source_ptr++;
+}
diff -urN linux-2.4.1/net/korbit/IIOP/iiop-endian.h linux-2.4.1-korbit/net/korbit/IIOP/iiop-endian.h
--- linux-2.4.1/net/korbit/IIOP/iiop-endian.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/iiop-endian.h	Thu Feb  1 11:46:51 2001
@@ -0,0 +1,42 @@
+#ifndef IIOP_ENDIAN_H
+#define IIOP_ENDIAN_H 1
+
+#include <glib.h>
+
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+
+# define FLAG_ENDIANNESS FLAG_BIG_ENDIAN
+# define conversion_needed(to_endianness) ((to_endianness)!=FLAG_BIG_ENDIAN)
+
+#elif G_BYTE_ORDER == G_LITTLE_ENDIAN
+
+# define FLAG_ENDIANNESS FLAG_LITTLE_ENDIAN
+# define conversion_needed(to_endianness) ((to_endianness)!=FLAG_LITTLE_ENDIAN)
+
+#else
+
+#error "Unsupported endianness on this system."
+
+#endif
+
+#define FLAG_BIG_ENDIAN 0
+#define FLAG_LITTLE_ENDIAN 1
+
+/* This is also defined in IIOP-types.c */
+void iiop_byteswap(guchar *outdata,
+		   const guchar *data,
+		   gulong datalen);
+
+#if defined(G_CAN_INLINE) && !defined(IIOP_DO_NOT_INLINE_IIOP_BYTESWAP)
+G_INLINE_FUNC void iiop_byteswap(guchar *outdata,
+				 const guchar *data,
+				 gulong datalen)
+{
+  const guchar *source_ptr = data;
+  guchar *dest_ptr = outdata + datalen - 1;
+  while(dest_ptr >= outdata)
+    *dest_ptr-- = *source_ptr++;
+}
+#endif
+
+#endif
diff -urN linux-2.4.1/net/korbit/IIOP/iiop-endianP.h linux-2.4.1-korbit/net/korbit/IIOP/iiop-endianP.h
--- linux-2.4.1/net/korbit/IIOP/iiop-endianP.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/IIOP/iiop-endianP.h	Thu Feb  1 16:19:47 2001
@@ -0,0 +1,11 @@
+#ifndef IIOP_ENDIANP_H
+#define IIOP_ENDIANP_H 1
+
+/* This is pretty much "here" */
+
+#include "config.h"
+#include "IIOP.h"
+
+#include "iiop-endian.h"
+
+#endif /* !IIOP_ENDIANP_H */
diff -urN linux-2.4.1/net/korbit/Makefile linux-2.4.1-korbit/net/korbit/Makefile
--- linux-2.4.1/net/korbit/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/Makefile	Thu Feb  1 15:57:33 2001
@@ -0,0 +1,22 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := korbit.o
+
+subdir-y := kglib orb IIOP ORBitutil modules
+subdir-m := modules
+
+obj-y := kglib/kglib.o orb/orblib.o IIOP/IIOPlib.o ORBitutil/ORBitutillib.o exported_symbols.o
+
+export-objs := exported_symbols.o
+
+EXTRA_CFLAGS = -D__KORBIT__ -DHAVE_CONFIG_H -I. -I./include -I./kglib -I./ORBitutil -nostdinc
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/ORBitutil/CVS/Entries linux-2.4.1-korbit/net/korbit/ORBitutil/CVS/Entries
--- linux-2.4.1/net/korbit/ORBitutil/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/CVS/Entries	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,13 @@
+/Makefile/1.4/Thu Feb  1 09:46:52 2001//
+/basic_types.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/compat.c/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/compat.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/orbit-os-config.h/1.2/Thu Feb  1 09:46:52 2001//
+/os-feature-alloca.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/os-specifics.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/thread-safety.c/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/thread-safety.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/trace.c/1.2/Thu Feb  1 09:46:52 2001//
+/trace.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+/util.h/1.1.1.1/Thu Feb  1 09:46:52 2001//
+D
diff -urN linux-2.4.1/net/korbit/ORBitutil/CVS/Repository linux-2.4.1-korbit/net/korbit/ORBitutil/CVS/Repository
--- linux-2.4.1/net/korbit/ORBitutil/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/CVS/Repository	Thu Feb  1 11:46:51 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/ORBitutil
diff -urN linux-2.4.1/net/korbit/ORBitutil/CVS/Root linux-2.4.1-korbit/net/korbit/ORBitutil/CVS/Root
--- linux-2.4.1/net/korbit/ORBitutil/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/CVS/Root	Thu Feb  1 11:46:51 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/ORBitutil/Makefile linux-2.4.1-korbit/net/korbit/ORBitutil/Makefile
--- linux-2.4.1/net/korbit/ORBitutil/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/Makefile	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,17 @@
+#
+# Makefile for KORBit/ORBitutil
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .o file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := ORBitutillib.o
+
+#obj-m := $(O_TARGET)
+obj-y := compat.o thread-safety.o trace.o
+
+EXTRA_CFLAGS = -D__KORBIT__ -DHAVE_CONFIG_H -I. -I.. -I../include -I../kglib -I../ORBitutil -nostdinc
+
+include $(TOPDIR)/Rules.make
diff -urN linux-2.4.1/net/korbit/ORBitutil/basic_types.h linux-2.4.1-korbit/net/korbit/ORBitutil/basic_types.h
--- linux-2.4.1/net/korbit/ORBitutil/basic_types.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/basic_types.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,46 @@
+#ifndef BASIC_TYPES_H
+#define BASIC_TYPES_H 1
+
+#include <glib.h>
+
+typedef gint16 CORBA_short;
+typedef gint32 CORBA_long;
+typedef guint16 CORBA_unsigned_short;
+typedef guint32 CORBA_unsigned_long;
+typedef gfloat CORBA_float;
+typedef gdouble CORBA_double;
+typedef char CORBA_char;
+typedef guchar CORBA_boolean;
+typedef guchar CORBA_octet;
+typedef gdouble CORBA_long_double;
+typedef guint16 CORBA_wchar; /* I'm not sure what size a wchar is supposed to be */
+
+/* Just a peeve */
+typedef CORBA_char GIOP_char;
+typedef CORBA_wchar GIOP_wchar;
+typedef CORBA_short GIOP_short;
+typedef CORBA_long GIOP_long;
+typedef CORBA_unsigned_short GIOP_unsigned_short;
+typedef CORBA_unsigned_long GIOP_unsigned_long;
+typedef CORBA_octet GIOP_octet;
+typedef CORBA_long GIOP_enum;
+typedef CORBA_boolean GIOP_boolean;
+typedef CORBA_float GIOP_float;
+typedef CORBA_double GIOP_double;
+typedef CORBA_long_double GIOP_long_double;
+
+#ifdef G_HAVE_GINT64
+#define HAVE_CORBA_LONG_LONG
+/* According to the spec, these two are optional. We support them if we can. */
+typedef gint64 CORBA_long_long;
+typedef guint64 CORBA_unsigned_long_long;
+typedef CORBA_long_long GIOP_long_long;
+typedef CORBA_unsigned_long_long GIOP_unsigned_long_long;
+#else
+#warning ""
+#warning "You don't G_HAVE_GINT64 defined in glib."
+#warning "Please make sure you don't have an old glibconfig.h lying around."
+#warning ""
+#endif
+
+#endif
diff -urN linux-2.4.1/net/korbit/ORBitutil/compat.c linux-2.4.1-korbit/net/korbit/ORBitutil/compat.c
--- linux-2.4.1/net/korbit/ORBitutil/compat.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/compat.c	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,43 @@
+#include "config.h"
+#include "util.h"
+
+#define MAX_IOVS 16
+
+int g_writev(int fd, const struct  iovec *  vector,  size_t count)
+{
+  int retval = 0;
+
+  while(count > MAX_IOVS) {
+    retval += writev(fd, vector, MAX_IOVS);
+    vector += MAX_IOVS; count -= MAX_IOVS;
+  }
+
+  return writev(fd, vector, count) + retval;
+}
+
+#ifndef HAVE_INET_ATON
+#include <netinet/in.h>
+#include <string.h>
+int inet_aton(const char *cp, struct in_addr *inp)
+{
+	union {
+		unsigned int n;
+		char parts[4];
+	} u;
+	int a=0,b=0,c=0,d=0, i;
+
+	i = sscanf(cp, "%d.%d.%d.%d%*s", &a, &b, &c, &d);
+
+	if(i != 4)
+		return 0;
+
+	u.parts[0] = a;
+	u.parts[1] = b;
+	u.parts[2] = c;
+	u.parts[3] = d;
+
+	inp->s_addr = u.n;
+
+	return 1;
+}
+#endif
diff -urN linux-2.4.1/net/korbit/ORBitutil/compat.h linux-2.4.1-korbit/net/korbit/ORBitutil/compat.h
--- linux-2.4.1/net/korbit/ORBitutil/compat.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/compat.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,8 @@
+#ifndef ORBITUTIL_COMPAT_H
+#define ORBITUTIL_COMPAT_H 1
+#include <sys/types.h>
+#include <sys/uio.h>
+
+int g_writev(int fd, const struct  iovec *  vector,  size_t count);
+
+#endif /*#define ORBITUTIL_COMPAT_H 1 */
diff -urN linux-2.4.1/net/korbit/ORBitutil/orbit-os-config.h linux-2.4.1-korbit/net/korbit/ORBitutil/orbit-os-config.h
--- linux-2.4.1/net/korbit/ORBitutil/orbit-os-config.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/orbit-os-config.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,8 @@
+#ifndef OS_CONFIG_H
+#define OS_CONFIG_H 1
+
+#ifndef __KORBIT__
+#define ORBIT_HAVE_ALLOCA_H 1
+#endif
+
+#endif
diff -urN linux-2.4.1/net/korbit/ORBitutil/os-feature-alloca.h linux-2.4.1-korbit/net/korbit/ORBitutil/os-feature-alloca.h
--- linux-2.4.1/net/korbit/ORBitutil/os-feature-alloca.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/os-feature-alloca.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,26 @@
+#ifndef OS_FEATURE_ALLOCA_H
+#define OS_FEATURE_ALLOCA_H 1
+
+#  if ORBIT_HAVE_ALLOCA_H
+#  include <alloca.h>
+#  endif
+
+#  include <string.h>
+
+#  if defined(__GNUC__)
+
+#    if defined(__STRICT_ANSI__)
+#      define alloca __builtin_alloca
+#    endif
+
+#  elif !(ORBIT_HAVE_ALLOCA_H)
+
+#    if defined(_AIX)
+ #pragma alloca
+#    elif !defined(alloca) /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+
+#  endif /* __GNUC__ etc. */
+
+#endif /* OS_FEATURE_ALLOCA_H */
diff -urN linux-2.4.1/net/korbit/ORBitutil/os-specifics.h linux-2.4.1-korbit/net/korbit/ORBitutil/os-specifics.h
--- linux-2.4.1/net/korbit/ORBitutil/os-specifics.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/os-specifics.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,12 @@
+#ifndef ORBITUTIL_OS_SPECIFICS_H
+#define ORBITUTIL_OS_SPECIFICS_H 1
+
+#include <ORBitutil/orbit-os-config.h>
+
+#include <ORBitutil/os-feature-alloca.h>
+
+/* This file should be a bunch of #ifdef's to #include the
+   os-<osname>.h for the current OS.  It is intended to abstract the
+   gunkiness necessary to get some OS's to build ORBit properly. */
+
+#endif
diff -urN linux-2.4.1/net/korbit/ORBitutil/thread-safety.c linux-2.4.1-korbit/net/korbit/ORBitutil/thread-safety.c
--- linux-2.4.1/net/korbit/ORBitutil/thread-safety.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/thread-safety.c	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,19 @@
+#include "util.h"
+
+#ifdef NOT_REENTRANT
+#include <pthread.h>
+
+pthread_key_t thread_data;
+
+void init_thread_data(void) __attribute__ ((constructor));
+
+void init_thread_data(void)
+{
+  pthread_key_create(&thread_data, NULL);
+}
+
+#else
+
+gpointer prog_data = NULL;
+
+#endif
diff -urN linux-2.4.1/net/korbit/ORBitutil/thread-safety.h linux-2.4.1-korbit/net/korbit/ORBitutil/thread-safety.h
--- linux-2.4.1/net/korbit/ORBitutil/thread-safety.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/thread-safety.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,36 @@
+#ifndef THREAD_SAFETY_H
+#define THREAD_SAFETY_H 1
+
+#ifdef NOT_REENTRANT
+
+#include <pthread.h>
+
+#define DEFINE_LOCK(x) pthread_mutex_t x##_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
+#define INIT_LOCK(x) /* We use static initialization, see above */
+#define GET_LOCK(x) pthread_mutex_lock(&x##_lock)
+#define RELEASE_LOCK(x) pthread_mutex_unlock(&x##_lock)
+#define PARAM_LOCK(x) pthread_mutex_t x##_lock
+#define LOCK_NAME(x) x##_lock
+#define EXTERN_LOCK(x) extern pthread_mutex_t x##_lock
+extern pthread_key_t thread_data;
+#define GET_THREAD_DATA() pthread_getspecific(thread_data)
+#define SET_THREAD_DATA(x) pthread_setspecific(thread_data, (x))
+
+#else
+
+/* stupid work around ANSI & empty semicolons. */
+#define DEFINE_LOCK(x)
+#define INIT_LOCK(x)
+#define GET_LOCK(x)
+#define RELEASE_LOCK(x)
+#define PARAM_LOCK(x) gpointer x##_lock
+#define LOCK_NAME(x) NULL
+#define EXTERN_LOCK(x)
+
+extern gpointer prog_data;
+#define GET_THREAD_DATA() prog_data
+#define SET_THREAD_DATA(x) (prog_data = (x))
+
+#endif
+
+#endif /* THREAD_SAFETY_H */
diff -urN linux-2.4.1/net/korbit/ORBitutil/trace.c linux-2.4.1-korbit/net/korbit/ORBitutil/trace.c
--- linux-2.4.1/net/korbit/ORBitutil/trace.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/trace.c	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,94 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@acm.org>
+ *
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "trace.h"
+
+/*
+ * The function to call to handle trace messages, or NULL to use the default
+ * of printing to stderr.
+ */
+#ifdef ORBIT_DEBUG
+static int (* TraceCallback)(char *, va_list)=NULL;
+static int TraceModules=0;
+static ORBit_TraceLevel TraceMaxLevel=0;
+
+const char *ORBit_Trace_levellist[] = {
+	"ALERT   ",
+	"CRITICAL",
+	"ERROR   ",
+	"WARNING ",
+	"NOTICE  ",
+	"INFO    ",
+	"DEBUG   "
+};
+
+void ORBit_Trace_setCallback(int (*cbf)(char *, va_list))
+{
+	TraceCallback=cbf;
+}
+
+int (*ORBit_Trace_getCallback(void))(char *, va_list)
+{
+	return(TraceCallback);
+}
+
+void ORBit_Trace_setModules(int modules)
+{
+	TraceModules=modules;
+}
+
+void ORBit_Trace_setLevel(ORBit_TraceLevel level)
+{
+	TraceMaxLevel=level;
+}
+
+int ORBit_Trace(ORBit_TraceModule module, ORBit_TraceLevel level, char *fmt, ...)
+{
+	va_list args;
+
+	if(!BitTest(TraceModules, module))
+		return 0;
+	if(TraceMaxLevel < level)
+		return 0;
+
+	va_start(args, fmt);
+	if(TraceCallback!=NULL)
+		return((*TraceCallback)(fmt, args));
+
+#ifdef __KORBIT__
+	printf("[%s]: ", ORBit_Trace_levellist[level]);
+
+	printf("%s", g_strdup_vprintf(fmt, args));
+	return 0; // breaks semantics, but return value is never used
+#else /* !__KORBIT__ */
+	fprintf(stderr, "[%s]: ", ORBit_Trace_levellist[level]);
+
+	return vfprintf(stderr, fmt, args);
+#endif /* !__KORBIT__ */
+}
+#endif
diff -urN linux-2.4.1/net/korbit/ORBitutil/trace.h linux-2.4.1-korbit/net/korbit/ORBitutil/trace.h
--- linux-2.4.1/net/korbit/ORBitutil/trace.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/trace.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,68 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@acm.org>
+ *
+ */
+
+#ifndef _ORBIT_TRACE_H_
+#define _ORBIT_TRACE_H_
+
+#include <stdarg.h>
+#include "util.h"
+
+typedef enum {
+	TraceMod_ORB,
+	TraceMod_CDR,
+	TraceMod_IIOP,
+	TraceMod_TC,
+	TraceMod_IR,
+	TraceMod_User=32
+} ORBit_TraceModule;
+
+typedef enum {
+	TraceLevel_Alert=0,
+	TraceLevel_Critical,
+	TraceLevel_Error,
+	TraceLevel_Warning,
+	TraceLevel_Notice,
+	TraceLevel_Info,
+	TraceLevel_Debug
+} ORBit_TraceLevel;
+
+extern const char *ORBit_Trace_levellist[];
+
+#ifdef ORBIT_DEBUG
+extern void ORBit_Trace_setCallback(int (*)(char *, va_list));
+extern int (*ORBit_Trace_getCallback(void))(char *, va_list);
+extern void ORBit_Trace_setModules(int);
+extern void ORBit_Trace_setLevel(ORBit_TraceLevel);
+extern int ORBit_Trace(ORBit_TraceModule, ORBit_TraceLevel, char *, ...);
+#else
+#define ORBit_Trace_setCallback(x)
+#define ORBit_Trace_getCallback() NULL
+#define ORBit_Trace_setModules(x)
+#define ORBit_Trace_setLevel(x)
+#define ORBit_Trace(module,level,fmt,args...)
+#endif
+
+
+#endif /* !_ORBIT_TRACE_H_ */
diff -urN linux-2.4.1/net/korbit/ORBitutil/util.h linux-2.4.1-korbit/net/korbit/ORBitutil/util.h
--- linux-2.4.1/net/korbit/ORBitutil/util.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/ORBitutil/util.h	Thu Feb  1 11:46:52 2001
@@ -0,0 +1,35 @@
+#ifndef UTIL_H
+#define UTIL_H 1
+
+#include <glib.h>
+
+#define ORBIT_DEBUG 1
+
+#ifdef ORBIT_DEBUG
+#define ORBIT_DEBUG_NOTE(x) (x)
+#else
+#define ORBIT_DEBUG_NOTE(x)
+#endif
+
+
+#define BitTest(f, bit)  ((f) & (1<<(bit)))
+#define BitSet(f, bit) ((f) |= (1<<(bit)))
+#define BitClr(f, bit) ((f) &= ~(1<<(bit)))
+/* Align an address upward to a boundary, expressed as a number of bytes.
+   E.g. align to an 8-byte boundary with argument of 8.  */
+
+/*
+ *   (this + boundary - 1)
+ *          &
+ *    ~(boundary - 1)
+ */
+
+#define ALIGN_ADDRESS(this, boundary) \
+  ((gpointer)((( ((unsigned long)(this)) + (((unsigned long)(boundary)) -1)) & (~(((unsigned long)(boundary))-1)))))
+
+#include <ORBitutil/thread-safety.h>
+#include <ORBitutil/trace.h>
+#include <ORBitutil/compat.h>
+#include <ORBitutil/os-specifics.h>
+
+#endif
diff -urN linux-2.4.1/net/korbit/config.h linux-2.4.1-korbit/net/korbit/config.h
--- linux-2.4.1/net/korbit/config.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/config.h	Thu Feb  1 11:46:49 2001
@@ -0,0 +1,73 @@
+
+/* Define if you have alloca, as a function or macro.  */
+#define HAVE_ALLOCA 1
+
+#define HAVE_ATEXIT 1
+#define NO_SYS_SIGLIST 1  /* reduce dependencies */
+#define NO_SYS_ERRLIST 1  /* reduce dependencies */
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+/* #define HAVE_ALLOCA_H 1 */
+
+/* Define if you have the vprintf function.  */
+#define HAVE_VPRINTF 1
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+#define HAVE_INET_ATON 1
+/* #undef ORBIT_SERIAL */
+
+/* Define to 'int' if it isn't defined in the header files. */
+/* #undef socklen_t */
+
+#define  ALIGNOF_CORBA_BOOLEAN 1
+#define  ALIGNOF_CORBA_CHAR 1
+#define  ALIGNOF_CORBA_DOUBLE 4
+#define  ALIGNOF_CORBA_FLOAT 4
+#define  ALIGNOF_CORBA_LONG 4
+#define  ALIGNOF_CORBA_LONG_DOUBLE 4
+#define  ALIGNOF_CORBA_LONG_LONG 4
+#define  ALIGNOF_CORBA_OCTET 1
+#define  ALIGNOF_CORBA_SHORT 2
+#define  ALIGNOF_CORBA_STRUCT 1
+#define  ALIGNOF_CORBA_UNSIGNED_LONG 4
+#define  ALIGNOF_CORBA_UNSIGNED_LONG_LONG 4
+#define  ALIGNOF_CORBA_UNSIGNED_SHORT 2
+#define  ALIGNOF_CORBA_WCHAR 2
+#define  ALIGNOF_CORBA_POINTER 4
+
+/* TCP wrappers */
+#define HAVE_TCPD_H 1
+
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+
+/* Define if you have the basename function.  */
+#define HAVE_BASENAME 1
+
+/* Define if you have the poll function.  */
+#define HAVE_POLL 1
+#define I_WANT_POLL 1
+
+/* Define if you have the <endian.h> header file.  */
+#define HAVE_ENDIAN_H 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <stddef.h> header file.  */
+#define HAVE_STDDEF_H 1
+
+/* Define if you have the <sys/poll.h> header file.  */
+#define HAVE_SYS_POLL_H 1
+
+/* Define if you have the <tcpd.h> header file.  */
+#define HAVE_TCPD_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the <wchar.h> header file.  */
+#define HAVE_WCHAR_H 1
diff -urN linux-2.4.1/net/korbit/exported_symbols.c linux-2.4.1-korbit/net/korbit/exported_symbols.c
--- linux-2.4.1/net/korbit/exported_symbols.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/exported_symbols.c	Thu Feb  1 11:46:49 2001
@@ -0,0 +1,93 @@
+/*
+ * #include whatever it takes to get the EXPORT_SYMBOL macro, and
+ * whatever header files from korbit (for things that are being
+ * exported.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include "errno.h"
+#include "orb/orbit.h"
+
+/* 
+ * Stuff that's good to export
+ */
+EXPORT_SYMBOL(errno);
+
+/* 
+ * kglib exports...
+ */
+EXPORT_SYMBOL(g_malloc0);
+EXPORT_SYMBOL(g_free);
+EXPORT_SYMBOL(g_snprintf);
+
+/*
+ * Mainline CORBA symbols.
+ */
+EXPORT_SYMBOL(CORBA_exception_init);
+EXPORT_SYMBOL(CORBA_ORB_init);
+EXPORT_SYMBOL(CORBA_ORB_resolve_initial_references);
+EXPORT_SYMBOL(CORBA_ORB_object_to_string);
+EXPORT_SYMBOL(CORBA_free);
+EXPORT_SYMBOL(CORBA_ORB_run);
+EXPORT_SYMBOL(CORBA_Object_release);
+EXPORT_SYMBOL(CORBA_Object_duplicate);
+EXPORT_SYMBOL(CORBA_octet_allocbuf);
+EXPORT_SYMBOL(CORBA_exception_set);
+EXPORT_SYMBOL(CORBA_string__free);
+EXPORT_SYMBOL(CORBA_ORB_string_to_object);
+EXPORT_SYMBOL(CORBA_string_alloc);
+EXPORT_SYMBOL(CORBA_exception_set_system);
+
+/* 
+ * ORBIT Specific symbols to export
+ */
+EXPORT_SYMBOL(ORBit_TypeCode_epv);
+EXPORT_SYMBOL(ORBit_send_system_exception);
+EXPORT_SYMBOL(ORBit_register_class);
+EXPORT_SYMBOL(ORBit_marshal_object);
+EXPORT_SYMBOL(ORBit_alloc);
+EXPORT_SYMBOL(ORBit_free);
+EXPORT_SYMBOL(ORBit_send_user_exception);
+EXPORT_SYMBOL(ORBit_delete_profiles);
+EXPORT_SYMBOL(ORBit_demarshal_object);
+EXPORT_SYMBOL(_ORBit_object_get_connection);
+EXPORT_SYMBOL(ORBit_handle_exception);
+EXPORT_SYMBOL(ORBit_object_get_forwarded_connection);
+EXPORT_SYMBOL(ORBit_default_principal_iovec);
+EXPORT_SYMBOL(ORBit_demarshal_IOR);
+
+/*
+ * CORBA giop functions
+ */
+EXPORT_SYMBOL(giop_send_buffer_write);
+EXPORT_SYMBOL(giop_send_buffer_unuse);
+EXPORT_SYMBOL(giop_message_buffer_do_alignment);
+EXPORT_SYMBOL(giop_message_buffer_append_mem);
+EXPORT_SYMBOL(giop_send_reply_buffer_use);
+EXPORT_SYMBOL(giop_send_request_buffer_use);
+EXPORT_SYMBOL(giop_recv_buffer_unuse);
+EXPORT_SYMBOL(giop_recv_reply_buffer_use_2);
+
+/*
+ * POA Symbols.
+ */
+EXPORT_SYMBOL(PortableServer_POAManager_activate);
+EXPORT_SYMBOL(PortableServer_POA_activate_object_with_id);
+EXPORT_SYMBOL(PortableServer_POA_servant_to_reference);
+EXPORT_SYMBOL(PortableServer_POA_deactivate_object);
+EXPORT_SYMBOL(PortableServer_POA__get_the_POAManager);
+EXPORT_SYMBOL(PortableServer_ServantBase__init);
+EXPORT_SYMBOL(PortableServer_ServantBase__fini);
+EXPORT_SYMBOL(PortableServer_POA_reference_to_servant);
+EXPORT_SYMBOL(PortableServer_POA_servant_to_id);
+EXPORT_SYMBOL(PortableServer_POA_activate_object);
+EXPORT_SYMBOL(PortableServer_POA_reference_to_id);
+
+/*
+ * TC Stuff (whatever that is)
+ */
+EXPORT_SYMBOL(TC_octet_struct);
+EXPORT_SYMBOL(TC_long_struct);
+EXPORT_SYMBOL(TC_ulong_struct);
+EXPORT_SYMBOL(TC_short_struct);
+EXPORT_SYMBOL(TC_string_struct);
diff -urN linux-2.4.1/net/korbit/include/.cvsignore linux-2.4.1-korbit/net/korbit/include/.cvsignore
--- linux-2.4.1/net/korbit/include/.cvsignore	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/.cvsignore	Thu Feb  1 11:46:53 2001
@@ -0,0 +1 @@
+stdarg.h
diff -urN linux-2.4.1/net/korbit/include/CVS/Entries linux-2.4.1-korbit/net/korbit/include/CVS/Entries
--- linux-2.4.1/net/korbit/include/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/CVS/Entries	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,24 @@
+/.cvsignore/1.1/Thu Feb  1 09:46:53 2001//
+/alloca.h/1.3/Thu Feb  1 09:46:53 2001//
+/assert.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/ctype.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/dirent.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/errno.h/1.2/Thu Feb  1 09:46:53 2001//
+/fcntl.h/1.3/Thu Feb  1 09:46:53 2001//
+/host_list.h/1.7/Thu Feb  1 09:46:53 2001//
+/limits.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/locale.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/math.h/1.2/Thu Feb  1 09:46:53 2001//
+/netdb.h/1.17/Thu Feb  1 09:46:53 2001//
+/pwd.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/signal.h/1.1.1.1/Thu Feb  1 09:46:53 2001//
+/stdarg.h/1.3/Thu Feb  1 09:46:54 2001//
+/stddef.h/1.1.1.1/Thu Feb  1 09:46:54 2001//
+/stdio.h/1.19/Thu Feb  1 09:46:54 2001//
+/stdlib.h/1.4/Thu Feb  1 09:46:54 2001//
+/string.h/1.3/Thu Feb  1 09:46:54 2001//
+/syslog.h/1.1.1.1/Thu Feb  1 09:46:54 2001//
+/time.h/1.1.1.1/Thu Feb  1 09:46:54 2001//
+/unistd.h/1.3/Thu Feb  1 09:46:54 2001//
+/utime.h/1.1.1.1/Thu Feb  1 09:46:54 2001//
+D
diff -urN linux-2.4.1/net/korbit/include/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/include/CVS/Entries.Log
--- linux-2.4.1/net/korbit/include/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/CVS/Entries.Log	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,3 @@
+A D/arpa////
+A D/netinet////
+A D/sys////
diff -urN linux-2.4.1/net/korbit/include/CVS/Repository linux-2.4.1-korbit/net/korbit/include/CVS/Repository
--- linux-2.4.1/net/korbit/include/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/CVS/Repository	Thu Feb  1 11:46:53 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/include
diff -urN linux-2.4.1/net/korbit/include/CVS/Root linux-2.4.1-korbit/net/korbit/include/CVS/Root
--- linux-2.4.1/net/korbit/include/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/CVS/Root	Thu Feb  1 11:46:53 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/include/alloca.h linux-2.4.1-korbit/net/korbit/include/alloca.h
--- linux-2.4.1/net/korbit/include/alloca.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/alloca.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,6 @@
+#ifndef __KORBIT_ALLOCA_H__
+#define __KORBIT_ALLOCA_H__
+
+#include <stdlib.h>
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/arpa/CVS/Entries linux-2.4.1-korbit/net/korbit/include/arpa/CVS/Entries
--- linux-2.4.1/net/korbit/include/arpa/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/arpa/CVS/Entries	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,2 @@
+/inet.h/1.4/Thu Feb  1 09:46:54 2001//
+D
diff -urN linux-2.4.1/net/korbit/include/arpa/CVS/Repository linux-2.4.1-korbit/net/korbit/include/arpa/CVS/Repository
--- linux-2.4.1/net/korbit/include/arpa/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/arpa/CVS/Repository	Thu Feb  1 11:46:54 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/include/arpa
diff -urN linux-2.4.1/net/korbit/include/arpa/CVS/Root linux-2.4.1-korbit/net/korbit/include/arpa/CVS/Root
--- linux-2.4.1/net/korbit/include/arpa/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/arpa/CVS/Root	Thu Feb  1 11:46:54 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/include/arpa/inet.h linux-2.4.1-korbit/net/korbit/include/arpa/inet.h
--- linux-2.4.1/net/korbit/include/arpa/inet.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/arpa/inet.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,50 @@
+#ifndef __KORBIT_ARPA_INET_H__
+#define __KORBIT_ARPA_INET_H__
+
+#include <linux/inet.h>
+#include <linux/in.h>
+
+static inline char* inet_ntoa(struct in_addr in)
+{
+   return in_ntoa(in.s_addr);
+}
+
+static inline int inet_aton(const char *cp, struct in_addr *inp)
+{
+	unsigned long l;
+	unsigned int val;
+	int i;
+
+        if (!cp || !inp)
+                return 0;
+
+	l = 0;
+	for (i = 0; i < 4; i++) 
+	{
+		l <<= 8;
+		if (*cp != '\0') 
+		{
+			val = 0;
+			while (*cp != '\0' && *cp != '.') 
+			{
+                                if (*cp < '0' || '9' < *cp)
+                                        return 0;
+                                
+				val *= 10;
+				val += *cp - '0';
+				cp++;
+			}
+                        if (val > 255)
+                                return 0;
+                        
+			l |= val;
+			if (*cp != '\0') 
+				cp++;
+		}
+	}
+	inp->s_addr = htonl(l);
+
+        return 1;
+}
+
+#endif /* __KORBIT_ARPA_INET_H__ */
diff -urN linux-2.4.1/net/korbit/include/assert.h linux-2.4.1-korbit/net/korbit/include/assert.h
--- linux-2.4.1/net/korbit/include/assert.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/assert.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_ASSERT_H__
+#define __KORBIT_ASSERT_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/ctype.h linux-2.4.1-korbit/net/korbit/include/ctype.h
--- linux-2.4.1/net/korbit/include/ctype.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/ctype.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,4 @@
+#ifndef __KORBIT_CTYPE_H__
+#define __KORBIT_CTYPE_H__
+#include <linux/ctype.h>
+#endif
diff -urN linux-2.4.1/net/korbit/include/dirent.h linux-2.4.1-korbit/net/korbit/include/dirent.h
--- linux-2.4.1/net/korbit/include/dirent.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/dirent.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_DIRENT_H__
+#define __KORBIT_DIRENT_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/errno.h linux-2.4.1-korbit/net/korbit/include/errno.h
--- linux-2.4.1/net/korbit/include/errno.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/errno.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,9 @@
+#ifndef __KORBIT_ERRNO_H__
+#define __KORBIT_ERRNO_H__
+
+#include <asm/errno.h>
+
+#define errno korbit_errno
+extern int korbit_errno;
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/fcntl.h linux-2.4.1-korbit/net/korbit/include/fcntl.h
--- linux-2.4.1/net/korbit/include/fcntl.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/fcntl.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,49 @@
+#ifndef __KORBIT_FCNTL_H__
+#define __KORBIT_FCNTL_H__
+
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/smp_lock.h>
+
+#include <asm/fcntl.h>
+
+#include <stdio.h>
+
+#define SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | FASYNC)
+
+static inline int fcntl(int fd, int cmd, long arg)
+{
+        struct file *filp = fd2file(fd);
+        long err = -EINVAL;
+        
+        switch (cmd)
+        {
+        case F_SETFD:
+        case F_GETFD:
+                err = 0;
+                break;
+        case F_GETFL:
+                if (filp)
+                        err = filp->f_flags;
+                break;
+        case F_SETFL:
+                if (filp)
+                {
+                        lock_kernel();
+
+                        /* required for strict SunOS emulation */
+                        if (O_NONBLOCK != O_NDELAY)
+                          if (arg & O_NDELAY)
+                            arg |= O_NONBLOCK;
+
+                        filp->f_flags = (arg & SETFL_MASK) | 
+                                        (filp->f_flags & ~SETFL_MASK);
+                        err = 0;
+                        unlock_kernel();
+                }
+                break;
+        }
+        return err;
+}
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/host_list.h linux-2.4.1-korbit/net/korbit/include/host_list.h
--- linux-2.4.1/net/korbit/include/host_list.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/host_list.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,24 @@
+/*
+ * A statically-allocated list of Hostnames<->IPv4 addresses.
+ */
+#ifndef __KORBIT_HOST_LIST_H
+#define __KORBIT_HOST_LIST_H
+
+static struct {
+        char *name;
+        char *IP;
+} host_table[] = {
+        {"redefine.dyndns.org", "206.221.225.140"},
+        {"csil-sunb4.cs.uiuc.edu", "128.174.243.204"},
+        {"kazoo.cs.uiuc.edu", "128.174.237.133"},
+        {"opus0.cs.uiuc.edu", "128.174.236.20"},
+        {"wakeland-56.flexabit.net", "64.198.239.56"},
+	{"es-dcl-border1.cso.uiuc.edu", "127.0.0.1"},
+	{"es-dcl-border1", "127.0.0.1"}
+//	{"es-dcl-border1.cso.uiuc.edu", "130.126.112.222"},
+//	{"es-dcl-border1", "130.126.112.222"}
+};
+
+#define __MAX_STATIC_NAMES (sizeof(host_table) / sizeof(host_table[0]))
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/limits.h linux-2.4.1-korbit/net/korbit/include/limits.h
--- linux-2.4.1/net/korbit/include/limits.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/limits.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,7 @@
+#ifndef __KORBIT_LIMITS_H__
+#define __KORBIT_LIMITS_H__
+
+#include <linux/limits.h>
+#include <linux/kernel.h>
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/locale.h linux-2.4.1-korbit/net/korbit/include/locale.h
--- linux-2.4.1/net/korbit/include/locale.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/locale.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_LOCALE_H__
+#define __KORBIT_LOCALE_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/math.h linux-2.4.1-korbit/net/korbit/include/math.h
--- linux-2.4.1/net/korbit/include/math.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/math.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,16 @@
+#ifndef __KORBIT_MATH_H__
+#define __KORBIT_MATH_H__
+
+#include <asm/page.h>
+
+static inline double pow(double x, double y) {
+	double Q = 1.0; 
+	if (y < 0) 
+		BUG();
+/*		return 1.0/pow(x,-y);*/
+	while (y-- > 0)
+		Q *= x;
+	return Q;
+}
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/netdb.h linux-2.4.1-korbit/net/korbit/include/netdb.h
--- linux-2.4.1/net/korbit/include/netdb.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/netdb.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,197 @@
+#ifndef __KORBIT_NETDB_H__
+#define __KORBIT_NETDB_H__
+
+#include <sys/socket.h>
+#include <linux/in.h>
+#include <arpa/inet.h>
+#include "host_list.h"
+
+#define h_errno 0
+/* static int h_errno; */
+
+/* Description of data base entry for a single host.  */
+struct hostent
+{
+  char *h_name;			/* Official name of host.  */
+  char **h_aliases;		/* Alias list.  */
+  int h_addrtype;		/* Host address type.  */
+  socklen_t h_length;		/* Length of address.  */
+  char **h_addr_list;		/* List of addresses from name server.  */
+#define	h_addr	h_addr_list[0]	/* Address, for backward compatibility.  */
+};
+
+/* Is this defined somewhere else? */
+/*struct in_addr {
+	__uint32_t s_addr;
+};*/
+
+/*
+ * Set h_errno?
+ * #define HOST_NOT_FOUND 1
+ * #define TRY_AGAIN 2
+ * #define NO_RECOVERY 3
+ * #define NO_DATA 4
+ */
+static inline struct hostent *gethostbyname (char *host)
+{
+	int c;
+	static struct in_addr tmp_in;
+	static struct hostent ret_host;
+	static char *aliases[2];
+	static char *addrs[2];
+
+	if (host == NULL)
+		{
+		printf ("** gethostbyname() Error: Got NULL parameter! **\n");
+		return (NULL);
+		}
+
+	/*
+	 * The actual lookup.
+	 */
+	for (c = 0; c < __MAX_STATIC_NAMES; c++)
+		{
+			if (host_table[c].name && strncmp (host, host_table[c].name, strlen(host_table[c].name)) == 0)
+				{
+/*				printf ("Name '%s' found at position %d!\n", argv[1], c);*/
+/*				printf ("IP address is: '%s'.\n", IPs[c]);*/
+				break;
+				}
+		}
+
+	if (c == __MAX_STATIC_NAMES)
+		{
+		/* Host not found, return NULL. */
+		return (NULL);
+		}
+	/* else, names[c] is gold! */
+
+	/* make a new hostent, ret_host */
+
+	ret_host.h_addrtype = AF_INET;
+	ret_host.h_aliases = aliases;
+	aliases[0] = host_table[c].name;
+	aliases[1] = NULL;
+	ret_host.h_name = host_table[c].name;
+	if (!inet_aton (host_table[c].IP, &tmp_in))
+		{
+		printf ("** gethostbyname() Error: Invalid IP address in table! **\n");
+		return (NULL);
+		}
+	ret_host.h_addr_list = addrs;
+	addrs[0] = (char *)&tmp_in.s_addr;
+	addrs[1] = NULL;
+	ret_host.h_length = sizeof (tmp_in.s_addr);
+	return (&ret_host);
+} /* End gethostbyname(). */
+
+/*
+ * TODO: getpeername(), gethostbyaddr(), getsockname(), gethostname()
+ * Everything from here-on has been untested (in userland). Buyer beware.
+ */
+static inline struct hostent *gethostbyaddr (const char *addr, int len, int type)
+{
+	struct in_addr tin;
+	char *inp_addr;
+	int c;
+	static struct hostent ret_host;
+	static char *aliases[1];
+	static char *addrs[2];
+	static struct in_addr tmp_in;
+
+
+	if ((type != AF_INET) || (len != 4))
+		{
+		printf ("** gethostbyaddr Error: Don't know how to deal with non-AF_INET addresses! **\n");
+		return (NULL);
+		}
+
+	tin.s_addr = *((__u32 *)addr);
+	inp_addr = inet_ntoa (tin);
+	if (inp_addr == NULL)
+		{
+		/* We got some invalid input, baby. */
+		return (NULL);
+
+		}
+
+	/*
+	 * The actual lookup.
+	 */
+	for (c = 0; c < __MAX_STATIC_NAMES; c++)
+		{
+			if (host_table[c].IP && strncmp (inp_addr, host_table[c].IP, strlen(host_table[c].IP)) == 0)
+				{
+				break;
+				}
+		}
+
+	if (c == __MAX_STATIC_NAMES)
+		{
+		/* Host not found, return NULL. */
+		return (NULL);
+		}
+	/* else, host_table[c].IP is gold! */
+
+	ret_host.h_addrtype = AF_INET;
+	ret_host.h_aliases = aliases;
+	aliases[0] = NULL;
+	ret_host.h_name = host_table[c].name;
+	if (!inet_aton (host_table[c].IP, &tmp_in))
+		{
+		printf ("** gethostbyname() Error: Invalid IP address in table! **\n");
+		return (NULL);
+		}
+	ret_host.h_addr_list = addrs;
+	addrs[0] = (char *)&tmp_in.s_addr;
+	addrs[1] = NULL;
+	ret_host.h_length = sizeof (tmp_in.s_addr);
+	return (&ret_host);	
+} /* End gethostbyaddr(). */
+
+/*
+ * If successful, return 0. Else, return -1 and set errno.
+ * Errors:
+ *    EBADF The argument s is not a valid file descriptor.
+ *
+ *    ENOMEM
+ *          There was insufficient memory available for the opera-
+ *          tion to complete.
+ *
+ *    ENOSR There were insufficient  STREAMS  resources  available
+ *          for the operation to complete.
+ *
+ *    ENOTSOCK
+ *          The argument s is not a socket.
+ */
+static inline int getsockname (int s, struct sockaddr *name, socklen_t *namelen)
+{
+ 	struct socket *sock = fd2sock(s);
+
+	if (sock == NULL)
+	        return -1;
+
+	/*
+	 * getname() wants an 'int *' for the length, will it by this
+	 * 'socklen_t *' business? (even though it is just an 'int *'?).
+	 */
+	if (sock->ops->getname(sock, name, namelen, 0) == 0)
+	        return 0;
+	else
+	    	return -1; /* should normally also set errno */
+} /* End getsockname(). */
+
+static inline int getpeername (int s, struct sockaddr *name, socklen_t *namelen)
+{
+ 	struct socket *sock = fd2sock(s);
+
+	if (sock == NULL)
+	        return -1;
+
+	if (sock->ops->getname(sock, name, namelen, 1) == 0)
+	        return 0;
+	else
+	    	return -1; /* should normally also set errno */
+} /* End getpeername(). */
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/netinet/CVS/Entries linux-2.4.1-korbit/net/korbit/include/netinet/CVS/Entries
--- linux-2.4.1/net/korbit/include/netinet/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/netinet/CVS/Entries	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,2 @@
+/in.h/1.1.1.1/Thu Feb  1 09:46:55 2001//
+D
diff -urN linux-2.4.1/net/korbit/include/netinet/CVS/Repository linux-2.4.1-korbit/net/korbit/include/netinet/CVS/Repository
--- linux-2.4.1/net/korbit/include/netinet/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/netinet/CVS/Repository	Thu Feb  1 11:46:55 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/include/netinet
diff -urN linux-2.4.1/net/korbit/include/netinet/CVS/Root linux-2.4.1-korbit/net/korbit/include/netinet/CVS/Root
--- linux-2.4.1/net/korbit/include/netinet/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/netinet/CVS/Root	Thu Feb  1 11:46:55 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/include/netinet/in.h linux-2.4.1-korbit/net/korbit/include/netinet/in.h
--- linux-2.4.1/net/korbit/include/netinet/in.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/netinet/in.h	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,5 @@
+#ifndef __KORBIT_NETINET_IN_H__
+#define __KORBIT_NETINET_IN_H__
+#include <linux/socket.h>
+#include <linux/in.h>
+#endif
diff -urN linux-2.4.1/net/korbit/include/pwd.h linux-2.4.1-korbit/net/korbit/include/pwd.h
--- linux-2.4.1/net/korbit/include/pwd.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/pwd.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_PWD_H__
+#define __KORBIT_PWD_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/signal.h linux-2.4.1-korbit/net/korbit/include/signal.h
--- linux-2.4.1/net/korbit/include/signal.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/signal.h	Thu Feb  1 11:46:53 2001
@@ -0,0 +1,6 @@
+#ifndef __KORBIT_SIGNAL_H__
+#define __KORBIT_SIGNAL_H__
+
+#include <asm/signal.h>
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/stdarg.h linux-2.4.1-korbit/net/korbit/include/stdarg.h
--- linux-2.4.1/net/korbit/include/stdarg.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/stdarg.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,13 @@
+#ifndef __KORBIT_STDARG_H__
+#define __KORBIT_STDARG_H__
+
+#define ANDY 1
+
+#if FREDRIK
+#include "/usr/lib/gcc-lib/i386-glibc21-linux/egcs-2.91.66/include/stdarg.h"
+#elif CHRIS
+#include "/usr/lib/gcc-lib/i586-mandrake-linux/egcs-2.91.66/include/stdarg.h"
+#elif ANDY
+#include "/usr/lib/gcc-lib/i386-redhat-linux/egcs-2.91.66/include/stdarg.h"
+#endif
+#endif
diff -urN linux-2.4.1/net/korbit/include/stddef.h linux-2.4.1-korbit/net/korbit/include/stddef.h
--- linux-2.4.1/net/korbit/include/stddef.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/stddef.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_STDDEF_H__
+#define __KORBIT_STDDEF_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/stdio.h linux-2.4.1-korbit/net/korbit/include/stdio.h
--- linux-2.4.1/net/korbit/include/stdio.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/stdio.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,402 @@
+#ifndef __KORBIT_STDIO_H__
+#define __KORBIT_STDIO_H__
+
+#include <asm/segment.h>
+#include <asm/uaccess.h>
+#include <linux/smp_lock.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/uio.h>
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/highuid.h>
+#include <sys/socket.h>
+
+#include <errno.h>
+
+#define KORBIT_DEBUG_WRITING 0
+
+
+#define printf(format,args...) printk(format,##args)
+#define fflush(x)
+
+#define SEEK_SET       0       /* Seek from beginning of file.  */
+#define SEEK_CUR       1       /* Seek from current position.  */
+#define SEEK_END       2       /* Seek from end of file.  */
+
+static inline int unlink(const char *pathname) {
+  printf("KERNEL UNLINK('%s') CALLED!\n", pathname);
+  return -1;
+}
+
+static inline struct file *fd2file(int fd) {
+        if (fd & 1) /* can't convert a socket! */
+                return NULL;
+
+        return (struct file *)(-(fd & ~1));
+}
+
+static inline int open(const char *filename, int flags, int mode) {
+        struct file *RetVal = filp_open(filename, flags, mode);
+        if (IS_ERR(RetVal))
+        {
+                errno = PTR_ERR(RetVal);
+                return -1;
+        }
+        return -(int)RetVal;
+}
+
+static inline int creat(const char *filename, mode_t mode)
+{
+        return open(filename, O_CREAT | O_WRONLY | O_TRUNC, mode);
+}
+
+static inline int lseek(int fd, long offset, int whence)
+{
+        if ((fd & 1) == 1)
+        {
+                printk("KERNEL FSEEK() CALLED ON SOCKET!\n");
+                return -1;
+        }
+        else 
+        {
+                struct file *F = fd2file(fd);
+                loff_t (*fn)(struct file *, loff_t, int);
+                int retval = -1;
+
+                if (whence <= 2) 
+                {
+                        fn = default_llseek;
+                        if (F->f_op && F->f_op->llseek)
+                                fn = F->f_op->llseek;
+                        
+                        lock_kernel();
+                        retval = fn(F, offset, whence);
+                        unlock_kernel();
+                }
+                if (retval < 0)
+                {
+                        errno = -retval;
+                        retval = -1;
+                }
+                return retval;
+        }
+}
+
+
+asmlinkage long sys_newstat(char * filename, struct stat * statbuf);
+static inline int stat(char *filename, struct stat *buf)
+{
+        mm_segment_t oldfs;
+        int retval;
+        
+        oldfs = get_fs(); set_fs(KERNEL_DS); 
+        retval = sys_newstat(filename, buf);
+        set_fs(oldfs);
+        if (retval < 0)
+        {
+                errno = -retval;
+                retval = -1;
+        }
+        return retval;
+}
+
+asmlinkage long sys_newlstat(char * filename, struct stat * statbuf);
+static inline int lstat(char *filename, struct stat *buf)
+{
+        mm_segment_t oldfs;
+        int retval;
+        
+        oldfs = get_fs(); set_fs(KERNEL_DS); 
+        retval = sys_newlstat(filename, buf);
+        set_fs(oldfs);
+        if (retval < 0)
+        {
+                errno = -retval;
+                retval = -1;
+        }
+        return retval;
+}
+
+
+static inline int do_revalidate(struct dentry *dentry)
+{
+        struct inode * inode = dentry->d_inode;
+        if (inode->i_op && inode->i_op->revalidate)
+                return inode->i_op->revalidate(dentry);
+        return 0;
+}
+
+
+static inline int cp_new_stat(struct inode * inode, struct stat * statbuf)
+{
+        struct stat tmp;
+        
+        memset(&tmp, 0, sizeof(tmp));
+        tmp.st_dev = kdev_t_to_nr(inode->i_dev);
+        tmp.st_ino = inode->i_ino;
+        tmp.st_mode = inode->i_mode;
+        tmp.st_nlink = inode->i_nlink;
+        SET_STAT_UID(tmp, inode->i_uid);
+        SET_STAT_GID(tmp, inode->i_gid);
+        tmp.st_rdev = kdev_t_to_nr(inode->i_rdev);
+#if BITS_PER_LONG == 32
+        if (inode->i_size > 0x7fffffff)
+                return -EOVERFLOW;
+        else
+#endif  
+        {
+                tmp.st_size = inode->i_size;
+                tmp.st_atime = inode->i_atime;
+                tmp.st_mtime = inode->i_mtime;
+                tmp.st_ctime = inode->i_ctime;
+                
+                tmp.st_blocks = inode->i_blocks;
+                tmp.st_blksize = inode->i_blksize;
+                
+                memcpy(statbuf, &tmp, sizeof(tmp));
+                return 0;
+        }
+}
+
+
+static inline int fstat(int fd, struct stat *buf)
+{
+        if ((fd & 1) == 1)
+        {
+                printk("TODO : FSTAT FOR SOCKETS, DO WE WANT THIS?\n");
+                errno = EBADF;
+                return -1;
+        }
+        else
+        {
+                struct file *file = fd2file(fd);
+                struct dentry *dentry;
+                int retval = -EBADF;
+                
+                if (file) 
+                {
+                        dentry = file->f_dentry;
+                        retval = do_revalidate(dentry);
+                        
+                        if (!retval)
+                                retval =  cp_new_stat(dentry->d_inode, buf);
+                }
+                if (retval < 0)
+                {
+                        errno = -retval;
+                        retval = -1;
+                }
+                return retval;
+        }
+}
+
+
+asmlinkage long sys_readlink(const char * path, char * buf, int bufsiz);
+static inline int readlink(const char *path, char *buf, size_t bufsiz)
+{
+        int retval;
+        mm_segment_t oldfs;
+        
+        oldfs = get_fs(); set_fs(KERNEL_DS); 
+        retval = sys_readlink(path, buf, bufsiz);
+        set_fs(oldfs);
+        if (retval < 0)
+        {
+                errno = -retval;
+                retval = -1;
+        }
+        return retval;
+}
+
+
+static inline int read(int fd, void *buffer, size_t count) {
+        if ((fd & 1) == 1)
+        {
+                struct socket *sock = fd2sock(fd);
+                struct iovec iov;
+                struct msghdr msg;
+		mm_segment_t oldfs;
+                int flags = 0;
+                int RetVal;
+                
+                msg.msg_name = NULL;
+                msg.msg_namelen = 0;
+                msg.msg_iov = &iov;
+                msg.msg_iovlen = 1;
+                msg.msg_control = NULL;
+                msg.msg_controllen = 0;
+		msg.msg_flags = 0;
+                iov.iov_base = buffer;
+                iov.iov_len = count;
+		oldfs = get_fs(); set_fs(KERNEL_DS); 
+                RetVal = sock_recvmsg(sock, &msg, count, flags);
+		set_fs(oldfs);
+                if (RetVal < 0)
+                {
+                        errno = -RetVal;
+                        RetVal = -1;
+                }
+                return RetVal;
+        }
+        else
+        {
+                struct file *F = fd2file(fd);
+                mm_segment_t oldfs;
+                int RetVal;
+                
+                oldfs = get_fs(); 
+                set_fs(KERNEL_DS);
+                RetVal = F->f_op->read(F, buffer, count, &F->f_pos);
+                set_fs(oldfs);
+                if (RetVal < 0)
+                {
+                        errno = -RetVal;
+                        RetVal = -1;
+                }
+                return RetVal;
+        }
+}
+
+static inline int write(int fd, const void *buffer, size_t count) {
+        if ((fd & 1) == 1)
+        {
+                struct socket *sock = fd2sock(fd);
+                struct iovec iov;
+                struct msghdr msg;
+		mm_segment_t oldfs;
+                int RetVal;
+                msg.msg_name = NULL;
+                msg.msg_namelen = 0;
+                msg.msg_iov = &iov;
+                msg.msg_iovlen = 1;
+                msg.msg_control = NULL;
+                msg.msg_controllen = 0;
+		msg.msg_flags = MSG_NOSIGNAL;
+                if (sock->type == SOCK_SEQPACKET)
+                        msg.msg_flags |= MSG_EOR;
+                iov.iov_base = (void *)buffer;
+                iov.iov_len = count;
+
+		oldfs = get_fs(); set_fs(KERNEL_DS); 
+                RetVal = sock_sendmsg(sock, &msg, count);
+		set_fs(oldfs);
+                if (RetVal < 0)
+                {
+                        errno = -RetVal;
+                        RetVal = -1;
+                }
+                return RetVal;
+        }
+        else
+        {
+                struct file *F = fd2file(fd);
+                mm_segment_t oldfs;
+                int RetVal;
+                
+                oldfs = get_fs(); 
+                set_fs(KERNEL_DS);
+                RetVal = F->f_op->write(F, buffer, count, &F->f_pos);
+                set_fs(oldfs);
+                if (RetVal < 0)
+                {
+                        errno = -RetVal;
+                        RetVal = -1;
+                }
+                return RetVal;
+        }
+}
+
+static inline int writev(int fd, const struct iovec  *vector, int count) {
+#ifndef DONT_USE_SIMPLE_WRITEV
+  int i, amount = 0;
+#if KORBIT_DEBUG_WRITING
+  printk("writev (fd = 0x%X, vec=0x%p, count = %d)\n", fd, vector, count);
+#endif
+  for (i = 0; i < count; i++) {
+    char *Buf = vector[i].iov_base;
+    int Amount = vector[i].iov_len;
+    while (Amount > 0) {
+      int A = write(fd, Buf, Amount);
+//#if KORBIT_DEBUG_WRITING
+if (A < Amount)
+      printk("  write(fd = 0x%X, buf = 0x%p, size = 0x%X) "
+             "= 0x%X errno = 0x%X\n", fd, Buf, Amount, A, errno);
+//#endif
+      Amount -= A;
+      amount += A;
+      Buf += A;
+      if (Amount > 0) schedule();     // Behave somewhat nicely...
+    }
+  }
+
+#if KORBIT_DEBUG_WRITING
+  printk("writev returning 0x%X[%d]\n", amount, amount);
+#endif
+  return amount;
+
+#else
+        if ((fd & 1) == 1)
+        {
+                struct socket *sock =  fd2sock(fd);
+                struct msghdr msg;
+		mm_segment_t oldfs;
+                int i, RetVal;
+                size_t tot_len = 0;
+                
+                for (i = 0; i < count; i++)
+                        tot_len += vector[i].iov_len;
+                
+                msg.msg_name = NULL;
+                msg.msg_namelen = 0;
+                msg.msg_iov = (struct iovec *)vector;
+                msg.msg_iovlen = count;
+                msg.msg_control = NULL;
+                msg.msg_controllen = 0;
+                if (sock->type == SOCK_SEQPACKET)
+                        msg.msg_flags |= MSG_EOR;
+
+		oldfs = get_fs(); set_fs(KERNEL_DS); 
+                RetVal = sock_sendmsg(sock, &msg, tot_len);
+		set_fs(oldfs);
+                if (RetVal < 0)
+                {
+                        errno = -RetVal;
+                        RetVal = -1;
+                }
+                return RetVal;
+        }
+        else
+        {
+                struct file *F = fd2file(fd);
+                mm_segment_t oldfs;
+                int RetVal;
+                
+                oldfs = get_fs(); 
+                set_fs(KERNEL_DS);
+                RetVal = F->f_op->writev(F, vector, (unsigned)count, &F->f_pos);
+                set_fs(oldfs);
+                if (RetVal < 0)
+                {
+                        errno = -RetVal;
+                        RetVal = -1;
+                }
+                return RetVal;
+        }
+#endif
+}
+
+static inline int close(int fd) {
+        int err = 0;
+        if ((fd & 1) == 1) {
+                struct socket *sock = fd2sock(fd);
+                sock_release(sock);
+        } else {
+                struct file *file = fd2file(fd);
+                fput(file);
+        }
+        return err;
+}
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/stdlib.h linux-2.4.1-korbit/net/korbit/include/stdlib.h
--- linux-2.4.1/net/korbit/include/stdlib.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/stdlib.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,99 @@
+#ifndef __KORBIT_STDLIB_H__
+#define __KORBIT_STDLIB_H__
+
+#include <linux/kernel.h>
+#include <linux/malloc.h>
+#include <linux/types.h>
+#include <asm/string.h>
+
+#define strtol(nptr,endptr,base) simple_strtol(nptr,endptr,base)
+
+#if 0
+#define malloc(size) kmalloc(size, GFP_KERNEL)
+#define free(ptr) kfree(ptr)
+#endif
+
+static inline void *malloc(size_t size)
+{
+        void *ptr = NULL;
+
+        if (size == 0) 
+                size = 4;
+
+        ptr = kmalloc(size + sizeof(size), GFP_KERNEL);
+
+        if (ptr)
+        {
+                *((size_t *)ptr) = size;
+                ptr = (size_t *)ptr + 1;
+        }
+        
+        return ptr;
+}
+
+static inline void free(void *ptr)
+{
+        if (ptr)
+                kfree((size_t *)ptr - 1);
+}
+
+#define alloca(size) malloc(size)
+
+/* freeca(ptr) - free a mem allocation if ptr points to one, otherwise do 
+ * nothing.
+ */
+static inline void freeca(void *ptr)
+{
+    if (ptr != NULL) { /* Don't free it if it's already free */
+	free(ptr);
+    }
+}
+
+static inline void *calloc(size_t nmemb, size_t size)
+{
+        void *ptr = malloc(nmemb*size);
+        if (ptr)
+                memset(ptr,0,nmemb*size);
+        return ptr;
+}
+
+static inline void *realloc(void *ptr, size_t size)
+{
+        void *newptr = NULL;
+
+        if (size != 0)
+                newptr = malloc(size);
+        
+        if (ptr && newptr) /* Copy old contents */
+        {
+                size_t *p1 = (size_t *)ptr - 1;
+                size_t *p2 = (size_t *)newptr - 1;
+                size_t n = *p1 < *p2 ? *p1 : *p2;
+                memcpy(newptr, ptr, n);
+        }
+
+        if (ptr)
+                free(ptr);
+        
+        return newptr;
+}
+
+/* Returned by `div'.  */
+typedef struct
+{
+        int quot;			/* Quotient.  */
+        int rem;			/* Remainder.  */
+} div_t;
+
+static inline div_t div(int number, int denom)
+{
+        div_t result;
+        result.quot = number/denom;
+        result.rem = number-(number*result.quot);
+        return result;
+}
+
+#define atexit(fn) -1
+#define getenv(name) 0
+
+#endif /* __KORBIT_STDLIB_H__ */
diff -urN linux-2.4.1/net/korbit/include/string.h linux-2.4.1-korbit/net/korbit/include/string.h
--- linux-2.4.1/net/korbit/include/string.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/string.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,11 @@
+#ifndef __KORBIT_STRING_H__
+#define __KORBIT_STRING_H__
+
+#include <linux/types.h>
+#include <asm/string.h>
+
+#include <glib.h>
+
+#define strerror(errno) g_strerror(errno)
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/CVS/Entries linux-2.4.1-korbit/net/korbit/include/sys/CVS/Entries
--- linux-2.4.1/net/korbit/include/sys/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/CVS/Entries	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,10 @@
+/ioctl.h/1.1.1.1/Thu Feb  1 09:46:55 2001//
+/poll.h/1.25/Thu Feb  1 09:46:55 2001//
+/socket.h/1.20/Thu Feb  1 09:46:55 2001//
+/stat.h/1.1.1.1/Thu Feb  1 09:46:55 2001//
+/time.h/1.1.1.1/Thu Feb  1 09:46:55 2001//
+/types.h/1.1.1.1/Thu Feb  1 09:46:56 2001//
+/uio.h/1.1.1.1/Thu Feb  1 09:46:56 2001//
+/un.h/1.1.1.1/Thu Feb  1 09:46:56 2001//
+/wait.h/1.1.1.1/Thu Feb  1 09:46:56 2001//
+D
diff -urN linux-2.4.1/net/korbit/include/sys/CVS/Repository linux-2.4.1-korbit/net/korbit/include/sys/CVS/Repository
--- linux-2.4.1/net/korbit/include/sys/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/CVS/Repository	Thu Feb  1 11:46:55 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/include/sys
diff -urN linux-2.4.1/net/korbit/include/sys/CVS/Root linux-2.4.1-korbit/net/korbit/include/sys/CVS/Root
--- linux-2.4.1/net/korbit/include/sys/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/CVS/Root	Thu Feb  1 11:46:55 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/include/sys/ioctl.h linux-2.4.1-korbit/net/korbit/include/sys/ioctl.h
--- linux-2.4.1/net/korbit/include/sys/ioctl.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/ioctl.h	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_SYS_IOCTL_H__
+#define __KORBIT_SYS_IOCTL_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/poll.h linux-2.4.1-korbit/net/korbit/include/sys/poll.h
--- linux-2.4.1/net/korbit/include/sys/poll.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/poll.h	Fri Feb  2 01:22:10 2001
@@ -0,0 +1,112 @@
+#ifndef __KORBIT_SYS_POLL_H__
+#define __KORBIT_SYS_POLL_H__
+
+#include <asm/poll.h>
+#include <asm/param.h>
+#include <linux/net.h>
+#include <linux/tcp.h>
+#include <linux/socket.h>
+#include <net/tcp.h>
+#include <net/sock.h>
+#include <linux/skbuff.h>
+#include <linux/sched.h>
+#include "stdlib.h"
+#include "sys/socket.h"
+
+/* Poll the file descriptors described by the NFDS structures starting at
+ * FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
+ * an event to occur; if TIMEOUT is -1, block until an event occurs.
+ * Returns the number of file descriptors with events, zero if timed
+ * out, or -1 for errors.
+ */
+
+/* This implementation of poll assumes that we are sitting on the wait
+ * queues for all of the file descriptors already.  Therefore if we are about
+ * to block, all we have to do is perform the schedule call which will
+ * automatically cause us to "block".
+ */
+static int poll_CheckFDs(struct pollfd *fds, unsigned long int nfds)
+{
+  int NumReady = 0, i;
+
+  // Loop over the file descriptors seeing if there is already work to be
+  // done...
+  for (i = 0; i < nfds; i++) {
+        struct socket *sock = fd2sock(fds[i].fd);
+	fds[i].revents = 0;
+
+        // Check to see if stuff is available to read
+        if (sock) {
+                // It's a socket baby
+                fds[i].revents = tcp_poll(0, sock, 0);
+
+                // Apparently tcp_poll doesn't look at the CLOSE_WAIT value,
+                // and we have a lot of sockets that end up in this state.
+                // This is a hack to shortcircuit some read failures from
+                // later.  This breaks "poll semantics" strictly speaking, but
+                // it's basically the "right thing to do" (tm).
+		if (sock->sk->state == TCP_CLOSE_WAIT) 
+                        fds[i].revents = POLLHUP;
+               	fds[i].revents &= fds[i].events | POLLERR | POLLHUP;
+        } else {
+                // It's a file
+                //struct file *f = fd2file(fd);
+//                printk("POLL NOT IMPLEMENTED FOR FILES YET\n");
+                BUG();
+	}
+
+        if (fds[i].revents) {
+                NumReady++;
+//                printk("FD #%d: Event = 0x%X\n", i, fds[i].revents);
+	}
+
+  } /* for */
+
+  return NumReady;
+} /* End poll_CheckFDs(). */
+
+
+static int poll(struct pollfd *fds, unsigned long int nfds, int timeout) {
+  wait_queue_t *WaitQueues = 0;
+  int NumReady = poll_CheckFDs(fds, nfds);
+  int i; 
+
+  if (NumReady || timeout == 0)
+    return NumReady;
+
+//  printk("Starting to Poll... %d fds...\n", nfds);
+  WaitQueues = (wait_queue_t*)malloc(nfds*sizeof(wait_queue_t));
+  if (WaitQueues == 0) return 0; // Crap, nomem...
+
+  for (i = 0; i < nfds; i++) { 
+    struct socket *sock = fd2sock(fds[i].fd);
+    init_waitqueue_entry(WaitQueues+i, current);
+
+    if (sock)
+      add_wait_queue_exclusive(sock->sk->sleep, WaitQueues+i);
+//    else 
+//      printk("I don't know how to wait on fd #%d = 0x%X\n", i, fds[i].fd);
+  }
+
+  // Wait for us to get notified by one of the socket wait queue notifiers!
+  do {
+    // Change our task state so that we are not immediately rescheduled.  
+    // This lets the scheduler know that we are waiting for something to happen
+    set_current_state(TASK_INTERRUPTIBLE);
+    schedule();
+  } while (!(NumReady = poll_CheckFDs(fds, nfds)));
+
+  set_current_state(TASK_RUNNING);
+
+  for (i = 0; i < nfds; i++) { 
+    struct socket *sock = fd2sock(fds[i].fd);
+    if (sock)
+      remove_wait_queue(sock->sk->sleep, WaitQueues+i);
+  }
+
+  free(WaitQueues);
+//  printk("Returning %d\n", NumReady);
+  return NumReady;
+}
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/socket.h linux-2.4.1-korbit/net/korbit/include/sys/socket.h
--- linux-2.4.1/net/korbit/include/sys/socket.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/socket.h	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,126 @@
+#ifndef __KORBIT_SYS_SOCKET_H__
+#define __KORBIT_SYS_SOCKET_H__
+typedef unsigned int socklen_t;
+
+#include <linux/socket.h>
+#include <linux/wait.h>
+#include <asm/semaphore.h>
+#include <net/sock.h>
+
+/* These functions are declared in net/socket.c */
+asmlinkage long sys_socket(int family, int type, int protocol);
+struct socket *sockfd_lookup(int fd, int *err);
+
+
+static inline int sock2fd(struct socket *s)
+{
+        return (-(int)s) | 1;
+}
+
+static inline struct socket *fd2sock(int sockfd)
+{
+        if ((sockfd & 1) == 0) /* can't convert a file! */
+                return NULL;
+
+        return (struct socket *)(-(sockfd & ~1));
+}
+
+
+static inline int socket(int domain, int type, int protocol) {
+        struct socket *sock;
+        int retval = sock_create(domain, type, protocol, &sock);
+
+        if (retval < 0) return (int)NULL;
+        return sock2fd(sock);
+}
+
+
+static inline int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen)
+{
+        struct socket *sock = fd2sock(sockfd);
+
+        if (sock == NULL)
+                return -1;
+        if (!sock->ops->bind(sock, my_addr, addrlen))
+                return 0;
+        else
+                return -1; /* should normally also set errno */
+}
+
+
+static inline int connect(int sockfd, const struct sockaddr *serv_addr, 
+                          socklen_t addrlen)
+{
+        struct socket *sock = fd2sock(sockfd);
+        int flags = 0; /* TODO : what is flags supposed to be? */
+        
+        if (sock == NULL)
+                return -1;
+
+        if (sock->ops->connect(sock, (struct sockaddr *)serv_addr, addrlen, flags) == 0)
+                return 0;
+        else
+                return -1; /* should normally also set errno */
+}
+
+
+static inline int listen(int sockfd, int backlog)
+{
+        struct socket *sock = fd2sock(sockfd);
+        
+        if (sock == NULL)
+                return -1;
+        
+        if (sock->ops->listen(sock, backlog) == 0)
+                return 0;
+        else
+                return -1; /* should normally also set errno */
+}
+
+
+static inline int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
+{
+        struct socket *sock = fd2sock(sockfd);
+        struct socket *newsock;
+        struct sockaddr_in *newaddr = (struct sockaddr_in *)addr; /* check? */
+        int flags = 0; /* Should be ok */
+
+	if (sock == 0) 
+                return -1;
+        
+        newsock = sock_alloc();
+        if (newsock == 0)
+                return -1;
+
+        newsock->type = sock->type;
+        newsock->ops = sock->ops;
+        if (sock->ops->accept(sock, newsock, flags) < 0) 
+        {
+                sock_release(newsock);
+                return -1; /* should normally also set errno */
+        }
+
+        newaddr->sin_family = AF_INET;
+        newaddr->sin_port = newsock->sk->dport;
+        newaddr->sin_addr.s_addr = newsock->sk->daddr;
+
+        *addrlen = sizeof(newaddr);
+
+        return sock2fd(newsock);
+}
+
+
+static inline int shutdown(int sockfd, int how)
+{
+        struct socket *sock = fd2sock(sockfd);
+        
+        if (sock == NULL)
+                return -1;
+
+        if (sock->ops->shutdown(sock, how) == 0)
+                return 0;
+        else
+                return -1; /* should normally also set errno */
+}
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/stat.h linux-2.4.1-korbit/net/korbit/include/sys/stat.h
--- linux-2.4.1/net/korbit/include/sys/stat.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/stat.h	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_SYS_STAT_H__
+#define __KORBIT_SYS_STAT_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/time.h linux-2.4.1-korbit/net/korbit/include/sys/time.h
--- linux-2.4.1/net/korbit/include/sys/time.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/time.h	Thu Feb  1 11:46:55 2001
@@ -0,0 +1,6 @@
+#ifndef __KORBIT_TIME_H__
+#define __KORBIT_TIME_H__
+
+#include <linux/time.h>
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/types.h linux-2.4.1-korbit/net/korbit/include/sys/types.h
--- linux-2.4.1/net/korbit/include/sys/types.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/types.h	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,4 @@
+#ifndef __KORBIT_SYS_TYPES_H__
+#define __KORBIT_SYS_TYPES_H__
+#include <linux/types.h>
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/uio.h linux-2.4.1-korbit/net/korbit/include/sys/uio.h
--- linux-2.4.1/net/korbit/include/sys/uio.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/uio.h	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,4 @@
+#ifndef __KORBIT_SYS_UIO_H__
+#define __KORBIT_SYS_UIO_H__
+#include <linux/uio.h>
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/un.h linux-2.4.1-korbit/net/korbit/include/sys/un.h
--- linux-2.4.1/net/korbit/include/sys/un.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/un.h	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,5 @@
+#ifndef __KORBIT_SYS_UN_H__
+#define __KORBIT_SYS_UN_H__
+#include <linux/socket.h>
+#include <linux/un.h>
+#endif
diff -urN linux-2.4.1/net/korbit/include/sys/wait.h linux-2.4.1-korbit/net/korbit/include/sys/wait.h
--- linux-2.4.1/net/korbit/include/sys/wait.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/sys/wait.h	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,3 @@
+#ifndef __KORBIT_SYS_WAIT_H__
+#define __KORBIT_SYS_WAIT_H__
+#endif
diff -urN linux-2.4.1/net/korbit/include/syslog.h linux-2.4.1-korbit/net/korbit/include/syslog.h
--- linux-2.4.1/net/korbit/include/syslog.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/syslog.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,7 @@
+#ifndef __KORBIT_SYSLOG_H__
+#define __KORBIT_SYSLOG_H__
+
+#define	LOG_NOTICE	5	/* normal but significant condition */
+#define	LOG_INFO	6	/* informational */
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/time.h linux-2.4.1-korbit/net/korbit/include/time.h
--- linux-2.4.1/net/korbit/include/time.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/time.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,4 @@
+#ifndef __KORBIT_TIME_H__
+#define __KORBIT_TIME_H__
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/unistd.h linux-2.4.1-korbit/net/korbit/include/unistd.h
--- linux-2.4.1/net/korbit/include/unistd.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/unistd.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,19 @@
+#ifndef __KORBIT_UNISTD_H__
+#define __KORBIT_UNISTD_H__
+
+#include <linux/types.h>
+#include <linux/utsname.h>
+#include <asm/string.h>
+#include <asm/semaphore.h>
+/* extern char *getcwd(char * buf, size_t size); */
+
+static inline int gethostname(char *name, size_t len) {
+  down_read(&uts_sem);
+  strncpy(name, system_utsname.nodename, len);
+  up_read(&uts_sem);
+printk("gethostname() = %s\n", name);
+  return 0;
+}
+
+
+#endif
diff -urN linux-2.4.1/net/korbit/include/utime.h linux-2.4.1-korbit/net/korbit/include/utime.h
--- linux-2.4.1/net/korbit/include/utime.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/include/utime.h	Thu Feb  1 11:46:54 2001
@@ -0,0 +1,4 @@
+#ifndef __KORBIT_UTIME_H__
+#define __KORBIT_UTIME_H__
+#include <linux/utime.h>
+#endif
diff -urN linux-2.4.1/net/korbit/kglib/CVS/Entries linux-2.4.1-korbit/net/korbit/kglib/CVS/Entries
--- linux-2.4.1/net/korbit/kglib/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/CVS/Entries	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,15 @@
+/Makefile/1.4/Thu Feb  1 09:46:56 2001//
+/garray.c/1.3/Thu Feb  1 09:46:56 2001//
+/ghash.c/1.2/Thu Feb  1 09:46:56 2001//
+/glib.h/1.3/Thu Feb  1 09:46:56 2001//
+/glibconfig.h/1.2/Thu Feb  1 09:46:56 2001//
+/glist.c/1.1.1.1/Thu Feb  1 09:46:57 2001//
+/gmem.c/1.2/Thu Feb  1 09:46:57 2001//
+/gprimes.c/1.1.1.1/Thu Feb  1 09:46:57 2001//
+/gslist.c/1.1.1.1/Thu Feb  1 09:46:57 2001//
+/gstrfuncs.c/1.2/Thu Feb  1 09:46:57 2001//
+/gstring.c/1.1.1.1/Thu Feb  1 09:46:57 2001//
+/gtree.c/1.1.1.1/Thu Feb  1 09:46:57 2001//
+/gutils.c/1.2/Thu Feb  1 09:46:57 2001//
+/korbit_errno.c/1.1/Thu Feb  1 09:46:57 2001//
+D
diff -urN linux-2.4.1/net/korbit/kglib/CVS/Repository linux-2.4.1-korbit/net/korbit/kglib/CVS/Repository
--- linux-2.4.1/net/korbit/kglib/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/CVS/Repository	Thu Feb  1 11:46:56 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/kglib
diff -urN linux-2.4.1/net/korbit/kglib/CVS/Root linux-2.4.1-korbit/net/korbit/kglib/CVS/Root
--- linux-2.4.1/net/korbit/kglib/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/CVS/Root	Thu Feb  1 11:46:56 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/kglib/Makefile linux-2.4.1-korbit/net/korbit/kglib/Makefile
--- linux-2.4.1/net/korbit/kglib/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/Makefile	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,18 @@
+#
+# Makefile for KORBit/kglib
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := kglib.o
+
+#obj-m := $(O_TARGET)
+obj-y := garray.o glist.o gprimes.o gstrfuncs.o gtree.o \
+          ghash.o gmem.o gslist.o gstring.o gutils.o korbit_errno.o
+
+EXTRA_CFLAGS = -D__KORBIT__ -DHAVE_CONFIG_H -DHAVE_UNISTD_H -I. -I.. -I../include -nostdinc
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/kglib/garray.c linux-2.4.1-korbit/net/korbit/kglib/garray.c
--- linux-2.4.1/net/korbit/kglib/garray.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/garray.c	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,431 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <string.h>
+#include "glib.h"
+
+
+#define MIN_ARRAY_SIZE  16
+
+
+typedef struct _GRealArray  GRealArray;
+
+struct _GRealArray
+{
+  guint8 *data;
+  guint   len;
+  guint   alloc;
+  guint   elt_size;
+  guint   zero_terminated : 1;
+  guint   clear : 1;
+};
+
+
+static gint g_nearest_pow        (gint        num);
+static void g_array_maybe_expand (GRealArray *array,
+				  gint        len);
+
+static GMemChunk *array_mem_chunk = NULL;
+G_LOCK_DEFINE_STATIC (array_mem_chunk);
+
+GArray*
+g_array_new (gboolean zero_terminated,
+	     gboolean clear,
+	     guint    elt_size)
+{
+  GRealArray *array;
+
+  G_LOCK (array_mem_chunk);
+  if (!array_mem_chunk)
+    array_mem_chunk = g_mem_chunk_new ("array mem chunk",
+				       sizeof (GRealArray),
+				       1024, G_ALLOC_AND_FREE);
+
+  array = g_chunk_new (GRealArray, array_mem_chunk);
+  G_UNLOCK (array_mem_chunk);
+
+  array->data            = NULL;
+  array->len             = 0;
+  array->alloc           = 0;
+  array->zero_terminated = (zero_terminated ? 1 : 0);
+  array->clear           = (clear ? 1 : 0);
+  array->elt_size        = elt_size;
+
+  return (GArray*) array;
+}
+
+void
+g_array_free (GArray  *array,
+	      gboolean free_segment)
+{
+  if (free_segment)
+    g_free (array->data);
+
+  G_LOCK (array_mem_chunk);
+  g_mem_chunk_free (array_mem_chunk, array);
+  G_UNLOCK (array_mem_chunk);
+}
+
+GArray*
+g_array_append_vals (GArray       *farray,
+		     gconstpointer data,
+		     guint         len)
+{
+  GRealArray *array = (GRealArray*) farray;
+
+  g_array_maybe_expand (array, len);
+
+  memcpy (array->data + array->elt_size * array->len, data, array->elt_size * len);
+
+  array->len += len;
+
+  return farray;
+}
+
+GArray*
+g_array_prepend_vals (GArray        *farray,
+		      gconstpointer  data,
+		      guint          len)
+{
+  GRealArray *array = (GRealArray*) farray;
+
+  g_array_maybe_expand (array, len);
+
+  g_memmove (array->data + array->elt_size * len, array->data, array->elt_size * array->len);
+
+  memcpy (array->data, data, len * array->elt_size);
+
+  array->len += len;
+
+  return farray;
+}
+
+GArray*
+g_array_insert_vals (GArray        *farray,
+		     guint          index,
+		     gconstpointer  data,
+		     guint          len)
+{
+  GRealArray *array = (GRealArray*) farray;
+
+  g_array_maybe_expand (array, len);
+
+  g_memmove (array->data + array->elt_size * (len + index), 
+	     array->data + array->elt_size * index, 
+	     array->elt_size * (array->len - index));
+
+  memcpy (array->data + array->elt_size * index, data, len * array->elt_size);
+
+  array->len += len;
+
+  return farray;
+}
+
+GArray*
+g_array_set_size (GArray *farray,
+		  guint   length)
+{
+  GRealArray *array = (GRealArray*) farray;
+
+  if (array->len < length)
+    g_array_maybe_expand (array, length - array->len);
+
+  array->len = length;
+
+  return farray;
+}
+
+GArray*
+g_array_remove_index (GArray* farray,
+		      guint index)
+{
+  GRealArray* array = (GRealArray*) farray;
+
+  g_return_val_if_fail (array, NULL);
+
+  g_return_val_if_fail (index < array->len, NULL);
+
+  if (index != array->len - 1)
+      g_memmove (array->data + array->elt_size * index, 
+		 array->data + array->elt_size * (index + 1), 
+		 array->elt_size * (array->len - index - 1));
+  
+  if (array->zero_terminated)
+    memset (array->data + array->elt_size * (array->len - 1), 0, 
+	    array->elt_size);
+
+  array->len -= 1;
+
+  return farray;
+}
+
+GArray*
+g_array_remove_index_fast (GArray* farray,
+			   guint index)
+{
+  GRealArray* array = (GRealArray*) farray;
+
+  g_return_val_if_fail (array, NULL);
+
+  g_return_val_if_fail (index < array->len, NULL);
+
+  if (index != array->len - 1)
+    g_memmove (array->data + array->elt_size * index, 
+	       array->data + array->elt_size * (array->len - 1), 
+	       array->elt_size);
+  
+  if (array->zero_terminated)
+    memset (array->data + array->elt_size * (array->len - 1), 0, 
+	    array->elt_size);
+
+  array->len -= 1;
+
+  return farray;
+}
+
+static gint
+g_nearest_pow (gint num)
+{
+  gint n = 1;
+
+  while (n < num)
+    n <<= 1;
+
+  return n;
+}
+
+static void
+g_array_maybe_expand (GRealArray *array,
+		      gint        len)
+{
+  guint want_alloc = (array->len + len + array->zero_terminated) * array->elt_size;
+
+  if (want_alloc > array->alloc)
+    {
+      guint old_alloc = array->alloc;
+
+      array->alloc = g_nearest_pow (want_alloc);
+      array->alloc = MAX (array->alloc, MIN_ARRAY_SIZE);
+
+      array->data = g_realloc (array->data, array->alloc);
+
+      if (array->clear || array->zero_terminated)
+	memset (array->data + old_alloc, 0, array->alloc - old_alloc);
+    }
+}
+
+/* Pointer Array
+ */
+
+typedef struct _GRealPtrArray  GRealPtrArray;
+
+struct _GRealPtrArray
+{
+  gpointer *pdata;
+  guint     len;
+  guint     alloc;
+};
+
+static void g_ptr_array_maybe_expand (GRealPtrArray *array,
+				      gint           len);
+
+static GMemChunk *ptr_array_mem_chunk = NULL;
+G_LOCK_DEFINE_STATIC (ptr_array_mem_chunk);
+
+
+GPtrArray*
+g_ptr_array_new (void)
+{
+  GRealPtrArray *array;
+
+  G_LOCK (ptr_array_mem_chunk);
+  if (!ptr_array_mem_chunk)
+    ptr_array_mem_chunk = g_mem_chunk_new ("array mem chunk",
+					   sizeof (GRealPtrArray),
+					   1024, G_ALLOC_AND_FREE);
+
+  array = g_chunk_new (GRealPtrArray, ptr_array_mem_chunk);
+  G_UNLOCK (ptr_array_mem_chunk);
+
+  array->pdata = NULL;
+  array->len = 0;
+  array->alloc = 0;
+
+  return (GPtrArray*) array;
+}
+
+void
+g_ptr_array_free (GPtrArray   *array,
+		  gboolean  free_segment)
+{
+  g_return_if_fail (array);
+
+  if (free_segment)
+    g_free (array->pdata);
+
+  G_LOCK (ptr_array_mem_chunk);
+  g_mem_chunk_free (ptr_array_mem_chunk, array);
+  G_UNLOCK (ptr_array_mem_chunk);
+}
+
+static void
+g_ptr_array_maybe_expand (GRealPtrArray *array,
+			  gint        len)
+{
+  guint old_alloc;
+
+  if ((array->len + len) > array->alloc)
+    {
+      old_alloc = array->alloc;
+
+      array->alloc = g_nearest_pow (array->len + len);
+      array->alloc = MAX (array->alloc, MIN_ARRAY_SIZE);
+      if (array->pdata)
+	array->pdata = g_realloc (array->pdata, sizeof(gpointer) * array->alloc);
+      else
+	array->pdata = g_new0 (gpointer, array->alloc);
+
+      memset (array->pdata + old_alloc, 0, 
+	      sizeof (gpointer) * (array->alloc - old_alloc));
+    }
+}
+
+void
+g_ptr_array_set_size  (GPtrArray   *farray,
+		       gint	     length)
+{
+  GRealPtrArray* array = (GRealPtrArray*) farray;
+
+  g_return_if_fail (array);
+
+  if (length > array->len)
+    g_ptr_array_maybe_expand (array, (length - array->len));
+
+  array->len = length;
+}
+
+gpointer
+g_ptr_array_remove_index (GPtrArray* farray,
+			  guint index)
+{
+  GRealPtrArray* array = (GRealPtrArray*) farray;
+  gpointer result;
+
+  g_return_val_if_fail (array, NULL);
+
+  g_return_val_if_fail (index < array->len, NULL);
+
+  result = array->pdata[index];
+  
+  if (index != array->len - 1)
+    g_memmove (array->pdata + index, array->pdata + index + 1, 
+	       sizeof (gpointer) * (array->len - index - 1));
+  
+  array->pdata[array->len - 1] = NULL;
+
+  array->len -= 1;
+
+  return result;
+}
+
+gpointer
+g_ptr_array_remove_index_fast (GPtrArray* farray,
+			       guint index)
+{
+  GRealPtrArray* array = (GRealPtrArray*) farray;
+  gpointer result;
+
+  g_return_val_if_fail (array, NULL);
+
+  g_return_val_if_fail (index < array->len, NULL);
+
+  result = array->pdata[index];
+  
+  if (index != array->len - 1)
+    array->pdata[index] = array->pdata[array->len - 1];
+
+  array->pdata[array->len - 1] = NULL;
+
+  array->len -= 1;
+
+  return result;
+}
+
+gboolean
+g_ptr_array_remove (GPtrArray* farray,
+		    gpointer data)
+{
+  GRealPtrArray* array = (GRealPtrArray*) farray;
+  int i;
+
+  g_return_val_if_fail (array, FALSE);
+
+  for (i = 0; i < array->len; i += 1)
+    {
+      if (array->pdata[i] == data)
+	{
+	  g_ptr_array_remove_index (farray, i);
+	  return TRUE;
+	}
+    }
+
+  return FALSE;
+}
+
+gboolean
+g_ptr_array_remove_fast (GPtrArray* farray,
+			 gpointer data)
+{
+  GRealPtrArray* array = (GRealPtrArray*) farray;
+  int i;
+
+  g_return_val_if_fail (array, FALSE);
+
+  for (i = 0; i < array->len; i += 1)
+    {
+      if (array->pdata[i] == data)
+	{
+	  g_ptr_array_remove_index_fast (farray, i);
+	  return TRUE;
+	}
+    }
+
+  return FALSE;
+}
+
+void
+g_ptr_array_add (GPtrArray* farray,
+		 gpointer data)
+{
+  GRealPtrArray* array = (GRealPtrArray*) farray;
+
+  g_return_if_fail (array);
+
+  g_ptr_array_maybe_expand (array, 1);
+
+  array->pdata[array->len++] = data;
+}
+
diff -urN linux-2.4.1/net/korbit/kglib/ghash.c linux-2.4.1-korbit/net/korbit/kglib/ghash.c
--- linux-2.4.1/net/korbit/kglib/ghash.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/ghash.c	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,404 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include "glib.h"
+
+
+#define HASH_TABLE_MIN_SIZE 11
+#define HASH_TABLE_MAX_SIZE 13845163
+
+
+typedef struct _GHashNode      GHashNode;
+
+struct _GHashNode
+{
+  gpointer key;
+  gpointer value;
+  GHashNode *next;
+};
+
+struct _GHashTable
+{
+  gint size;
+  gint nnodes;
+  guint frozen;
+  GHashNode **nodes;
+  GHashFunc hash_func;
+  GCompareFunc key_compare_func;
+};
+
+
+static void		g_hash_table_resize	 (GHashTable	*hash_table);
+static GHashNode**	g_hash_table_lookup_node (GHashTable	*hash_table,
+						  gconstpointer	 key);
+static GHashNode*	g_hash_node_new		 (gpointer	 key,
+						  gpointer	 value);
+static void		g_hash_node_destroy	 (GHashNode	*hash_node);
+static void		g_hash_nodes_destroy	 (GHashNode	*hash_node);
+
+
+G_LOCK_DEFINE_STATIC (g_hash_global);
+
+static GMemChunk *node_mem_chunk = NULL;
+static GHashNode *node_free_list = NULL;
+
+
+GHashTable*
+g_hash_table_new (GHashFunc    hash_func,
+		  GCompareFunc key_compare_func)
+{
+  GHashTable *hash_table;
+  guint i;
+  
+  hash_table = g_new (GHashTable, 1);
+  hash_table->size = HASH_TABLE_MIN_SIZE;
+  hash_table->nnodes = 0;
+  hash_table->frozen = FALSE;
+  hash_table->hash_func = hash_func ? hash_func : g_direct_hash;
+  hash_table->key_compare_func = key_compare_func;
+  hash_table->nodes = g_new (GHashNode*, hash_table->size);
+  
+  for (i = 0; i < hash_table->size; i++)
+    hash_table->nodes[i] = NULL;
+  
+  return hash_table;
+}
+
+void
+g_hash_table_destroy (GHashTable *hash_table)
+{
+  guint i;
+  
+  g_return_if_fail (hash_table != NULL);
+  
+  for (i = 0; i < hash_table->size; i++)
+    g_hash_nodes_destroy (hash_table->nodes[i]);
+  
+  g_free (hash_table->nodes);
+  g_free (hash_table);
+}
+
+static inline GHashNode**
+g_hash_table_lookup_node (GHashTable	*hash_table,
+			  gconstpointer	 key)
+{
+  GHashNode **node;
+  
+  node = &hash_table->nodes
+    [(* hash_table->hash_func) (key) % hash_table->size];
+  
+  /* Hash table lookup needs to be fast.
+   *  We therefore remove the extra conditional of testing
+   *  whether to call the key_compare_func or not from
+   *  the inner loop.
+   */
+  if (hash_table->key_compare_func)
+    while (*node && !(*hash_table->key_compare_func) ((*node)->key, key))
+      node = &(*node)->next;
+  else
+    while (*node && (*node)->key != key)
+      node = &(*node)->next;
+  
+  return node;
+}
+
+gpointer
+g_hash_table_lookup (GHashTable	  *hash_table,
+		     gconstpointer key)
+{
+  GHashNode *node;
+  
+  g_return_val_if_fail (hash_table != NULL, NULL);
+  
+  node = *g_hash_table_lookup_node (hash_table, key);
+  
+  return node ? node->value : NULL;
+}
+
+void
+g_hash_table_insert (GHashTable *hash_table,
+		     gpointer	 key,
+		     gpointer	 value)
+{
+  GHashNode **node;
+  
+  g_return_if_fail (hash_table != NULL);
+  
+  node = g_hash_table_lookup_node (hash_table, key);
+  
+  if (*node)
+    {
+      /* do not reset node->key in this place, keeping
+       * the old key might be intended.
+       * a g_hash_table_remove/g_hash_table_insert pair
+       * can be used otherwise.
+       *
+       * node->key = key; */
+      (*node)->value = value;
+    }
+  else
+    {
+      *node = g_hash_node_new (key, value);
+      hash_table->nnodes++;
+      if (!hash_table->frozen)
+	g_hash_table_resize (hash_table);
+    }
+}
+
+void
+g_hash_table_remove (GHashTable	     *hash_table,
+		     gconstpointer    key)
+{
+  GHashNode **node, *dest;
+  
+  g_return_if_fail (hash_table != NULL);
+  
+  node = g_hash_table_lookup_node (hash_table, key);
+
+  if (*node)
+    {
+      dest = *node;
+      (*node) = dest->next;
+      g_hash_node_destroy (dest);
+      hash_table->nnodes--;
+  
+      if (!hash_table->frozen)
+        g_hash_table_resize (hash_table);
+    }
+}
+
+gboolean
+g_hash_table_lookup_extended (GHashTable	*hash_table,
+			      gconstpointer	 lookup_key,
+			      gpointer		*orig_key,
+			      gpointer		*value)
+{
+  GHashNode *node;
+  
+  g_return_val_if_fail (hash_table != NULL, FALSE);
+  
+  node = *g_hash_table_lookup_node (hash_table, lookup_key);
+  
+  if (node)
+    {
+      if (orig_key)
+	*orig_key = node->key;
+      if (value)
+	*value = node->value;
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+void
+g_hash_table_freeze (GHashTable *hash_table)
+{
+  g_return_if_fail (hash_table != NULL);
+  
+  hash_table->frozen++;
+}
+
+void
+g_hash_table_thaw (GHashTable *hash_table)
+{
+  g_return_if_fail (hash_table != NULL);
+  
+  if (hash_table->frozen)
+    if (!(--hash_table->frozen))
+      g_hash_table_resize (hash_table);
+}
+
+guint
+g_hash_table_foreach_remove (GHashTable	*hash_table,
+			     GHRFunc	 func,
+			     gpointer	 user_data)
+{
+  GHashNode *node, *prev;
+  guint i;
+  guint deleted = 0;
+  
+  g_return_val_if_fail (hash_table != NULL, 0);
+  g_return_val_if_fail (func != NULL, 0);
+  
+  for (i = 0; i < hash_table->size; i++)
+    {
+    restart:
+      
+      prev = NULL;
+      
+      for (node = hash_table->nodes[i]; node; prev = node, node = node->next)
+	{
+	  if ((* func) (node->key, node->value, user_data))
+	    {
+	      deleted += 1;
+	      
+	      hash_table->nnodes -= 1;
+	      
+	      if (prev)
+		{
+		  prev->next = node->next;
+		  g_hash_node_destroy (node);
+		  node = prev;
+		}
+	      else
+		{
+		  hash_table->nodes[i] = node->next;
+		  g_hash_node_destroy (node);
+		  goto restart;
+		}
+	    }
+	}
+    }
+  
+  if (!hash_table->frozen)
+    g_hash_table_resize (hash_table);
+  
+  return deleted;
+}
+
+void
+g_hash_table_foreach (GHashTable *hash_table,
+		      GHFunc	  func,
+		      gpointer	  user_data)
+{
+  GHashNode *node;
+  gint i;
+  
+  g_return_if_fail (hash_table != NULL);
+  g_return_if_fail (func != NULL);
+  
+  for (i = 0; i < hash_table->size; i++)
+    for (node = hash_table->nodes[i]; node; node = node->next)
+      (* func) (node->key, node->value, user_data);
+}
+
+/* Returns the number of elements contained in the hash table. */
+guint
+g_hash_table_size (GHashTable *hash_table)
+{
+  g_return_val_if_fail (hash_table != NULL, 0);
+  
+  return hash_table->nnodes;
+}
+
+static void
+g_hash_table_resize (GHashTable *hash_table)
+{
+  GHashNode **new_nodes;
+  GHashNode *node;
+  GHashNode *next;
+#ifdef __KORBIT__
+  guint nodes_per_list;
+#else
+  gfloat nodes_per_list;
+#endif
+  guint hash_val;
+  gint new_size;
+  gint i;
+  
+  nodes_per_list = (hash_table->nnodes * 10) / hash_table->size;
+  
+  if ((nodes_per_list > 3 || hash_table->size <= HASH_TABLE_MIN_SIZE) &&
+      (nodes_per_list < 30 || hash_table->size >= HASH_TABLE_MAX_SIZE))
+    return;
+  
+  new_size = CLAMP(g_spaced_primes_closest (hash_table->nnodes),
+		   HASH_TABLE_MIN_SIZE,
+		   HASH_TABLE_MAX_SIZE);
+  new_nodes = g_new0 (GHashNode*, new_size);
+  
+  for (i = 0; i < hash_table->size; i++)
+    for (node = hash_table->nodes[i]; node; node = next)
+      {
+	next = node->next;
+
+	hash_val = (* hash_table->hash_func) (node->key) % new_size;
+
+	node->next = new_nodes[hash_val];
+	new_nodes[hash_val] = node;
+      }
+  
+  g_free (hash_table->nodes);
+  hash_table->nodes = new_nodes;
+  hash_table->size = new_size;
+}
+
+static GHashNode*
+g_hash_node_new (gpointer key,
+		 gpointer value)
+{
+  GHashNode *hash_node;
+  
+  G_LOCK (g_hash_global);
+  if (node_free_list)
+    {
+      hash_node = node_free_list;
+      node_free_list = node_free_list->next;
+    }
+  else
+    {
+      if (!node_mem_chunk)
+	node_mem_chunk = g_mem_chunk_new ("hash node mem chunk",
+					  sizeof (GHashNode),
+					  1024, G_ALLOC_ONLY);
+      
+      hash_node = g_chunk_new (GHashNode, node_mem_chunk);
+    }
+  G_UNLOCK (g_hash_global);
+  
+  hash_node->key = key;
+  hash_node->value = value;
+  hash_node->next = NULL;
+  
+  return hash_node;
+}
+
+static void
+g_hash_node_destroy (GHashNode *hash_node)
+{
+  G_LOCK (g_hash_global);
+  hash_node->next = node_free_list;
+  node_free_list = hash_node;
+  G_UNLOCK (g_hash_global);
+}
+
+static void
+g_hash_nodes_destroy (GHashNode *hash_node)
+{
+  if (hash_node)
+    {
+      GHashNode *node = hash_node;
+  
+      while (node->next)
+        node = node->next;
+  
+      G_LOCK (g_hash_global);
+      node->next = node_free_list;
+      node_free_list = hash_node;
+      G_UNLOCK (g_hash_global);
+    }
+}
diff -urN linux-2.4.1/net/korbit/kglib/glib.h linux-2.4.1-korbit/net/korbit/kglib/glib.h
--- linux-2.4.1/net/korbit/kglib/glib.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/glib.h	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,1671 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_LIB_H__
+#define __G_LIB_H__
+
+#ifdef __KORBIT__
+#define G_DISABLE_ASSERT 1
+#include <stdio.h>
+#endif
+
+#include "config.h"
+
+/* system specific config file glibconfig.h provides definitions for
+ * the extrema of many of the standard types. These are:
+ *
+ *  G_MINSHORT, G_MAXSHORT
+ *  G_MININT, G_MAXINT
+ *  G_MINLONG, G_MAXLONG
+ *  G_MINFLOAT, G_MAXFLOAT
+ *  G_MINDOUBLE, G_MAXDOUBLE
+ *
+ * It also provides the following typedefs:
+ *
+ *  gint8, guint8
+ *  gint16, guint16
+ *  gint32, guint32
+ *  gint64, guint64
+ *
+ * It defines the G_BYTE_ORDER symbol to one of G_*_ENDIAN (see later in
+ * this file). 
+ *
+ * And it provides a way to store and retrieve a `gint' in/from a `gpointer'.
+ * This is useful to pass an integer instead of a pointer to a callback.
+ *
+ *  GINT_TO_POINTER(i), GUINT_TO_POINTER(i)
+ *  GPOINTER_TO_INT(p), GPOINTER_TO_UINT(p)
+ *
+ * Finally, it provide the following wrappers to STDC functions:
+ *
+ *  g_ATEXIT
+ *    To register hooks which are executed on exit().
+ *    Usually a wrapper for STDC atexit.
+ *
+ *  void *g_memmove(void *dest, const void *src, guint count);
+ *    A wrapper for STDC memmove, or an implementation, if memmove doesn't
+ *    exist.  The prototype looks like the above, give or take a const,
+ *    or size_t.
+ */
+#include <glibconfig.h>
+
+/* include varargs functions for assertment macros
+ */
+#include <stdarg.h>
+
+#define G_DIR_SEPARATOR '/'
+#define G_DIR_SEPARATOR_S "/"
+#define G_SEARCHPATH_SEPARATOR ':'
+#define G_SEARCHPATH_SEPARATOR_S ":"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Provide definitions for some commonly used macros.
+ *  Some of them are only provided if they haven't already
+ *  been defined. It is assumed that if they are already
+ *  defined then the current definition is correct.
+ */
+#ifndef	NULL
+#define	NULL	((void*) 0)
+#endif
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+#undef	MAX
+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
+
+#undef	MIN
+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
+
+#undef	ABS
+#define ABS(a)	   (((a) < 0) ? -(a) : (a))
+
+#undef	CLAMP
+#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
+
+
+/* Define G_VA_COPY() to do the right thing for copying va_list variables.
+ * glibconfig.h may have already defined G_VA_COPY as va_copy or __va_copy.
+ */
+#if !defined (G_VA_COPY)
+#  if defined (__GNUC__) && defined (__PPC__) && (defined (_CALL_SYSV) || defined (_WIN32))
+#  define G_VA_COPY(ap1, ap2)	  (*(ap1) = *(ap2))
+#  elif defined (G_VA_COPY_AS_ARRAY)
+#  define G_VA_COPY(ap1, ap2)	  g_memmove ((ap1), (ap2), sizeof (va_list))
+#  else /* va_list is a pointer */
+#  define G_VA_COPY(ap1, ap2)	  ((ap1) = (ap2))
+#  endif /* va_list is a pointer */
+#endif /* !G_VA_COPY */
+
+
+/* Provide convenience macros for handling structure
+ * fields through their offsets.
+ */
+#define G_STRUCT_OFFSET(struct_type, member)	\
+    ((gulong) ((gchar*) &((struct_type*) 0)->member))
+#define G_STRUCT_MEMBER_P(struct_p, struct_offset)   \
+    ((gpointer) ((gchar*) (struct_p) + (gulong) (struct_offset)))
+#define G_STRUCT_MEMBER(member_type, struct_p, struct_offset)   \
+    (*(member_type*) G_STRUCT_MEMBER_P ((struct_p), (struct_offset)))
+
+
+/* inlining hassle. for compilers that don't allow the `inline' keyword,
+ * mostly because of strict ANSI C compliance or dumbness, we try to fall
+ * back to either `__inline__' or `__inline'.
+ * we define G_CAN_INLINE, if the compiler seems to be actually
+ * *capable* to do function inlining, in which case inline function bodys
+ * do make sense. we also define G_INLINE_FUNC to properly export the
+ * function prototypes if no inlining can be performed.
+ * we special case most of the stuff, so inline functions can have a normal
+ * implementation by defining G_INLINE_FUNC to extern and G_CAN_INLINE to 1.
+ */
+#ifndef G_INLINE_FUNC
+#  define G_CAN_INLINE 1
+#endif
+#ifdef G_HAVE_INLINE
+#  if defined (__GNUC__) && defined (__STRICT_ANSI__)
+#    undef inline
+#    define inline __inline__
+#  endif
+#else /* !G_HAVE_INLINE */
+#  undef inline
+#  if defined (G_HAVE___INLINE__)
+#    define inline __inline__
+#  else /* !inline && !__inline__ */
+#    if defined (G_HAVE___INLINE)
+#      define inline __inline
+#    else /* !inline && !__inline__ && !__inline */
+#      define inline /* don't inline, then */
+#      ifndef G_INLINE_FUNC
+#	 undef G_CAN_INLINE
+#      endif
+#    endif
+#  endif
+#endif
+#ifndef G_INLINE_FUNC
+#  ifdef __GNUC__
+#    ifdef __OPTIMIZE__
+#      define G_INLINE_FUNC extern inline
+#    else
+#      undef G_CAN_INLINE
+#      define G_INLINE_FUNC extern
+#    endif
+#  else /* !__GNUC__ */
+#    ifdef G_CAN_INLINE
+#      define G_INLINE_FUNC static inline
+#    else
+#      define G_INLINE_FUNC extern
+#    endif
+#  endif /* !__GNUC__ */
+#endif /* !G_INLINE_FUNC */
+
+
+/* Provide simple macro statement wrappers (adapted from Perl):
+ *  G_STMT_START { statements; } G_STMT_END;
+ *  can be used as a single statement, as in
+ *  if (x) G_STMT_START { ... } G_STMT_END; else ...
+ *
+ *  For gcc we will wrap the statements within `({' and `})' braces.
+ *  For SunOS they will be wrapped within `if (1)' and `else (void) 0',
+ *  and otherwise within `do' and `while (0)'.
+ */
+#if !(defined (G_STMT_START) && defined (G_STMT_END))
+#  if defined (__GNUC__) && !defined (__STRICT_ANSI__) && !defined (__cplusplus)
+#    define G_STMT_START	(void)(
+#    define G_STMT_END		)
+#  else
+#    if (defined (sun) || defined (__sun__))
+#      define G_STMT_START	if (1)
+#      define G_STMT_END	else (void)0
+#    else
+#      define G_STMT_START	do
+#      define G_STMT_END	while (0)
+#    endif
+#  endif
+#endif
+
+
+/* Provide macros to feature the GCC function attribute.
+ */
+#if	__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define G_GNUC_PRINTF( format_idx, arg_idx )	\
+  __attribute__((format (printf, format_idx, arg_idx)))
+#define G_GNUC_SCANF( format_idx, arg_idx )	\
+  __attribute__((format (scanf, format_idx, arg_idx)))
+#define G_GNUC_FORMAT( arg_idx )		\
+  __attribute__((format_arg (arg_idx)))
+#define G_GNUC_NORETURN				\
+  __attribute__((noreturn))
+#define G_GNUC_CONST				\
+  __attribute__((const))
+#define G_GNUC_UNUSED				\
+  __attribute__((unused))
+#else	/* !__GNUC__ */
+#define G_GNUC_PRINTF( format_idx, arg_idx )
+#define G_GNUC_SCANF( format_idx, arg_idx )
+#define G_GNUC_FORMAT( arg_idx )
+#define G_GNUC_NORETURN
+#define G_GNUC_CONST
+#define	G_GNUC_UNUSED
+#endif	/* !__GNUC__ */
+
+
+/* Wrap the gcc __PRETTY_FUNCTION__ and __FUNCTION__ variables with
+ * macros, so we can refer to them as strings unconditionally.
+ */
+#ifdef	__GNUC__
+#define	G_GNUC_FUNCTION		__FUNCTION__
+#define	G_GNUC_PRETTY_FUNCTION	__PRETTY_FUNCTION__
+#else	/* !__GNUC__ */
+#define	G_GNUC_FUNCTION		""
+#define	G_GNUC_PRETTY_FUNCTION	""
+#endif	/* !__GNUC__ */
+
+/* we try to provide a usefull equivalent for ATEXIT if it is
+ * not defined, but use is actually abandoned. people should
+ * use g_atexit() instead.
+ */
+#ifndef ATEXIT
+# define ATEXIT(proc)	g_ATEXIT(proc)
+#else
+# define G_NATIVE_ATEXIT
+#endif /* ATEXIT */
+
+/* Hacker macro to place breakpoints for elected machines.
+ * Actual use is strongly deprecated of course ;)
+ */
+#if defined (__i386__) && defined (__GNUC__) && __GNUC__ >= 2
+#define	G_BREAKPOINT()		G_STMT_START{ __asm__ __volatile__ ("int $03"); }G_STMT_END
+#elif defined (__alpha__) && defined (__GNUC__) && __GNUC__ >= 2
+#define	G_BREAKPOINT()		G_STMT_START{ __asm__ __volatile__ ("bpt"); }G_STMT_END
+#else	/* !__i386__ && !__alpha__ */
+#define	G_BREAKPOINT()
+#endif	/* __i386__ */
+
+
+/* Provide macros for easily allocating memory. The macros
+ *  will cast the allocated memory to the specified type
+ *  in order to avoid compiler warnings. (Makes the code neater).
+ */
+
+#ifdef __DMALLOC_H__
+#  define g_new(type, count)		(ALLOC (type, count))
+#  define g_new0(type, count)		(CALLOC (type, count))
+#  define g_renew(type, mem, count)	(REALLOC (mem, type, count))
+#else /* __DMALLOC_H__ */
+#  define g_new(type, count)	  \
+      ((type *) g_malloc ((unsigned) sizeof (type) * (count)))
+#  define g_new0(type, count)	  \
+      ((type *) g_malloc0 ((unsigned) sizeof (type) * (count)))
+#  define g_renew(type, mem, count)	  \
+      ((type *) g_realloc (mem, (unsigned) sizeof (type) * (count)))
+#endif /* __DMALLOC_H__ */
+
+#define g_mem_chunk_create(type, pre_alloc, alloc_type)	( \
+  g_mem_chunk_new (#type " mem chunks (" #pre_alloc ")", \
+		   sizeof (type), \
+		   sizeof (type) * (pre_alloc), \
+		   (alloc_type)) \
+)
+#define g_chunk_new(type, chunk)	( \
+  (type *) g_mem_chunk_alloc (chunk) \
+)
+#define g_chunk_new0(type, chunk)	( \
+  (type *) g_mem_chunk_alloc0 (chunk) \
+)
+#define g_chunk_free(mem, mem_chunk)	G_STMT_START { \
+  g_mem_chunk_free ((mem_chunk), (mem)); \
+} G_STMT_END
+
+
+#define g_string(x) #x
+
+
+/* Provide macros for error handling. The "assert" macros will
+ *  exit on failure. The "return" macros will exit the current
+ *  function. Two different definitions are given for the macros
+ *  if G_DISABLE_ASSERT is not defined, in order to support gcc's
+ *  __PRETTY_FUNCTION__ capability.
+ */
+
+#ifdef G_DISABLE_ASSERT
+
+#define g_assert(expr)
+#define g_assert_not_reached()
+
+#else /* !G_DISABLE_ASSERT */
+
+#ifdef __GNUC__
+
+#define g_assert(expr)			G_STMT_START{		\
+     if (!(expr))						\
+       g_log (G_LOG_DOMAIN,					\
+	      G_LOG_LEVEL_ERROR,				\
+	      "file %s: line %d (%s): assertion failed: (%s)",	\
+	      __FILE__,						\
+	      __LINE__,						\
+	      __PRETTY_FUNCTION__,				\
+	      #expr);			}G_STMT_END
+
+#define g_assert_not_reached()		G_STMT_START{		\
+     g_log (G_LOG_DOMAIN,					\
+	    G_LOG_LEVEL_ERROR,					\
+	    "file %s: line %d (%s): should not be reached",	\
+	    __FILE__,						\
+	    __LINE__,						\
+	    __PRETTY_FUNCTION__);	}G_STMT_END
+
+#else /* !__GNUC__ */
+
+#define g_assert(expr)			G_STMT_START{		\
+     if (!(expr))						\
+       g_log (G_LOG_DOMAIN,					\
+	      G_LOG_LEVEL_ERROR,				\
+	      "file %s: line %d: assertion failed: (%s)",	\
+	      __FILE__,						\
+	      __LINE__,						\
+	      #expr);			}G_STMT_END
+
+#define g_assert_not_reached()		G_STMT_START{	\
+     g_log (G_LOG_DOMAIN,				\
+	    G_LOG_LEVEL_ERROR,				\
+	    "file %s: line %d: should not be reached",	\
+	    __FILE__,					\
+	    __LINE__);		}G_STMT_END
+
+#endif /* __GNUC__ */
+
+#endif /* !G_DISABLE_ASSERT */
+
+
+#ifdef __KORBIT__
+
+#define g_return_if_fail(expr)		G_STMT_START{			\
+     if (!(expr))							\
+       {								\
+	 return;							\
+       };				}G_STMT_END
+
+#define g_return_val_if_fail(expr,val)	G_STMT_START{			\
+     if (!(expr))							\
+       {								\
+	 return val;							\
+       };				}G_STMT_END
+
+#else /* !__KORBIT__ */
+
+#ifdef G_DISABLE_CHECKS
+
+#define g_return_if_fail(expr)
+#define g_return_val_if_fail(expr,val)
+
+#else /* !G_DISABLE_CHECKS */
+
+#ifdef __GNUC__
+
+#define g_return_if_fail(expr)		G_STMT_START{			\
+     if (!(expr))							\
+       {								\
+	 g_log (G_LOG_DOMAIN,						\
+		G_LOG_LEVEL_CRITICAL,					\
+		"file %s: line %d (%s): assertion `%s' failed.",	\
+		__FILE__,						\
+		__LINE__,						\
+		__PRETTY_FUNCTION__,					\
+		#expr);							\
+	 return;							\
+       };				}G_STMT_END
+
+#define g_return_val_if_fail(expr,val)	G_STMT_START{			\
+     if (!(expr))							\
+       {								\
+	 g_log (G_LOG_DOMAIN,						\
+		G_LOG_LEVEL_CRITICAL,					\
+		"file %s: line %d (%s): assertion `%s' failed.",	\
+		__FILE__,						\
+		__LINE__,						\
+		__PRETTY_FUNCTION__,					\
+		#expr);							\
+	 return val;							\
+       };				}G_STMT_END
+
+#else /* !__GNUC__ */
+
+#define g_return_if_fail(expr)		G_STMT_START{		\
+     if (!(expr))						\
+       {							\
+	 g_log (G_LOG_DOMAIN,					\
+		G_LOG_LEVEL_CRITICAL,				\
+		"file %s: line %d: assertion `%s' failed.",	\
+		__FILE__,					\
+		__LINE__,					\
+		#expr);						\
+	 return;						\
+       };				}G_STMT_END
+
+#define g_return_val_if_fail(expr, val)	G_STMT_START{		\
+     if (!(expr))						\
+       {							\
+	 g_log (G_LOG_DOMAIN,					\
+		G_LOG_LEVEL_CRITICAL,				\
+		"file %s: line %d: assertion `%s' failed.",	\
+		__FILE__,					\
+		__LINE__,					\
+		#expr);						\
+	 return val;						\
+       };				}G_STMT_END
+
+#endif /* !__GNUC__ */
+
+#endif /* !G_DISABLE_CHECKS */
+
+#endif /* !__KORBIT__ */
+
+
+/* Provide type definitions for commonly used types.
+ *  These are useful because a "gint8" can be adjusted
+ *  to be 1 byte (8 bits) on all platforms. Similarly and
+ *  more importantly, "gint32" can be adjusted to be
+ *  4 bytes (32 bits) on all platforms.
+ */
+
+typedef char   gchar;
+typedef short  gshort;
+typedef long   glong;
+typedef int    gint;
+typedef gint   gboolean;
+
+typedef unsigned char	guchar;
+typedef unsigned short	gushort;
+typedef unsigned long	gulong;
+typedef unsigned int	guint;
+
+typedef float	gfloat;
+typedef double	gdouble;
+
+/* HAVE_LONG_DOUBLE doesn't work correctly on all platforms.
+ * Since gldouble isn't used anywhere, just disable it for now */
+
+#if 0
+#ifdef HAVE_LONG_DOUBLE
+typedef long double gldouble;
+#else /* HAVE_LONG_DOUBLE */
+typedef double gldouble;
+#endif /* HAVE_LONG_DOUBLE */
+#endif /* 0 */
+
+typedef void* gpointer;
+typedef const void *gconstpointer;
+
+
+typedef gint32	gssize;
+typedef guint32 gsize;
+typedef guint32 GQuark;
+typedef gint32	GTime;
+
+
+/* Portable endian checks and conversions
+ *
+ * glibconfig.h defines G_BYTE_ORDER which expands to one of
+ * the below macros.
+ */
+#define G_LITTLE_ENDIAN 1234
+#define G_BIG_ENDIAN    4321
+#define G_PDP_ENDIAN    3412		/* unused, need specific PDP check */	
+
+
+/* Basic bit swapping functions
+ */
+#define GUINT16_SWAP_LE_BE_CONSTANT(val)	((guint16) ( \
+    (((guint16) (val) & (guint16) 0x00ffU) << 8) | \
+    (((guint16) (val) & (guint16) 0xff00U) >> 8)))
+#define GUINT32_SWAP_LE_BE_CONSTANT(val)	((guint32) ( \
+    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
+    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
+    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
+    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))
+
+/* Intel specific stuff for speed
+ */
+#if defined (__i386__) && defined (__GNUC__) && __GNUC__ >= 2
+#  define GUINT16_SWAP_LE_BE_X86(val) \
+     (__extension__					\
+      ({ register guint16 __v;				\
+	 if (__builtin_constant_p (val))		\
+	   __v = GUINT16_SWAP_LE_BE_CONSTANT (val);	\
+	 else						\
+	   __asm__ __const__ ("rorw $8, %w0"		\
+			      : "=r" (__v)		\
+			      : "0" ((guint16) (val)));	\
+	__v; }))
+#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_X86 (val))
+#  if !defined(__i486__) && !defined(__i586__) \
+      && !defined(__pentium__) && !defined(__i686__) && !defined(__pentiumpro__)
+#     define GUINT32_SWAP_LE_BE_X86(val) \
+        (__extension__						\
+         ({ register guint32 __v;				\
+	    if (__builtin_constant_p (val))			\
+	      __v = GUINT32_SWAP_LE_BE_CONSTANT (val);		\
+	  else							\
+	    __asm__ __const__ ("rorw $8, %w0\n\t"		\
+			       "rorl $16, %0\n\t"		\
+			       "rorw $8, %w0"			\
+			       : "=r" (__v)			\
+			       : "0" ((guint32) (val)));	\
+	__v; }))
+#  else /* 486 and higher has bswap */
+#     define GUINT32_SWAP_LE_BE_X86(val) \
+        (__extension__						\
+         ({ register guint32 __v;				\
+	    if (__builtin_constant_p (val))			\
+	      __v = GUINT32_SWAP_LE_BE_CONSTANT (val);		\
+	  else							\
+	    __asm__ __const__ ("bswap %0"			\
+			       : "=r" (__v)			\
+			       : "0" ((guint32) (val)));	\
+	__v; }))
+#  endif /* processor specific 32-bit stuff */
+#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_X86 (val))
+#else /* !__i386__ */
+#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
+#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))
+#endif /* __i386__ */
+
+#ifdef G_HAVE_GINT64
+#  define GUINT64_SWAP_LE_BE_CONSTANT(val)	((guint64) ( \
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x00000000000000ffU)) << 56) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x000000000000ff00U)) << 40) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x0000000000ff0000U)) << 24) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x00000000ff000000U)) <<  8) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x000000ff00000000U)) >>  8) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x0000ff0000000000U)) >> 24) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0x00ff000000000000U)) >> 40) |	\
+      (((guint64) (val) &						\
+	(guint64) G_GINT64_CONSTANT(0xff00000000000000U)) >> 56)))
+#  if defined (__i386__) && defined (__GNUC__) && __GNUC__ >= 2
+#    define GUINT64_SWAP_LE_BE_X86(val) \
+	(__extension__						\
+	 ({ union { guint64 __ll;				\
+		    guint32 __l[2]; } __r;			\
+	    if (__builtin_constant_p (val))			\
+	      __r.__ll = GUINT64_SWAP_LE_BE_CONSTANT (val);	\
+	    else						\
+	      {							\
+	 	union { guint64 __ll;				\
+			guint32 __l[2]; } __w;			\
+		__w.__ll = ((guint64) val);			\
+		__r.__l[0] = GUINT32_SWAP_LE_BE (__w.__l[1]);	\
+		__r.__l[1] = GUINT32_SWAP_LE_BE (__w.__l[0]);	\
+	      }							\
+	  __r.__ll; }))
+#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_X86 (val))
+#  else /* !__i386__ */
+#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT(val))
+#  endif
+#endif
+
+#define GUINT16_SWAP_LE_PDP(val)	((guint16) (val))
+#define GUINT16_SWAP_BE_PDP(val)	(GUINT16_SWAP_LE_BE (val))
+#define GUINT32_SWAP_LE_PDP(val)	((guint32) ( \
+    (((guint32) (val) & (guint32) 0x0000ffffU) << 16) | \
+    (((guint32) (val) & (guint32) 0xffff0000U) >> 16)))
+#define GUINT32_SWAP_BE_PDP(val)	((guint32) ( \
+    (((guint32) (val) & (guint32) 0x00ff00ffU) << 8) | \
+    (((guint32) (val) & (guint32) 0xff00ff00U) >> 8)))
+
+/* The G*_TO_?E() macros are defined in glibconfig.h.
+ * The transformation is symmetric, so the FROM just maps to the TO.
+ */
+#define GINT16_FROM_LE(val)	(GINT16_TO_LE (val))
+#define GUINT16_FROM_LE(val)	(GUINT16_TO_LE (val))
+#define GINT16_FROM_BE(val)	(GINT16_TO_BE (val))
+#define GUINT16_FROM_BE(val)	(GUINT16_TO_BE (val))
+#define GINT32_FROM_LE(val)	(GINT32_TO_LE (val))
+#define GUINT32_FROM_LE(val)	(GUINT32_TO_LE (val))
+#define GINT32_FROM_BE(val)	(GINT32_TO_BE (val))
+#define GUINT32_FROM_BE(val)	(GUINT32_TO_BE (val))
+
+#ifdef G_HAVE_GINT64
+#define GINT64_FROM_LE(val)	(GINT64_TO_LE (val))
+#define GUINT64_FROM_LE(val)	(GUINT64_TO_LE (val))
+#define GINT64_FROM_BE(val)	(GINT64_TO_BE (val))
+#define GUINT64_FROM_BE(val)	(GUINT64_TO_BE (val))
+#endif
+
+#define GLONG_FROM_LE(val)	(GLONG_TO_LE (val))
+#define GULONG_FROM_LE(val)	(GULONG_TO_LE (val))
+#define GLONG_FROM_BE(val)	(GLONG_TO_BE (val))
+#define GULONG_FROM_BE(val)	(GULONG_TO_BE (val))
+
+#define GINT_FROM_LE(val)	(GINT_TO_LE (val))
+#define GUINT_FROM_LE(val)	(GUINT_TO_LE (val))
+#define GINT_FROM_BE(val)	(GINT_TO_BE (val))
+#define GUINT_FROM_BE(val)	(GUINT_TO_BE (val))
+
+
+/* Portable versions of host-network order stuff
+ */
+#define g_ntohl(val) (GUINT32_FROM_BE (val))
+#define g_ntohs(val) (GUINT16_FROM_BE (val))
+#define g_htonl(val) (GUINT32_TO_BE (val))
+#define g_htons(val) (GUINT16_TO_BE (val))
+
+
+/* Glib version.
+ * we prefix variable declarations so they can
+ * properly get exported in windows dlls.
+ */
+#define GUTILS_C_VAR extern
+
+
+GUTILS_C_VAR const guint glib_major_version;
+GUTILS_C_VAR const guint glib_minor_version;
+GUTILS_C_VAR const guint glib_micro_version;
+GUTILS_C_VAR const guint glib_interface_age;
+GUTILS_C_VAR const guint glib_binary_age;
+
+#define GLIB_CHECK_VERSION(major,minor,micro)    \
+    (GLIB_MAJOR_VERSION > (major) || \
+     (GLIB_MAJOR_VERSION == (major) && GLIB_MINOR_VERSION > (minor)) || \
+     (GLIB_MAJOR_VERSION == (major) && GLIB_MINOR_VERSION == (minor) && \
+      GLIB_MICRO_VERSION >= (micro)))
+
+/* Forward declarations of glib types.
+ */
+typedef struct _GAllocator	GAllocator;
+typedef struct _GArray		GArray;
+typedef struct _GByteArray	GByteArray;
+typedef struct _GDebugKey	GDebugKey;
+typedef struct _GHashTable	GHashTable;
+typedef struct _GList		GList;
+typedef struct _GMemChunk	GMemChunk;
+typedef struct _GNode		GNode;
+typedef struct _GPtrArray	GPtrArray;
+typedef struct _GSList		GSList;
+typedef struct _GString		GString;
+typedef struct _GStringChunk	GStringChunk;
+typedef struct _GTree		GTree;
+typedef struct _GTuples		GTuples;
+
+/* Tree traverse flags */
+typedef enum
+{
+  G_TRAVERSE_LEAFS	= 1 << 0,
+  G_TRAVERSE_NON_LEAFS	= 1 << 1,
+  G_TRAVERSE_ALL	= G_TRAVERSE_LEAFS | G_TRAVERSE_NON_LEAFS,
+  G_TRAVERSE_MASK	= 0x03
+} GTraverseFlags;
+
+/* Tree traverse orders */
+typedef enum
+{
+  G_IN_ORDER,
+  G_PRE_ORDER,
+  G_POST_ORDER,
+  G_LEVEL_ORDER
+} GTraverseType;
+
+/* Log level shift offset for user defined
+ * log levels (0-7 are used by GLib).
+ */
+#define	G_LOG_LEVEL_USER_SHIFT	(8)
+
+/* Glib log levels and flags.
+ */
+typedef enum
+{
+  /* log flags */
+  G_LOG_FLAG_RECURSION		= 1 << 0,
+  G_LOG_FLAG_FATAL		= 1 << 1,
+  
+  /* GLib log levels */
+  G_LOG_LEVEL_ERROR		= 1 << 2,	/* always fatal */
+  G_LOG_LEVEL_CRITICAL		= 1 << 3,
+  G_LOG_LEVEL_WARNING		= 1 << 4,
+  G_LOG_LEVEL_MESSAGE		= 1 << 5,
+  G_LOG_LEVEL_INFO		= 1 << 6,
+  G_LOG_LEVEL_DEBUG		= 1 << 7,
+  
+  G_LOG_LEVEL_MASK		= ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
+} GLogLevelFlags;
+
+/* GLib log levels that are considered fatal by default */
+#define	G_LOG_FATAL_MASK	(G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR)
+
+
+typedef gint		(*GCompareFunc)		(gconstpointer	a,
+						 gconstpointer	b);
+typedef gchar*		(*GCompletionFunc)	(gpointer);
+typedef void		(*GDestroyNotify)	(gpointer	data);
+typedef void		(*GDataForeachFunc)	(GQuark		key_id,
+						 gpointer	data,
+						 gpointer	user_data);
+typedef void		(*GFunc)		(gpointer	data,
+						 gpointer	user_data);
+typedef guint		(*GHashFunc)		(gconstpointer	key);
+typedef void		(*GFreeFunc)		(gpointer	data);
+typedef void		(*GHFunc)		(gpointer	key,
+						 gpointer	value,
+						 gpointer	user_data);
+typedef gboolean	(*GHRFunc)		(gpointer	key,
+						 gpointer	value,
+						 gpointer	user_data);
+typedef void		(*GLogFunc)		(const gchar   *log_domain,
+						 GLogLevelFlags	log_level,
+						 const gchar   *message,
+						 gpointer	user_data);
+typedef gboolean	(*GNodeTraverseFunc)	(GNode	       *node,
+						 gpointer	data);
+typedef void		(*GNodeForeachFunc)	(GNode	       *node,
+						 gpointer	data);
+typedef gint		(*GSearchFunc)		(gpointer	key,
+						 gpointer	data);
+typedef gint		(*GTraverseFunc)	(gpointer	key,
+						 gpointer	value,
+						 gpointer	data);
+typedef	void		(*GVoidFunc)		(void);
+
+
+struct _GList
+{
+  gpointer data;
+  GList *next;
+  GList *prev;
+};
+
+struct _GSList
+{
+  gpointer data;
+  GSList *next;
+};
+
+struct _GString
+{
+  gchar *str;
+  gint len;
+};
+
+struct _GArray
+{
+  gchar *data;
+  guint len;
+};
+
+struct _GByteArray
+{
+  guint8 *data;
+  guint	  len;
+};
+
+struct _GPtrArray
+{
+  gpointer *pdata;
+  guint	    len;
+};
+
+struct _GTuples
+{
+  guint len;
+};
+
+struct _GDebugKey
+{
+  gchar *key;
+  guint	 value;
+};
+
+
+/* Doubly linked lists
+ */
+void   g_list_push_allocator    (GAllocator     *allocator);
+void   g_list_pop_allocator     (void);
+GList* g_list_alloc		(void);
+void   g_list_free		(GList		*list);
+void   g_list_free_1		(GList		*list);
+GList* g_list_append		(GList		*list,
+				 gpointer	 data);
+GList* g_list_prepend		(GList		*list,
+				 gpointer	 data);
+GList* g_list_insert		(GList		*list,
+				 gpointer	 data,
+				 gint		 position);
+GList* g_list_insert_sorted	(GList		*list,
+				 gpointer	 data,
+				 GCompareFunc	 func);
+GList* g_list_concat		(GList		*list1,
+				 GList		*list2);
+GList* g_list_remove		(GList		*list,
+				 gpointer	 data);
+GList* g_list_remove_link	(GList		*list,
+				 GList		*llink);
+GList* g_list_reverse		(GList		*list);
+GList* g_list_copy		(GList		*list);
+GList* g_list_nth		(GList		*list,
+				 guint		 n);
+GList* g_list_find		(GList		*list,
+				 gpointer	 data);
+GList* g_list_find_custom	(GList		*list,
+				 gpointer	 data,
+				 GCompareFunc	 func);
+gint   g_list_position		(GList		*list,
+				 GList		*llink);
+gint   g_list_index		(GList		*list,
+				 gpointer	 data);
+GList* g_list_last		(GList		*list);
+GList* g_list_first		(GList		*list);
+guint  g_list_length		(GList		*list);
+void   g_list_foreach		(GList		*list,
+				 GFunc		 func,
+				 gpointer	 user_data);
+GList* g_list_sort              (GList          *list,
+		                 GCompareFunc    compare_func);
+gpointer g_list_nth_data	(GList		*list,
+				 guint		 n);
+#define g_list_previous(list)	((list) ? (((GList *)(list))->prev) : NULL)
+#define g_list_next(list)	((list) ? (((GList *)(list))->next) : NULL)
+
+
+/* Singly linked lists
+ */
+void    g_slist_push_allocator  (GAllocator     *allocator);
+void    g_slist_pop_allocator   (void);
+GSList* g_slist_alloc		(void);
+void	g_slist_free		(GSList		*list);
+void	g_slist_free_1		(GSList		*list);
+GSList* g_slist_append		(GSList		*list,
+				 gpointer	 data);
+GSList* g_slist_prepend		(GSList		*list,
+				 gpointer	 data);
+GSList* g_slist_insert		(GSList		*list,
+				 gpointer	 data,
+				 gint		 position);
+GSList* g_slist_insert_sorted	(GSList		*list,
+				 gpointer	 data,
+				 GCompareFunc	 func);
+GSList* g_slist_concat		(GSList		*list1,
+				 GSList		*list2);
+GSList* g_slist_remove		(GSList		*list,
+				 gpointer	 data);
+GSList* g_slist_remove_link	(GSList		*list,
+				 GSList		*llink);
+GSList* g_slist_reverse		(GSList		*list);
+GSList*	g_slist_copy		(GSList		*list);
+GSList* g_slist_nth		(GSList		*list,
+				 guint		 n);
+GSList* g_slist_find		(GSList		*list,
+				 gpointer	 data);
+GSList* g_slist_find_custom	(GSList		*list,
+				 gpointer	 data,
+				 GCompareFunc	 func);
+gint	g_slist_position	(GSList		*list,
+				 GSList		*llink);
+gint	g_slist_index		(GSList		*list,
+				 gpointer	 data);
+GSList* g_slist_last		(GSList		*list);
+guint	g_slist_length		(GSList		*list);
+void	g_slist_foreach		(GSList		*list,
+				 GFunc		 func,
+				 gpointer	 user_data);
+GSList*  g_slist_sort           (GSList          *list,
+		                 GCompareFunc    compare_func);
+gpointer g_slist_nth_data	(GSList		*list,
+				 guint		 n);
+#define g_slist_next(slist)	((slist) ? (((GSList *)(slist))->next) : NULL)
+
+
+/* Hash tables
+ */
+GHashTable* g_hash_table_new		(GHashFunc	 hash_func,
+					 GCompareFunc	 key_compare_func);
+void	    g_hash_table_destroy	(GHashTable	*hash_table);
+void	    g_hash_table_insert		(GHashTable	*hash_table,
+					 gpointer	 key,
+					 gpointer	 value);
+void	    g_hash_table_remove		(GHashTable	*hash_table,
+					 gconstpointer	 key);
+gpointer    g_hash_table_lookup		(GHashTable	*hash_table,
+					 gconstpointer	 key);
+gboolean    g_hash_table_lookup_extended(GHashTable	*hash_table,
+					 gconstpointer	 lookup_key,
+					 gpointer	*orig_key,
+					 gpointer	*value);
+void	    g_hash_table_freeze		(GHashTable	*hash_table);
+void	    g_hash_table_thaw		(GHashTable	*hash_table);
+void	    g_hash_table_foreach	(GHashTable	*hash_table,
+					 GHFunc		 func,
+					 gpointer	 user_data);
+guint	    g_hash_table_foreach_remove	(GHashTable	*hash_table,
+					 GHRFunc	 func,
+					 gpointer	 user_data);
+guint	    g_hash_table_size		(GHashTable	*hash_table);
+
+
+
+
+/* Balanced binary trees
+ */
+GTree*	 g_tree_new	 (GCompareFunc	 key_compare_func);
+void	 g_tree_destroy	 (GTree		*tree);
+void	 g_tree_insert	 (GTree		*tree,
+			  gpointer	 key,
+			  gpointer	 value);
+void	 g_tree_remove	 (GTree		*tree,
+			  gpointer	 key);
+gpointer g_tree_lookup	 (GTree		*tree,
+			  gpointer	 key);
+void	 g_tree_traverse (GTree		*tree,
+			  GTraverseFunc	 traverse_func,
+			  GTraverseType	 traverse_type,
+			  gpointer	 data);
+gpointer g_tree_search	 (GTree		*tree,
+			  GSearchFunc	 search_func,
+			  gpointer	 data);
+gint	 g_tree_height	 (GTree		*tree);
+gint	 g_tree_nnodes	 (GTree		*tree);
+
+
+
+/* N-way tree implementation
+ */
+struct _GNode
+{
+  gpointer data;
+  GNode	  *next;
+  GNode	  *prev;
+  GNode	  *parent;
+  GNode	  *children;
+};
+
+#define	 G_NODE_IS_ROOT(node)	(((GNode*) (node))->parent == NULL && \
+				 ((GNode*) (node))->prev == NULL && \
+				 ((GNode*) (node))->next == NULL)
+#define	 G_NODE_IS_LEAF(node)	(((GNode*) (node))->children == NULL)
+
+void     g_node_push_allocator  (GAllocator       *allocator);
+void     g_node_pop_allocator   (void);
+GNode*	 g_node_new		(gpointer	   data);
+void	 g_node_destroy		(GNode		  *root);
+void	 g_node_unlink		(GNode		  *node);
+GNode*	 g_node_insert		(GNode		  *parent,
+				 gint		   position,
+				 GNode		  *node);
+GNode*	 g_node_insert_before	(GNode		  *parent,
+				 GNode		  *sibling,
+				 GNode		  *node);
+GNode*	 g_node_prepend		(GNode		  *parent,
+				 GNode		  *node);
+guint	 g_node_n_nodes		(GNode		  *root,
+				 GTraverseFlags	   flags);
+GNode*	 g_node_get_root	(GNode		  *node);
+gboolean g_node_is_ancestor	(GNode		  *node,
+				 GNode		  *descendant);
+guint	 g_node_depth		(GNode		  *node);
+GNode*	 g_node_find		(GNode		  *root,
+				 GTraverseType	   order,
+				 GTraverseFlags	   flags,
+				 gpointer	   data);
+
+/* convenience macros */
+#define g_node_append(parent, node)				\
+     g_node_insert_before ((parent), NULL, (node))
+#define	g_node_insert_data(parent, position, data)		\
+     g_node_insert ((parent), (position), g_node_new (data))
+#define	g_node_insert_data_before(parent, sibling, data)	\
+     g_node_insert_before ((parent), (sibling), g_node_new (data))
+#define	g_node_prepend_data(parent, data)			\
+     g_node_prepend ((parent), g_node_new (data))
+#define	g_node_append_data(parent, data)			\
+     g_node_insert_before ((parent), NULL, g_node_new (data))
+
+/* traversal function, assumes that `node' is root
+ * (only traverses `node' and its subtree).
+ * this function is just a high level interface to
+ * low level traversal functions, optimized for speed.
+ */
+void	 g_node_traverse	(GNode		  *root,
+				 GTraverseType	   order,
+				 GTraverseFlags	   flags,
+				 gint		   max_depth,
+				 GNodeTraverseFunc func,
+				 gpointer	   data);
+
+/* return the maximum tree height starting with `node', this is an expensive
+ * operation, since we need to visit all nodes. this could be shortened by
+ * adding `guint height' to struct _GNode, but then again, this is not very
+ * often needed, and would make g_node_insert() more time consuming.
+ */
+guint	 g_node_max_height	 (GNode *root);
+
+void	 g_node_children_foreach (GNode		  *node,
+				  GTraverseFlags   flags,
+				  GNodeForeachFunc func,
+				  gpointer	   data);
+void	 g_node_reverse_children (GNode		  *node);
+guint	 g_node_n_children	 (GNode		  *node);
+GNode*	 g_node_nth_child	 (GNode		  *node,
+				  guint		   n);
+GNode*	 g_node_last_child	 (GNode		  *node);
+GNode*	 g_node_find_child	 (GNode		  *node,
+				  GTraverseFlags   flags,
+				  gpointer	   data);
+gint	 g_node_child_position	 (GNode		  *node,
+				  GNode		  *child);
+gint	 g_node_child_index	 (GNode		  *node,
+				  gpointer	   data);
+
+GNode*	 g_node_first_sibling	 (GNode		  *node);
+GNode*	 g_node_last_sibling	 (GNode		  *node);
+
+#define	 g_node_prev_sibling(node)	((node) ? \
+					 ((GNode*) (node))->prev : NULL)
+#define	 g_node_next_sibling(node)	((node) ? \
+					 ((GNode*) (node))->next : NULL)
+#define	 g_node_first_child(node)	((node) ? \
+					 ((GNode*) (node))->children : NULL)
+
+
+
+/* Fatal error handlers.
+ * g_on_error_query() will prompt the user to either
+ * [E]xit, [H]alt, [P]roceed or show [S]tack trace.
+ * g_on_error_stack_trace() invokes gdb, which attaches to the current
+ * process and shows a stack trace.
+ * These function may cause different actions on non-unix platforms.
+ * The prg_name arg is required by gdb to find the executable, if it is
+ * passed as NULL, g_on_error_query() will try g_get_prgname().
+ */
+void g_on_error_query (const gchar *prg_name);
+void g_on_error_stack_trace (const gchar *prg_name);
+
+
+/* Logging mechanism
+ */
+extern	        const gchar		*g_log_domain_glib;
+guint		g_log_set_handler	(const gchar	*log_domain,
+					 GLogLevelFlags	 log_levels,
+					 GLogFunc	 log_func,
+					 gpointer	 user_data);
+void		g_log_remove_handler	(const gchar	*log_domain,
+					 guint		 handler_id);
+void		g_log_default_handler	(const gchar	*log_domain,
+					 GLogLevelFlags	 log_level,
+					 const gchar	*message,
+					 gpointer	 unused_data);
+#ifdef __KORBIT__
+#define g_log(log_domain, log_level, format, args...) \
+G_STMT_START { printf(format, ##args); printf("\n"); } G_STMT_END
+#define g_logv(log_domain, log_level, format, args...)
+#else /* !__KORBIT__ */
+void		g_log			(const gchar	*log_domain,
+					 GLogLevelFlags	 log_level,
+					 const gchar	*format,
+					 ...) G_GNUC_PRINTF (3, 4);
+void		g_logv			(const gchar	*log_domain,
+					 GLogLevelFlags	 log_level,
+					 const gchar	*format,
+					 va_list	 args);
+#endif /* !__KORBIT__ */
+GLogLevelFlags	g_log_set_fatal_mask	(const gchar	*log_domain,
+					 GLogLevelFlags	 fatal_mask);
+GLogLevelFlags	g_log_set_always_fatal	(GLogLevelFlags	 fatal_mask);
+#ifndef	G_LOG_DOMAIN
+#define	G_LOG_DOMAIN	((gchar*) 0)
+#endif	/* G_LOG_DOMAIN */
+#ifdef	__GNUC__
+#define	g_error(format, args...)	g_log (G_LOG_DOMAIN, \
+					       G_LOG_LEVEL_ERROR, \
+					       format, ##args)
+#define	g_message(format, args...)	g_log (G_LOG_DOMAIN, \
+					       G_LOG_LEVEL_MESSAGE, \
+					       format, ##args)
+#define	g_warning(format, args...)	g_log (G_LOG_DOMAIN, \
+					       G_LOG_LEVEL_WARNING, \
+					       format, ##args)
+#else	/* !__GNUC__ */
+static void
+g_error (const gchar *format,
+	 ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format, args);
+  va_end (args);
+}
+static void
+g_message (const gchar *format,
+	   ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, format, args);
+  va_end (args);
+}
+static void
+g_warning (const gchar *format,
+	   ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, format, args);
+  va_end (args);
+}
+#endif	/* !__GNUC__ */
+
+typedef void	(*GPrintFunc)		(const gchar	*string);
+#ifdef __KORBIT__
+#define g_print(format, args...) printf(format, ##args)
+#else
+void		g_print			(const gchar	*format,
+					 ...) G_GNUC_PRINTF (1, 2);
+#endif
+GPrintFunc	g_set_print_handler	(GPrintFunc	 func);
+void		g_printerr		(const gchar	*format,
+					 ...) G_GNUC_PRINTF (1, 2);
+GPrintFunc	g_set_printerr_handler	(GPrintFunc	 func);
+
+/* deprecated compatibility functions, use g_log_set_handler() instead */
+typedef void		(*GErrorFunc)		(const gchar *str);
+typedef void		(*GWarningFunc)		(const gchar *str);
+GErrorFunc   g_set_error_handler   (GErrorFunc	 func);
+GWarningFunc g_set_warning_handler (GWarningFunc func);
+GPrintFunc   g_set_message_handler (GPrintFunc func);
+
+
+gpointer g_malloc      (gulong	  size);
+gpointer g_malloc0     (gulong	  size);
+gpointer g_realloc     (gpointer  mem,
+			gulong	  size);
+void	 g_free	       (gpointer  mem);
+
+/* Generic allocators
+ */
+GAllocator* g_allocator_new   (const gchar  *name,
+			       guint         n_preallocs);
+void        g_allocator_free  (GAllocator   *allocator);
+
+#define	G_ALLOCATOR_LIST	(1)
+#define	G_ALLOCATOR_SLIST	(2)
+#define	G_ALLOCATOR_NODE	(3)
+
+
+/* "g_mem_chunk_new" creates a new memory chunk.
+ * Memory chunks are used to allocate pieces of memory which are
+ *  always the same size. Lists are a good example of such a data type.
+ * The memory chunk allocates and frees blocks of memory as needed.
+ *  Just be sure to call "g_mem_chunk_free" and not "g_free" on data
+ *  allocated in a mem chunk. ("g_free" will most likely cause a seg
+ *  fault...somewhere).
+ *
+ * Oh yeah, GMemChunk is an opaque data type. (You don't really
+ *  want to know what's going on inside do you?)
+ */
+
+/* ALLOC_ONLY MemChunk's can only allocate memory. The free operation
+ *  is interpreted as a no op. ALLOC_ONLY MemChunk's save 4 bytes per
+ *  atom. (They are also useful for lists which use MemChunk to allocate
+ *  memory but are also part of the MemChunk implementation).
+ * ALLOC_AND_FREE MemChunk's can allocate and free memory.
+ */
+
+#define G_ALLOC_ONLY	  1
+#define G_ALLOC_AND_FREE  2
+
+GMemChunk* g_mem_chunk_new     (gchar	  *name,
+				gint	   atom_size,
+				gulong	   area_size,
+				gint	   type);
+void	   g_mem_chunk_destroy (GMemChunk *mem_chunk);
+gpointer   g_mem_chunk_alloc   (GMemChunk *mem_chunk);
+gpointer   g_mem_chunk_alloc0  (GMemChunk *mem_chunk);
+void	   g_mem_chunk_free    (GMemChunk *mem_chunk,
+				gpointer   mem);
+void	   g_mem_chunk_clean   (GMemChunk *mem_chunk);
+void	   g_mem_chunk_reset   (GMemChunk *mem_chunk);
+void	   g_mem_chunk_print   (GMemChunk *mem_chunk);
+void	   g_mem_chunk_info    (void);
+
+/* Ah yes...we have a "g_blow_chunks" function.
+ * "g_blow_chunks" simply compresses all the chunks. This operation
+ *  consists of freeing every memory area that should be freed (but
+ *  which we haven't gotten around to doing yet). And, no,
+ *  "g_blow_chunks" doesn't follow the naming scheme, but it is a
+ *  much better name than "g_mem_chunk_clean_all" or something
+ *  similar.
+ */
+void g_blow_chunks (void);
+
+
+/* String utility functions that modify a string argument or
+ * return a constant string that must not be freed.
+ */
+#define	 G_STR_DELIMITERS	"_-|> <."
+gchar*	 g_strdelimit		(gchar	     *string,
+				 const gchar *delimiters,
+				 gchar	      new_delimiter);
+#ifndef __KORBIT__
+gdouble	 g_strtod		(const gchar *nptr,
+				 gchar	    **endptr);
+#endif /* !__KORBIT__ */
+gchar*	 g_strerror		(gint	      errnum);
+gchar*	 g_strsignal		(gint	      signum);
+gint	 g_strcasecmp		(const gchar *s1,
+				 const gchar *s2);
+gint	 g_strncasecmp		(const gchar *s1,
+				 const gchar *s2,
+				 guint 	      n);
+void	 g_strdown		(gchar	     *string);
+void	 g_strup		(gchar	     *string);
+void	 g_strreverse		(gchar	     *string);
+/* removes leading spaces */
+gchar*   g_strchug              (gchar        *string);
+/* removes trailing spaces */
+gchar*  g_strchomp              (gchar        *string);
+/* removes leading & trailing spaces */
+#define g_strstrip( string )	g_strchomp (g_strchug (string))
+
+/* String utility functions that return a newly allocated string which
+ * ought to be freed from the caller at some point.
+ */
+gchar*	 g_strdup		(const gchar *str);
+gchar*	 g_strdup_printf	(const gchar *format,
+				 ...) G_GNUC_PRINTF (1, 2);
+gchar*	 g_strdup_vprintf	(const gchar *format,
+				 va_list      args);
+gchar*	 g_strndup		(const gchar *str,
+				 guint	      n);
+gchar*	 g_strnfill		(guint	      length,
+				 gchar	      fill_char);
+gchar*	 g_strconcat		(const gchar *string1,
+				 ...); /* NULL terminated */
+gchar*   g_strjoin		(const gchar  *separator,
+				 ...); /* NULL terminated */
+gchar*	 g_strescape		(gchar	      *string);
+gpointer g_memdup		(gconstpointer mem,
+				 guint	       byte_size);
+
+/* NULL terminated string arrays.
+ * g_strsplit() splits up string into max_tokens tokens at delim and
+ * returns a newly allocated string array.
+ * g_strjoinv() concatenates all of str_array's strings, sliding in an
+ * optional separator, the returned string is newly allocated.
+ * g_strfreev() frees the array itself and all of its strings.
+ */
+gchar**	 g_strsplit		(const gchar  *string,
+				 const gchar  *delimiter,
+				 gint          max_tokens);
+gchar*   g_strjoinv		(const gchar  *separator,
+				 gchar       **str_array);
+void     g_strfreev		(gchar       **str_array);
+
+
+
+/* calculate a string size, guarranteed to fit format + args.
+ */
+guint	g_printf_string_upper_bound (const gchar* format,
+				     va_list	  args);
+
+
+/* Retrive static string info
+ */
+gchar*	g_get_user_name		(void);
+gchar*	g_get_real_name		(void);
+gchar*	g_get_home_dir		(void);
+gchar*	g_get_tmp_dir		(void);
+gchar*	g_get_prgname		(void);
+void	g_set_prgname		(const gchar *prgname);
+
+
+/* Miscellaneous utility functions
+ */
+guint	g_parse_debug_string	(const gchar *string,
+				 GDebugKey   *keys,
+				 guint	      nkeys);
+gint	g_snprintf		(gchar	     *string,
+				 gulong	      n,
+				 gchar const *format,
+				 ...) G_GNUC_PRINTF (3, 4);
+gint	g_vsnprintf		(gchar	     *string,
+				 gulong	      n,
+				 gchar const *format,
+				 va_list      args);
+gchar*	g_basename		(const gchar *file_name);
+/* Check if a file name is an absolute path */
+gboolean g_path_is_absolute	(const gchar *file_name);
+/* In case of absolute paths, skip the root part */
+gchar*  g_path_skip_root	(gchar       *file_name);
+
+/* strings are newly allocated with g_malloc() */
+gchar*	g_dirname		(const gchar *file_name);
+gchar*	g_get_current_dir	(void);
+gchar*  g_getenv		(const gchar *variable);
+
+
+/* we use a GLib function as a replacement for ATEXIT, so
+ * the programmer is not required to check the return value
+ * (if there is any in the implementation) and doesn't encounter
+ * missing include files.
+ */
+void	g_atexit		(GVoidFunc    func);
+
+
+/* Bit tests
+ */
+G_INLINE_FUNC gint	g_bit_nth_lsf (guint32 mask,
+				       gint    nth_bit);
+#ifdef	G_CAN_INLINE
+G_INLINE_FUNC gint
+g_bit_nth_lsf (guint32 mask,
+	       gint    nth_bit)
+{
+  do
+    {
+      nth_bit++;
+      if (mask & (1 << (guint) nth_bit))
+	return nth_bit;
+    }
+  while (nth_bit < 32);
+  return -1;
+}
+#endif	/* G_CAN_INLINE */
+
+G_INLINE_FUNC gint	g_bit_nth_msf (guint32 mask,
+				       gint    nth_bit);
+#ifdef G_CAN_INLINE
+G_INLINE_FUNC gint
+g_bit_nth_msf (guint32 mask,
+	       gint    nth_bit)
+{
+  if (nth_bit < 0)
+    nth_bit = 32;
+  do
+    {
+      nth_bit--;
+      if (mask & (1 << (guint) nth_bit))
+	return nth_bit;
+    }
+  while (nth_bit > 0);
+  return -1;
+}
+#endif	/* G_CAN_INLINE */
+
+G_INLINE_FUNC guint	g_bit_storage (guint number);
+#ifdef G_CAN_INLINE
+G_INLINE_FUNC guint
+g_bit_storage (guint number)
+{
+  register guint n_bits = 0;
+  
+  do
+    {
+      n_bits++;
+      number >>= 1;
+    }
+  while (number);
+  return n_bits;
+}
+#endif	/* G_CAN_INLINE */
+
+/* String Chunks
+ */
+GStringChunk* g_string_chunk_new	   (gint size);
+void	      g_string_chunk_free	   (GStringChunk *chunk);
+gchar*	      g_string_chunk_insert	   (GStringChunk *chunk,
+					    const gchar	 *string);
+gchar*	      g_string_chunk_insert_const  (GStringChunk *chunk,
+					    const gchar	 *string);
+
+
+/* Strings
+ */
+GString* g_string_new	    (const gchar *init);
+GString* g_string_sized_new (guint	  dfl_size);
+void	 g_string_free	    (GString	 *string,
+			     gint	  free_segment);
+GString* g_string_assign    (GString	 *lval,
+			     const gchar *rval);
+GString* g_string_truncate  (GString	 *string,
+			     gint	  len);
+GString* g_string_append    (GString	 *string,
+			     const gchar *val);
+GString* g_string_append_c  (GString	 *string,
+			     gchar	  c);
+GString* g_string_prepend   (GString	 *string,
+			     const gchar *val);
+GString* g_string_prepend_c (GString	 *string,
+			     gchar	  c);
+GString* g_string_insert    (GString	 *string,
+			     gint	  pos,
+			     const gchar *val);
+GString* g_string_insert_c  (GString	 *string,
+			     gint	  pos,
+			     gchar	  c);
+GString* g_string_erase	    (GString	 *string,
+			     gint	  pos,
+			     gint	  len);
+GString* g_string_down	    (GString	 *string);
+GString* g_string_up	    (GString	 *string);
+void	 g_string_sprintf   (GString	 *string,
+			     const gchar *format,
+			     ...) G_GNUC_PRINTF (2, 3);
+void	 g_string_sprintfa  (GString	 *string,
+			     const gchar *format,
+			     ...) G_GNUC_PRINTF (2, 3);
+
+
+/* Resizable arrays, remove fills any cleared spot and shortens the
+ * array, while preserving the order. remove_fast will distort the
+ * order by moving the last element to the position of the removed 
+ */
+
+#define g_array_append_val(a,v)	  g_array_append_vals (a, &v, 1)
+#define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &v, 1)
+#define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &v, 1)
+#define g_array_index(a,t,i)      (((t*) (a)->data) [(i)])
+
+GArray* g_array_new	          (gboolean	    zero_terminated,
+				   gboolean	    clear,
+				   guint	    element_size);
+void	g_array_free	          (GArray	   *array,
+				   gboolean	    free_segment);
+GArray* g_array_append_vals       (GArray	   *array,
+				   gconstpointer    data,
+				   guint	    len);
+GArray* g_array_prepend_vals      (GArray	   *array,
+				   gconstpointer    data,
+				   guint	    len);
+GArray* g_array_insert_vals       (GArray          *array,
+				   guint            index,
+				   gconstpointer    data,
+				   guint            len);
+GArray* g_array_set_size          (GArray	   *array,
+				   guint	    length);
+GArray* g_array_remove_index	  (GArray	   *array,
+				   guint	    index);
+GArray* g_array_remove_index_fast (GArray	   *array,
+				   guint	    index);
+
+/* Resizable pointer array.  This interface is much less complicated
+ * than the above.  Add appends appends a pointer.  Remove fills any
+ * cleared spot and shortens the array. remove_fast will again distort
+ * order.  
+ */
+#define	    g_ptr_array_index(array,index) (array->pdata)[index]
+GPtrArray*  g_ptr_array_new		   (void);
+void	    g_ptr_array_free		   (GPtrArray	*array,
+					    gboolean	 free_seg);
+void	    g_ptr_array_set_size	   (GPtrArray	*array,
+					    gint	 length);
+gpointer    g_ptr_array_remove_index	   (GPtrArray	*array,
+					    guint	 index);
+gpointer    g_ptr_array_remove_index_fast  (GPtrArray	*array,
+					    guint	 index);
+gboolean    g_ptr_array_remove		   (GPtrArray	*array,
+					    gpointer	 data);
+gboolean    g_ptr_array_remove_fast        (GPtrArray	*array,
+					    gpointer	 data);
+void	    g_ptr_array_add		   (GPtrArray	*array,
+					    gpointer	 data);
+
+/* Hash Functions
+ */
+gint  g_str_equal (gconstpointer   v,
+		   gconstpointer   v2);
+guint g_str_hash  (gconstpointer   v);
+
+gint  g_int_equal (gconstpointer   v,
+		   gconstpointer   v2);
+guint g_int_hash  (gconstpointer   v);
+
+/* This "hash" function will just return the key's adress as an
+ * unsigned integer. Useful for hashing on plain adresses or
+ * simple integer values.
+ * passing NULL into g_hash_table_new() as GHashFunc has the
+ * same effect as passing g_direct_hash().
+ */
+guint g_direct_hash  (gconstpointer v);
+gint  g_direct_equal (gconstpointer v,
+		      gconstpointer v2);
+
+
+
+/* Prime numbers.
+ */
+
+/* This function returns prime numbers spaced by approximately 1.5-2.0
+ * and is for use in resizing data structures which prefer
+ * prime-valued sizes.	The closest spaced prime function returns the
+ * next largest prime, or the highest it knows about which is about
+ * MAXINT/4.
+ */
+guint	   g_spaced_primes_closest (guint num);
+
+
+
+#ifndef __KORBIT__
+/* GLib Thread support
+ */
+typedef struct _GMutex		GMutex;
+typedef struct _GCond		GCond;
+typedef struct _GPrivate	GPrivate;
+typedef struct _GStaticPrivate	GStaticPrivate;
+typedef struct _GThreadFunctions GThreadFunctions;
+struct _GThreadFunctions
+{
+  GMutex*  (*mutex_new)       (void);
+  void     (*mutex_lock)      (GMutex		*mutex);
+  gboolean (*mutex_trylock)   (GMutex		*mutex);
+  void     (*mutex_unlock)    (GMutex		*mutex);
+  void     (*mutex_free)      (GMutex		*mutex);
+  GCond*   (*cond_new)        (void);
+  void     (*cond_signal)     (GCond		*cond);
+  void     (*cond_broadcast)  (GCond		*cond);
+  void     (*cond_wait)       (GCond		*cond,
+			       GMutex		*mutex);
+  gboolean (*cond_timed_wait) (GCond		*cond,
+			       GMutex		*mutex, 
+			       GTimeVal 	*end_time);
+  void      (*cond_free)      (GCond		*cond);
+  GPrivate* (*private_new)    (GDestroyNotify	 destructor);
+  gpointer  (*private_get)    (GPrivate		*private_key);
+  void      (*private_set)    (GPrivate		*private_key,
+			       gpointer		 data);
+};
+
+GUTILS_C_VAR GThreadFunctions	g_thread_functions_for_glib_use;
+GUTILS_C_VAR gboolean		g_thread_use_default_impl;
+GUTILS_C_VAR gboolean		g_threads_got_initialized;
+
+/* initializes the mutex/cond/private implementation for glib, might
+ * only be called once, and must not be called directly or indirectly
+ * from another glib-function, e.g. as a callback.
+ */
+void   g_thread_init   (GThreadFunctions       *vtable);
+
+/* internal function for fallback static mutex implementation */
+GMutex*	g_static_mutex_get_mutex_impl	(GMutex	**mutex);
+
+/* shorthands for conditional and unconditional function calls */
+#define G_THREAD_UF(name, arglist) \
+    (*g_thread_functions_for_glib_use . name) arglist
+#define G_THREAD_CF(name, fail, arg) \
+    (g_thread_supported () ? G_THREAD_UF (name, arg) : (fail))
+/* keep in mind, all those mutexes and static mutexes are not 
+ * recursive in general, don't rely on that
+ */
+#define	g_thread_supported()	(g_threads_got_initialized)
+#define g_mutex_new()            G_THREAD_UF (mutex_new,      ())
+#define g_mutex_lock(mutex)      G_THREAD_CF (mutex_lock,     (void)0, (mutex))
+#define g_mutex_trylock(mutex)   G_THREAD_CF (mutex_trylock,  TRUE,    (mutex))
+#define g_mutex_unlock(mutex)    G_THREAD_CF (mutex_unlock,   (void)0, (mutex))
+#define g_mutex_free(mutex)      G_THREAD_CF (mutex_free,     (void)0, (mutex))
+#define g_cond_new()             G_THREAD_UF (cond_new,       ())
+#define g_cond_signal(cond)      G_THREAD_CF (cond_signal,    (void)0, (cond))
+#define g_cond_broadcast(cond)   G_THREAD_CF (cond_broadcast, (void)0, (cond))
+#define g_cond_wait(cond, mutex) G_THREAD_CF (cond_wait,      (void)0, (cond, \
+                                                                        mutex))
+#define g_cond_free(cond)        G_THREAD_CF (cond_free,      (void)0, (cond))
+#define g_cond_timed_wait(cond, mutex, abs_time) G_THREAD_CF (cond_timed_wait, \
+                                                              TRUE, \
+                                                              (cond, mutex, \
+							       abs_time))
+#define g_private_new(destructor)	  G_THREAD_UF (private_new, (destructor))
+#define g_private_get(private_key)	  G_THREAD_CF (private_get, \
+                                                       ((gpointer)private_key), \
+                                                       (private_key))
+#define g_private_set(private_key, value) G_THREAD_CF (private_set, \
+                                                       (void) (private_key = \
+                                                        (GPrivate*) (value)), \
+                                                       (private_key, value))
+/* GStaticMutexes can be statically initialized with the value
+ * G_STATIC_MUTEX_INIT, and then they can directly be used, that is
+ * much easier, than having to explicitly allocate the mutex before
+ * use
+ */
+#define g_static_mutex_lock(mutex) \
+    g_mutex_lock (g_static_mutex_get_mutex (mutex))
+#define g_static_mutex_trylock(mutex) \
+    g_mutex_trylock (g_static_mutex_get_mutex (mutex))
+#define g_static_mutex_unlock(mutex) \
+    g_mutex_unlock (g_static_mutex_get_mutex (mutex)) 
+struct _GStaticPrivate
+{
+  guint index;
+};
+#define G_STATIC_PRIVATE_INIT { 0 }
+gpointer g_static_private_get (GStaticPrivate	*private_key);
+void     g_static_private_set (GStaticPrivate	*private_key, 
+			       gpointer        	 data,
+			       GDestroyNotify    notify);
+#endif /* __KORBIT__ */
+
+/* these are some convenience macros that expand to nothing if GLib
+ * was configured with --disable-threads. for using StaticMutexes,
+ * you define them with G_LOCK_DEFINE_STATIC (name) or G_LOCK_DEFINE (name)
+ * if you need to export the mutex. With G_LOCK_EXTERN (name) you can
+ * declare such an globally defined lock. name is a unique identifier
+ * for the protected varibale or code portion. locking, testing and
+ * unlocking of such mutexes can be done with G_LOCK(), G_UNLOCK() and
+ * G_TRYLOCK() respectively.  
+ */
+#ifdef __KORBIT__
+#undef G_THREADS_ENABLED
+#endif
+
+extern void glib_dummy_decl (void);
+#define G_LOCK_NAME(name)		(g__ ## name ## _lock)
+#ifdef	G_THREADS_ENABLED
+#  define G_LOCK_DEFINE_STATIC(name)	static G_LOCK_DEFINE (name)
+#  define G_LOCK_DEFINE(name)		\
+    GStaticMutex G_LOCK_NAME (name) = G_STATIC_MUTEX_INIT 
+#  define G_LOCK_EXTERN(name)		extern GStaticMutex G_LOCK_NAME (name)
+
+#    define G_LOCK(name) g_static_mutex_lock	   (&G_LOCK_NAME (name)) 
+#    define G_UNLOCK(name) g_static_mutex_unlock   (&G_LOCK_NAME (name))
+#    define G_TRYLOCK(name) g_static_mutex_trylock (&G_LOCK_NAME (name))
+#else	/* !G_THREADS_ENABLED */
+#  define G_LOCK_DEFINE_STATIC(name)	extern void glib_dummy_decl (void)
+#  define G_LOCK_DEFINE(name)		extern void glib_dummy_decl (void)
+#  define G_LOCK_EXTERN(name)		extern void glib_dummy_decl (void)
+#  define G_LOCK(name)
+#  define G_UNLOCK(name)
+#  define G_TRYLOCK(name)		(FALSE)
+#endif	/* !G_THREADS_ENABLED */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __G_LIB_H__ */
diff -urN linux-2.4.1/net/korbit/kglib/glibconfig.h linux-2.4.1-korbit/net/korbit/kglib/glibconfig.h
--- linux-2.4.1/net/korbit/kglib/glibconfig.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/glibconfig.h	Thu Feb  1 11:46:56 2001
@@ -0,0 +1,131 @@
+/* glibconfig.h
+ *
+ * This is a generated file.  Please modify `configure.in'
+ */
+
+#ifndef GLIBCONFIG_H
+#define GLIBCONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <limits.h>
+/*#include <float.h>*/
+#define GLIB_HAVE_SYS_POLL_H
+
+#define G_MINFLOAT	FLT_MIN
+#define G_MAXFLOAT	FLT_MAX
+#define G_MINDOUBLE	DBL_MIN
+#define G_MAXDOUBLE	DBL_MAX
+#define G_MINSHORT	SHRT_MIN
+#define G_MAXSHORT	SHRT_MAX
+#define G_MININT	INT_MIN
+#define G_MAXINT	INT_MAX
+#define G_MINLONG	LONG_MIN
+#define G_MAXLONG	LONG_MAX
+
+typedef signed char gint8;
+typedef unsigned char guint8;
+typedef signed short gint16;
+typedef unsigned short guint16;
+typedef signed int gint32;
+typedef unsigned int guint32;
+
+#if defined (__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))
+#  define G_GNUC_EXTENSION __extension__
+#else
+#  define G_GNUC_EXTENSION
+#endif
+
+#define G_HAVE_GINT64 1
+
+G_GNUC_EXTENSION typedef signed long long gint64;
+G_GNUC_EXTENSION typedef unsigned long long guint64;
+
+#define G_GINT64_CONSTANT(val)	(G_GNUC_EXTENSION (val##LL))
+
+#define GPOINTER_TO_INT(p)	((gint)   (p))
+#define GPOINTER_TO_UINT(p)	((guint)  (p))
+
+#define GINT_TO_POINTER(i)	((gpointer)  (i))
+#define GUINT_TO_POINTER(u)	((gpointer)  (u))
+
+#ifdef NeXT /* @#%@! NeXTStep */
+# define g_ATEXIT(proc)	(!atexit (proc))
+#else
+# define g_ATEXIT(proc)	(atexit (proc))
+#endif
+
+#define g_memmove(d,s,n) G_STMT_START { memmove ((d), (s), (n)); } G_STMT_END
+
+#define GLIB_MAJOR_VERSION 1
+#define GLIB_MINOR_VERSION 2
+#define GLIB_MICRO_VERSION 8
+
+
+#define G_VA_COPY	__va_copy
+
+#ifdef	__cplusplus
+#define	G_HAVE_INLINE	1
+#else	/* !__cplusplus */
+#define G_HAVE_INLINE 1
+#define G_HAVE___INLINE 1
+#define G_HAVE___INLINE__ 1
+#endif	/* !__cplusplus */
+
+#define G_THREADS_ENABLED
+#define G_THREADS_IMPL_POSIX
+typedef struct _GStaticMutex GStaticMutex;
+struct _GStaticMutex
+{
+  struct _GMutex *runtime_mutex;
+  union {
+    char   pad[24];
+    double dummy_double;
+    void  *dummy_pointer;
+    long   dummy_long;
+  } aligned_pad_u;
+};
+#define	G_STATIC_MUTEX_INIT	{ NULL, { { 0,0,0,0,0,0,77,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} } }
+#define	g_static_mutex_get_mutex(mutex)   (g_thread_use_default_impl ? ((GMutex*) &((mutex)->aligned_pad_u)) :    g_static_mutex_get_mutex_impl (&((mutex)->runtime_mutex)))
+
+#define GINT16_TO_BE(val)	((gint16) (val))
+#define GUINT16_TO_BE(val)	((guint16) (val))
+#define GINT16_TO_LE(val)	((gint16) GUINT16_SWAP_LE_BE (val))
+#define GUINT16_TO_LE(val)	(GUINT16_SWAP_LE_BE (val))
+#define GINT32_TO_BE(val)	((gint32) (val))
+#define GUINT32_TO_BE(val)	((guint32) (val))
+#define GINT32_TO_LE(val)	((gint32) GUINT32_SWAP_LE_BE (val))
+#define GUINT32_TO_LE(val)	(GUINT32_SWAP_LE_BE (val))
+#define GINT64_TO_BE(val)	((gint64) (val))
+#define GUINT64_TO_BE(val)	((guint64) (val))
+#define GINT64_TO_LE(val)	((gint64) GUINT64_SWAP_LE_BE (val))
+#define GUINT64_TO_LE(val)	(GUINT64_SWAP_LE_BE (val))
+#define GLONG_TO_LE(val)	((glong) GINT32_TO_LE (val))
+#define GULONG_TO_LE(val)	((gulong) GUINT32_TO_LE (val))
+#define GLONG_TO_BE(val)	((glong) GINT32_TO_BE (val))
+#define GULONG_TO_BE(val)	((gulong) GUINT32_TO_BE (val))
+#define GINT_TO_LE(val)		((gint) GINT32_TO_LE (val))
+#define GUINT_TO_LE(val)	((guint) GUINT32_TO_LE (val))
+#define GINT_TO_BE(val)		((gint) GINT32_TO_BE (val))
+#define GUINT_TO_BE(val)	((guint) GUINT32_TO_BE (val))
+#define G_BYTE_ORDER G_LITTLE_ENDIAN
+
+#define GLIB_SYSDEF_POLLIN =1
+#define GLIB_SYSDEF_POLLOUT =4
+#define GLIB_SYSDEF_POLLPRI =2
+#define GLIB_SYSDEF_POLLERR =8
+#define GLIB_SYSDEF_POLLHUP =16
+#define GLIB_SYSDEF_POLLNVAL =32
+
+
+#define G_HAVE_WCHAR_H 1
+#define G_HAVE_WCTYPE_H 1
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* GLIBCONFIG_H */
diff -urN linux-2.4.1/net/korbit/kglib/glist.c linux-2.4.1-korbit/net/korbit/kglib/glist.c
--- linux-2.4.1/net/korbit/kglib/glist.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/glist.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,666 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include "glib.h"
+
+
+struct _GAllocator /* from gmem.c */
+{
+  gchar         *name;
+  guint16        n_preallocs;
+  guint          is_unused : 1;
+  guint          type : 4;
+  GAllocator    *last;
+  GMemChunk     *mem_chunk;
+  GList		*free_lists; /* implementation specific */
+};
+
+static GAllocator	*current_allocator = NULL;
+G_LOCK_DEFINE_STATIC (current_allocator);
+
+/* HOLDS: current_allocator_lock */
+static void
+g_list_validate_allocator (GAllocator *allocator)
+{
+  g_return_if_fail (allocator != NULL);
+  g_return_if_fail (allocator->is_unused == TRUE);
+
+  if (allocator->type != G_ALLOCATOR_LIST)
+    {
+      allocator->type = G_ALLOCATOR_LIST;
+      if (allocator->mem_chunk)
+	{
+	  g_mem_chunk_destroy (allocator->mem_chunk);
+	  allocator->mem_chunk = NULL;
+	}
+    }
+
+  if (!allocator->mem_chunk)
+    {
+      allocator->mem_chunk = g_mem_chunk_new (allocator->name,
+					      sizeof (GList),
+					      sizeof (GList) * allocator->n_preallocs,
+					      G_ALLOC_ONLY);
+      allocator->free_lists = NULL;
+    }
+
+  allocator->is_unused = FALSE;
+}
+
+void
+g_list_push_allocator(GAllocator *allocator)
+{
+  G_LOCK (current_allocator);
+  g_list_validate_allocator ( allocator );
+  allocator->last = current_allocator;
+  current_allocator = allocator;
+  G_UNLOCK (current_allocator);
+}
+
+void
+g_list_pop_allocator (void)
+{
+  G_LOCK (current_allocator);
+  if (current_allocator)
+    {
+      GAllocator *allocator;
+
+      allocator = current_allocator;
+      current_allocator = allocator->last;
+      allocator->last = NULL;
+      allocator->is_unused = TRUE;
+    }
+  G_UNLOCK (current_allocator);
+}
+
+GList*
+g_list_alloc (void)
+{
+  GList *list;
+
+  G_LOCK (current_allocator);
+  if (!current_allocator)
+    {
+      GAllocator *allocator = g_allocator_new ("GLib default GList allocator",
+					       128);
+      g_list_validate_allocator (allocator);
+      allocator->last = NULL;
+      current_allocator = allocator;
+    }
+  if (!current_allocator->free_lists)
+    {
+      list = g_chunk_new (GList, current_allocator->mem_chunk);
+      list->data = NULL;
+    }
+  else
+    {
+      if (current_allocator->free_lists->data)
+	{
+	  list = current_allocator->free_lists->data;
+	  current_allocator->free_lists->data = list->next;
+	  list->data = NULL;
+	}
+      else
+	{
+	  list = current_allocator->free_lists;
+	  current_allocator->free_lists = list->next;
+	}
+    }
+  G_UNLOCK (current_allocator);
+  list->next = NULL;
+  list->prev = NULL;
+  
+  return list;
+}
+
+void
+g_list_free (GList *list)
+{
+  if (list)
+    {
+      list->data = list->next;  
+      G_LOCK (current_allocator);
+      list->next = current_allocator->free_lists;
+      current_allocator->free_lists = list;
+      G_UNLOCK (current_allocator);
+    }
+}
+
+void
+g_list_free_1 (GList *list)
+{
+  if (list)
+    {
+      list->data = NULL;  
+      G_LOCK (current_allocator);
+      list->next = current_allocator->free_lists;
+      current_allocator->free_lists = list;
+      G_UNLOCK (current_allocator);
+    }
+}
+
+GList*
+g_list_append (GList	*list,
+	       gpointer	 data)
+{
+  GList *new_list;
+  GList *last;
+  
+  new_list = g_list_alloc ();
+  new_list->data = data;
+  
+  if (list)
+    {
+      last = g_list_last (list);
+      /* g_assert (last != NULL); */
+      last->next = new_list;
+      new_list->prev = last;
+
+      return list;
+    }
+  else
+    return new_list;
+}
+
+GList*
+g_list_prepend (GList	 *list,
+		gpointer  data)
+{
+  GList *new_list;
+  
+  new_list = g_list_alloc ();
+  new_list->data = data;
+  
+  if (list)
+    {
+      if (list->prev)
+	{
+	  list->prev->next = new_list;
+	  new_list->prev = list->prev;
+	}
+      list->prev = new_list;
+      new_list->next = list;
+    }
+  
+  return new_list;
+}
+
+GList*
+g_list_insert (GList	*list,
+	       gpointer	 data,
+	       gint	 position)
+{
+  GList *new_list;
+  GList *tmp_list;
+  
+  if (position < 0)
+    return g_list_append (list, data);
+  else if (position == 0)
+    return g_list_prepend (list, data);
+  
+  tmp_list = g_list_nth (list, position);
+  if (!tmp_list)
+    return g_list_append (list, data);
+  
+  new_list = g_list_alloc ();
+  new_list->data = data;
+  
+  if (tmp_list->prev)
+    {
+      tmp_list->prev->next = new_list;
+      new_list->prev = tmp_list->prev;
+    }
+  new_list->next = tmp_list;
+  tmp_list->prev = new_list;
+  
+  if (tmp_list == list)
+    return new_list;
+  else
+    return list;
+}
+
+GList *
+g_list_concat (GList *list1, GList *list2)
+{
+  GList *tmp_list;
+  
+  if (list2)
+    {
+      tmp_list = g_list_last (list1);
+      if (tmp_list)
+	tmp_list->next = list2;
+      else
+	list1 = list2;
+      list2->prev = tmp_list;
+    }
+  
+  return list1;
+}
+
+GList*
+g_list_remove (GList	*list,
+	       gpointer	 data)
+{
+  GList *tmp;
+  
+  tmp = list;
+  while (tmp)
+    {
+      if (tmp->data != data)
+	tmp = tmp->next;
+      else
+	{
+	  if (tmp->prev)
+	    tmp->prev->next = tmp->next;
+	  if (tmp->next)
+	    tmp->next->prev = tmp->prev;
+	  
+	  if (list == tmp)
+	    list = list->next;
+	  
+	  g_list_free_1 (tmp);
+	  
+	  break;
+	}
+    }
+  return list;
+}
+
+GList*
+g_list_remove_link (GList *list,
+		    GList *link)
+{
+  if (link)
+    {
+      if (link->prev)
+	link->prev->next = link->next;
+      if (link->next)
+	link->next->prev = link->prev;
+      
+      if (link == list)
+	list = list->next;
+      
+      link->next = NULL;
+      link->prev = NULL;
+    }
+  
+  return list;
+}
+
+GList*
+g_list_copy (GList *list)
+{
+  GList *new_list = NULL;
+
+  if (list)
+    {
+      GList *last;
+
+      new_list = g_list_alloc ();
+      new_list->data = list->data;
+      last = new_list;
+      list = list->next;
+      while (list)
+	{
+	  last->next = g_list_alloc ();
+	  last->next->prev = last;
+	  last = last->next;
+	  last->data = list->data;
+	  list = list->next;
+	}
+    }
+
+  return new_list;
+}
+
+GList*
+g_list_reverse (GList *list)
+{
+  GList *last;
+  
+  last = NULL;
+  while (list)
+    {
+      last = list;
+      list = last->next;
+      last->next = last->prev;
+      last->prev = list;
+    }
+  
+  return last;
+}
+
+GList*
+g_list_nth (GList *list,
+	    guint  n)
+{
+  while ((n-- > 0) && list)
+    list = list->next;
+  
+  return list;
+}
+
+gpointer
+g_list_nth_data (GList     *list,
+		 guint      n)
+{
+  while ((n-- > 0) && list)
+    list = list->next;
+  
+  return list ? list->data : NULL;
+}
+
+GList*
+g_list_find (GList    *list,
+	     gpointer  data)
+{
+  while (list)
+    {
+      if (list->data == data)
+	break;
+      list = list->next;
+    }
+  
+  return list;
+}
+
+GList*
+g_list_find_custom (GList       *list,
+		    gpointer     data,
+		    GCompareFunc func)
+{
+  g_return_val_if_fail (func != NULL, list);
+
+  while (list)
+    {
+      if (! func (list->data, data))
+	return list;
+      list = list->next;
+    }
+
+  return NULL;
+}
+
+
+gint
+g_list_position (GList *list,
+		 GList *link)
+{
+  gint i;
+
+  i = 0;
+  while (list)
+    {
+      if (list == link)
+	return i;
+      i++;
+      list = list->next;
+    }
+
+  return -1;
+}
+
+gint
+g_list_index (GList   *list,
+	      gpointer data)
+{
+  gint i;
+
+  i = 0;
+  while (list)
+    {
+      if (list->data == data)
+	return i;
+      i++;
+      list = list->next;
+    }
+
+  return -1;
+}
+
+GList*
+g_list_last (GList *list)
+{
+  if (list)
+    {
+      while (list->next)
+	list = list->next;
+    }
+  
+  return list;
+}
+
+GList*
+g_list_first (GList *list)
+{
+  if (list)
+    {
+      while (list->prev)
+	list = list->prev;
+    }
+  
+  return list;
+}
+
+guint
+g_list_length (GList *list)
+{
+  guint length;
+  
+  length = 0;
+  while (list)
+    {
+      length++;
+      list = list->next;
+    }
+  
+  return length;
+}
+
+void
+g_list_foreach (GList	 *list,
+		GFunc	  func,
+		gpointer  user_data)
+{
+  while (list)
+    {
+      (*func) (list->data, user_data);
+      list = list->next;
+    }
+}
+
+
+GList*
+g_list_insert_sorted (GList        *list,
+                      gpointer      data,
+                      GCompareFunc  func)
+{
+  GList *tmp_list = list;
+  GList *new_list;
+  gint cmp;
+
+  g_return_val_if_fail (func != NULL, list);
+  
+  if (!list) 
+    {
+      new_list = g_list_alloc();
+      new_list->data = data;
+      return new_list;
+    }
+  
+  cmp = (*func) (data, tmp_list->data);
+  
+  while ((tmp_list->next) && (cmp > 0))
+    {
+      tmp_list = tmp_list->next;
+      cmp = (*func) (data, tmp_list->data);
+    }
+
+  new_list = g_list_alloc();
+  new_list->data = data;
+
+  if ((!tmp_list->next) && (cmp > 0))
+    {
+      tmp_list->next = new_list;
+      new_list->prev = tmp_list;
+      return list;
+    }
+   
+  if (tmp_list->prev)
+    {
+      tmp_list->prev->next = new_list;
+      new_list->prev = tmp_list->prev;
+    }
+  new_list->next = tmp_list;
+  tmp_list->prev = new_list;
+ 
+  if (tmp_list == list)
+    return new_list;
+  else
+    return list;
+}
+
+static GList *
+g_list_sort_merge (GList       *l1, 
+		   GList       *l2,
+		   GCompareFunc compare_func)
+{
+  GList list, *l, *lprev;
+
+  l = &list; 
+  lprev = NULL;
+
+  while (l1 && l2)
+    {
+      if (compare_func (l1->data, l2->data) < 0)
+        {
+	  l->next = l1;
+	  l = l->next;
+	  l->prev = lprev; 
+	  lprev = l;
+	  l1 = l1->next;
+        } 
+      else 
+	{
+	  l->next = l2;
+	  l = l->next;
+	  l->prev = lprev; 
+	  lprev = l;
+	  l2 = l2->next;
+        }
+    }
+  l->next = l1 ? l1 : l2;
+  l->next->prev = l;
+
+  return list.next;
+}
+
+GList* 
+g_list_sort (GList       *list,
+	     GCompareFunc compare_func)
+{
+  GList *l1, *l2;
+  
+  if (!list) 
+    return NULL;
+  if (!list->next) 
+    return list;
+  
+  l1 = list; 
+  l2 = list->next;
+
+  while ((l2 = l2->next) != NULL)
+    {
+      if ((l2 = l2->next) == NULL) 
+	break;
+      l1 = l1->next;
+    }
+  l2 = l1->next; 
+  l1->next = NULL; 
+
+  return g_list_sort_merge (g_list_sort (list, compare_func),
+			    g_list_sort (l2,   compare_func),
+			    compare_func);
+}
+
+GList* 
+g_list_sort2 (GList       *list,
+	      GCompareFunc compare_func)
+{
+  GSList *runs = NULL;
+  GList *tmp;
+
+  /* Degenerate case.  */
+  if (!list) return NULL;
+
+  /* Assume: list = [12,2,4,11,2,4,6,1,1,12].  */
+  for (tmp = list; tmp; )
+    {
+      GList *tmp2;
+      for (tmp2 = tmp;
+	   tmp2->next && compare_func (tmp2->data, tmp2->next->data) <= 0;
+	   tmp2 = tmp2->next)
+	/* Nothing */;
+      runs = g_slist_append (runs, tmp);
+      tmp = tmp2->next;
+      tmp2->next = NULL;
+    }
+  /* Now: runs = [[12],[2,4,11],[2,4,6],[1,1,12]].  */
+  
+  while (runs->next)
+    {
+      /* We have more than one run.  Merge pairwise.  */
+      GSList *dst, *src, *dstprev = NULL;
+      dst = src = runs;
+      while (src && src->next)
+	{
+	  dst->data = g_list_sort_merge (src->data,
+					 src->next->data,
+					 compare_func);
+	  dstprev = dst;
+	  dst = dst->next;
+	  src = src->next->next;
+	}
+
+      /* If number of runs was odd, just keep the last.  */
+      if (src)
+	{
+	  dst->data = src->data;
+	  dstprev = dst;
+	  dst = dst->next;
+	}
+
+      dstprev->next = NULL;
+      g_slist_free (dst);
+    }
+
+  /* After 1st loop: runs = [[2,4,11,12],[1,1,2,4,6,12]].  */
+  /* After 2nd loop: runs = [[1,1,2,2,4,4,6,11,12,12]].  */
+
+  list = runs->data;
+  g_slist_free (runs);
+  return list;
+}
diff -urN linux-2.4.1/net/korbit/kglib/gmem.c linux-2.4.1-korbit/net/korbit/kglib/gmem.c
--- linux-2.4.1/net/korbit/kglib/gmem.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gmem.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,767 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ *
+ * Mutilated on 10/22/00 by Fredrik and Chris
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include "glib.h"
+
+#define MEM_PROFILE_TABLE_SIZE 8192
+#define ENTER_MEM_CHUNK_ROUTINE()
+#define LEAVE_MEM_CHUNK_ROUTINE()
+
+/*
+ * This library can check for some attempts to do illegal things to
+ * memory (ENABLE_MEM_CHECK), and can do profiling
+ * (ENABLE_MEM_PROFILE).  Both features are implemented by storing
+ * words before the start of the memory chunk.
+ *
+ * The first, at offset -2*SIZEOF_LONG, is used only if
+ * ENABLE_MEM_CHECK is set, and stores 0 after the memory has been
+ * allocated and 1 when it has been freed.  The second, at offset
+ * -SIZEOF_LONG, is used if either flag is set and stores the size of
+ * the block.
+ *
+ * The MEM_CHECK flag is checked when memory is realloc'd and free'd,
+ * and it can be explicitly checked before using a block by calling
+ * g_mem_check().
+ */
+
+#define MEM_AREA_SIZE 4L
+
+#define MEM_ALIGN     sizeof(long)
+
+
+typedef struct _GFreeAtom      GFreeAtom;
+typedef struct _GMemArea       GMemArea;
+typedef struct _GRealMemChunk  GRealMemChunk;
+
+struct _GFreeAtom
+{
+  GFreeAtom *next;
+};
+
+struct _GMemArea
+{
+  GMemArea *next;            /* the next mem area */
+  GMemArea *prev;            /* the previous mem area */
+  gulong index;              /* the current index into the "mem" array */
+  gulong free;               /* the number of free bytes in this mem area */
+  gulong allocated;          /* the number of atoms allocated from this area */
+  gulong mark;               /* is this mem area marked for deletion */
+  gchar mem[MEM_AREA_SIZE];  /* the mem array from which atoms get allocated
+			      * the actual size of this array is determined by
+			      *  the mem chunk "area_size". ANSI says that it
+			      *  must be declared to be the maximum size it
+			      *  can possibly be (even though the actual size
+			      *  may be less).
+			      */
+};
+
+struct _GRealMemChunk
+{
+  gchar *name;               /* name of this MemChunk...used for debugging output */
+  gint type;                 /* the type of MemChunk: ALLOC_ONLY or ALLOC_AND_FREE */
+  gint num_mem_areas;        /* the number of memory areas */
+  gint num_marked_areas;     /* the number of areas marked for deletion */
+  guint atom_size;           /* the size of an atom */
+  gulong area_size;          /* the size of a memory area */
+  GMemArea *mem_area;        /* the current memory area */
+  GMemArea *mem_areas;       /* a list of all the mem areas owned by this chunk */
+  GMemArea *free_mem_area;   /* the free area...which is about to be destroyed */
+  GFreeAtom *free_atoms;     /* the free atoms list */
+  GTree *mem_tree;           /* tree of mem areas sorted by memory address */
+  GRealMemChunk *next;       /* pointer to the next chunk */
+  GRealMemChunk *prev;       /* pointer to the previous chunk */
+};
+
+
+static gulong g_mem_chunk_compute_size (gulong    size,
+					gulong    min_size);
+static gint   g_mem_chunk_area_compare (GMemArea *a,
+					GMemArea *b);
+static gint   g_mem_chunk_area_search  (GMemArea *a,
+					gchar    *addr);
+
+
+/* here we can't use StaticMutexes, as they depend upon a working
+ * g_malloc, the same holds true for StaticPrivate */
+#ifndef __KORBIT__
+static GMutex* mem_chunks_lock = NULL;
+#endif /* !__KORBIT__ */
+static GRealMemChunk *mem_chunks = NULL;
+
+
+gpointer
+g_malloc (gulong size)
+{
+  gpointer p;
+  
+  if (size == 0)
+    return NULL;
+  
+  p = (gpointer) malloc (size);
+  if (!p)
+    g_error ("could not allocate %ld bytes", size);
+  
+  return p;
+}
+
+gpointer
+g_malloc0 (gulong size)
+{
+  gpointer p;
+  
+  if (size == 0)
+    return NULL;
+  
+  p = (gpointer) calloc (size, 1);
+  if (!p)
+    g_error ("could not allocate %ld bytes", size);
+  
+  return p;
+}
+
+gpointer
+g_realloc (gpointer mem,
+	   gulong   size)
+{
+  gpointer p;
+  
+  if (size == 0)
+    {
+      g_free (mem);
+    
+      return NULL;
+    }
+  
+  if (!mem)
+    {
+#ifdef REALLOC_0_WORKS
+      p = (gpointer) realloc (NULL, size);
+#else /* !REALLOC_0_WORKS */
+      p = (gpointer) malloc (size);
+#endif /* !REALLOC_0_WORKS */
+    }
+  else
+    {
+      p = (gpointer) realloc (mem, size);
+    }
+  
+  if (!p)
+    g_error ("could not reallocate %lu bytes", (gulong) size);
+  
+  return p;
+}
+
+void
+g_free (gpointer mem)
+{
+  if (mem)
+    {
+      free (mem);
+    }
+}
+
+
+void
+g_mem_profile (void)
+{
+}
+
+void
+g_mem_check (gpointer mem)
+{
+}
+
+GMemChunk*
+g_mem_chunk_new (gchar  *name,
+		 gint    atom_size,
+		 gulong  area_size,
+		 gint    type)
+{
+  GRealMemChunk *mem_chunk;
+  gulong rarea_size;
+
+  g_return_val_if_fail (atom_size > 0, NULL);
+  g_return_val_if_fail (area_size >= atom_size, NULL);
+
+  ENTER_MEM_CHUNK_ROUTINE();
+
+  area_size = (area_size + atom_size - 1) / atom_size;
+  area_size *= atom_size;
+
+  mem_chunk = g_new (struct _GRealMemChunk, 1);
+  mem_chunk->name = name;
+  mem_chunk->type = type;
+  mem_chunk->num_mem_areas = 0;
+  mem_chunk->num_marked_areas = 0;
+  mem_chunk->mem_area = NULL;
+  mem_chunk->free_mem_area = NULL;
+  mem_chunk->free_atoms = NULL;
+  mem_chunk->mem_tree = NULL;
+  mem_chunk->mem_areas = NULL;
+  mem_chunk->atom_size = atom_size;
+  
+  if (mem_chunk->type == G_ALLOC_AND_FREE)
+    mem_chunk->mem_tree = g_tree_new ((GCompareFunc) g_mem_chunk_area_compare);
+  
+  if (mem_chunk->atom_size % MEM_ALIGN)
+    mem_chunk->atom_size += MEM_ALIGN - (mem_chunk->atom_size % MEM_ALIGN);
+
+  rarea_size = area_size + sizeof (GMemArea) - MEM_AREA_SIZE;
+  rarea_size = g_mem_chunk_compute_size (rarea_size, atom_size + sizeof (GMemArea) - MEM_AREA_SIZE);
+  mem_chunk->area_size = rarea_size - (sizeof (GMemArea) - MEM_AREA_SIZE);
+
+#ifndef __KORBIT__
+  g_mutex_lock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  mem_chunk->next = mem_chunks;
+  mem_chunk->prev = NULL;
+  if (mem_chunks)
+    mem_chunks->prev = mem_chunk;
+  mem_chunks = mem_chunk;
+#ifndef __KORBIT__
+  g_mutex_unlock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+
+  LEAVE_MEM_CHUNK_ROUTINE();
+
+  return ((GMemChunk*) mem_chunk);
+}
+
+void
+g_mem_chunk_destroy (GMemChunk *mem_chunk)
+{
+  GRealMemChunk *rmem_chunk;
+  GMemArea *mem_areas;
+  GMemArea *temp_area;
+  
+  g_return_if_fail (mem_chunk != NULL);
+
+  ENTER_MEM_CHUNK_ROUTINE();
+
+  rmem_chunk = (GRealMemChunk*) mem_chunk;
+  
+  mem_areas = rmem_chunk->mem_areas;
+  while (mem_areas)
+    {
+      temp_area = mem_areas;
+      mem_areas = mem_areas->next;
+      g_free (temp_area);
+    }
+  
+  if (rmem_chunk->next)
+    rmem_chunk->next->prev = rmem_chunk->prev;
+  if (rmem_chunk->prev)
+    rmem_chunk->prev->next = rmem_chunk->next;
+  
+#ifndef __KORBIT__
+  g_mutex_lock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  if (rmem_chunk == mem_chunks)
+    mem_chunks = mem_chunks->next;
+#ifndef __KORBIT__
+  g_mutex_unlock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  
+  if (rmem_chunk->type == G_ALLOC_AND_FREE)
+    g_tree_destroy (rmem_chunk->mem_tree);
+  
+  g_free (rmem_chunk);
+
+  LEAVE_MEM_CHUNK_ROUTINE();
+}
+
+gpointer
+g_mem_chunk_alloc (GMemChunk *mem_chunk)
+{
+  GRealMemChunk *rmem_chunk;
+  GMemArea *temp_area;
+  gpointer mem;
+
+  ENTER_MEM_CHUNK_ROUTINE();
+
+  g_return_val_if_fail (mem_chunk != NULL, NULL);
+  
+  rmem_chunk = (GRealMemChunk*) mem_chunk;
+  
+  while (rmem_chunk->free_atoms)
+    {
+      /* Get the first piece of memory on the "free_atoms" list.
+       * We can go ahead and destroy the list node we used to keep
+       *  track of it with and to update the "free_atoms" list to
+       *  point to its next element.
+       */
+      mem = rmem_chunk->free_atoms;
+      rmem_chunk->free_atoms = rmem_chunk->free_atoms->next;
+      
+      /* Determine which area this piece of memory is allocated from */
+      temp_area = g_tree_search (rmem_chunk->mem_tree,
+				 (GSearchFunc) g_mem_chunk_area_search,
+				 mem);
+      
+      /* If the area has been marked, then it is being destroyed.
+       *  (ie marked to be destroyed).
+       * We check to see if all of the segments on the free list that
+       *  reference this area have been removed. This occurs when
+       *  the ammount of free memory is less than the allocatable size.
+       * If the chunk should be freed, then we place it in the "free_mem_area".
+       * This is so we make sure not to free the mem area here and then
+       *  allocate it again a few lines down.
+       * If we don't allocate a chunk a few lines down then the "free_mem_area"
+       *  will be freed.
+       * If there is already a "free_mem_area" then we'll just free this mem area.
+       */
+      if (temp_area->mark)
+        {
+          /* Update the "free" memory available in that area */
+          temp_area->free += rmem_chunk->atom_size;
+	  
+          if (temp_area->free == rmem_chunk->area_size)
+            {
+              if (temp_area == rmem_chunk->mem_area)
+                rmem_chunk->mem_area = NULL;
+	      
+              if (rmem_chunk->free_mem_area)
+                {
+                  rmem_chunk->num_mem_areas -= 1;
+		  
+                  if (temp_area->next)
+                    temp_area->next->prev = temp_area->prev;
+                  if (temp_area->prev)
+                    temp_area->prev->next = temp_area->next;
+                  if (temp_area == rmem_chunk->mem_areas)
+                    rmem_chunk->mem_areas = rmem_chunk->mem_areas->next;
+		  
+		  if (rmem_chunk->type == G_ALLOC_AND_FREE)
+		    g_tree_remove (rmem_chunk->mem_tree, temp_area);
+                  g_free (temp_area);
+                }
+              else
+                rmem_chunk->free_mem_area = temp_area;
+	      
+	      rmem_chunk->num_marked_areas -= 1;
+	    }
+	}
+      else
+        {
+          /* Update the number of allocated atoms count.
+	   */
+          temp_area->allocated += 1;
+	  
+          /* The area wasn't marked...return the memory
+	   */
+	  goto outa_here;
+        }
+    }
+  
+  /* If there isn't a current mem area or the current mem area is out of space
+   *  then allocate a new mem area. We'll first check and see if we can use
+   *  the "free_mem_area". Otherwise we'll just malloc the mem area.
+   */
+  if ((!rmem_chunk->mem_area) ||
+      ((rmem_chunk->mem_area->index + rmem_chunk->atom_size) > rmem_chunk->area_size))
+    {
+      if (rmem_chunk->free_mem_area)
+        {
+          rmem_chunk->mem_area = rmem_chunk->free_mem_area;
+	  rmem_chunk->free_mem_area = NULL;
+        }
+      else
+        {
+	  rmem_chunk->mem_area = (GMemArea*) g_malloc (sizeof (GMemArea) -
+						       MEM_AREA_SIZE +
+						       rmem_chunk->area_size);
+	  
+	  rmem_chunk->num_mem_areas += 1;
+	  rmem_chunk->mem_area->next = rmem_chunk->mem_areas;
+	  rmem_chunk->mem_area->prev = NULL;
+	  
+	  if (rmem_chunk->mem_areas)
+	    rmem_chunk->mem_areas->prev = rmem_chunk->mem_area;
+	  rmem_chunk->mem_areas = rmem_chunk->mem_area;
+	  
+	  if (rmem_chunk->type == G_ALLOC_AND_FREE)
+	    g_tree_insert (rmem_chunk->mem_tree, rmem_chunk->mem_area, rmem_chunk->mem_area);
+        }
+      
+      rmem_chunk->mem_area->index = 0;
+      rmem_chunk->mem_area->free = rmem_chunk->area_size;
+      rmem_chunk->mem_area->allocated = 0;
+      rmem_chunk->mem_area->mark = 0;
+    }
+  
+  /* Get the memory and modify the state variables appropriately.
+   */
+  mem = (gpointer) &rmem_chunk->mem_area->mem[rmem_chunk->mem_area->index];
+  rmem_chunk->mem_area->index += rmem_chunk->atom_size;
+  rmem_chunk->mem_area->free -= rmem_chunk->atom_size;
+  rmem_chunk->mem_area->allocated += 1;
+
+outa_here:
+
+  LEAVE_MEM_CHUNK_ROUTINE();
+
+  return mem;
+}
+
+gpointer
+g_mem_chunk_alloc0 (GMemChunk *mem_chunk)
+{
+  gpointer mem;
+
+  mem = g_mem_chunk_alloc (mem_chunk);
+  if (mem)
+    {
+      GRealMemChunk *rmem_chunk = (GRealMemChunk*) mem_chunk;
+
+      memset (mem, 0, rmem_chunk->atom_size);
+    }
+
+  return mem;
+}
+
+void
+g_mem_chunk_free (GMemChunk *mem_chunk,
+		  gpointer   mem)
+{
+  GRealMemChunk *rmem_chunk;
+  GMemArea *temp_area;
+  GFreeAtom *free_atom;
+  
+  g_return_if_fail (mem_chunk != NULL);
+  g_return_if_fail (mem != NULL);
+
+  ENTER_MEM_CHUNK_ROUTINE();
+
+  rmem_chunk = (GRealMemChunk*) mem_chunk;
+  
+  /* Don't do anything if this is an ALLOC_ONLY chunk
+   */
+  if (rmem_chunk->type == G_ALLOC_AND_FREE)
+    {
+      /* Place the memory on the "free_atoms" list
+       */
+      free_atom = (GFreeAtom*) mem;
+      free_atom->next = rmem_chunk->free_atoms;
+      rmem_chunk->free_atoms = free_atom;
+      
+      temp_area = g_tree_search (rmem_chunk->mem_tree,
+				 (GSearchFunc) g_mem_chunk_area_search,
+				 mem);
+      
+      temp_area->allocated -= 1;
+      
+      if (temp_area->allocated == 0)
+	{
+	  temp_area->mark = 1;
+	  rmem_chunk->num_marked_areas += 1;
+	}
+    }
+
+  LEAVE_MEM_CHUNK_ROUTINE();
+}
+
+/* This doesn't free the free_area if there is one */
+void
+g_mem_chunk_clean (GMemChunk *mem_chunk)
+{
+  GRealMemChunk *rmem_chunk;
+  GMemArea *mem_area;
+  GFreeAtom *prev_free_atom;
+  GFreeAtom *temp_free_atom;
+  gpointer mem;
+  
+  g_return_if_fail (mem_chunk != NULL);
+  
+  rmem_chunk = (GRealMemChunk*) mem_chunk;
+  
+  if (rmem_chunk->type == G_ALLOC_AND_FREE)
+    {
+      prev_free_atom = NULL;
+      temp_free_atom = rmem_chunk->free_atoms;
+      
+      while (temp_free_atom)
+	{
+	  mem = (gpointer) temp_free_atom;
+	  
+	  mem_area = g_tree_search (rmem_chunk->mem_tree,
+				    (GSearchFunc) g_mem_chunk_area_search,
+				    mem);
+	  
+          /* If this mem area is marked for destruction then delete the
+	   *  area and list node and decrement the free mem.
+           */
+	  if (mem_area->mark)
+	    {
+	      if (prev_free_atom)
+		prev_free_atom->next = temp_free_atom->next;
+	      else
+		rmem_chunk->free_atoms = temp_free_atom->next;
+	      temp_free_atom = temp_free_atom->next;
+	      
+	      mem_area->free += rmem_chunk->atom_size;
+	      if (mem_area->free == rmem_chunk->area_size)
+		{
+		  rmem_chunk->num_mem_areas -= 1;
+		  rmem_chunk->num_marked_areas -= 1;
+		  
+		  if (mem_area->next)
+		    mem_area->next->prev = mem_area->prev;
+		  if (mem_area->prev)
+		    mem_area->prev->next = mem_area->next;
+		  if (mem_area == rmem_chunk->mem_areas)
+		    rmem_chunk->mem_areas = rmem_chunk->mem_areas->next;
+		  if (mem_area == rmem_chunk->mem_area)
+		    rmem_chunk->mem_area = NULL;
+		  
+		  if (rmem_chunk->type == G_ALLOC_AND_FREE)
+		    g_tree_remove (rmem_chunk->mem_tree, mem_area);
+		  g_free (mem_area);
+		}
+	    }
+	  else
+	    {
+	      prev_free_atom = temp_free_atom;
+	      temp_free_atom = temp_free_atom->next;
+	    }
+	}
+    }
+}
+
+void
+g_mem_chunk_reset (GMemChunk *mem_chunk)
+{
+  GRealMemChunk *rmem_chunk;
+  GMemArea *mem_areas;
+  GMemArea *temp_area;
+  
+  g_return_if_fail (mem_chunk != NULL);
+  
+  rmem_chunk = (GRealMemChunk*) mem_chunk;
+  
+  mem_areas = rmem_chunk->mem_areas;
+  rmem_chunk->num_mem_areas = 0;
+  rmem_chunk->mem_areas = NULL;
+  rmem_chunk->mem_area = NULL;
+  
+  while (mem_areas)
+    {
+      temp_area = mem_areas;
+      mem_areas = mem_areas->next;
+      g_free (temp_area);
+    }
+  
+  rmem_chunk->free_atoms = NULL;
+  
+  if (rmem_chunk->mem_tree)
+    g_tree_destroy (rmem_chunk->mem_tree);
+  rmem_chunk->mem_tree = g_tree_new ((GCompareFunc) g_mem_chunk_area_compare);
+}
+
+void
+g_mem_chunk_print (GMemChunk *mem_chunk)
+{
+  GRealMemChunk *rmem_chunk;
+  GMemArea *mem_areas;
+  gulong mem;
+  
+  g_return_if_fail (mem_chunk != NULL);
+  
+  rmem_chunk = (GRealMemChunk*) mem_chunk;
+  mem_areas = rmem_chunk->mem_areas;
+  mem = 0;
+  
+  while (mem_areas)
+    {
+      mem += rmem_chunk->area_size - mem_areas->free;
+      mem_areas = mem_areas->next;
+    }
+  
+  g_log (g_log_domain_glib, G_LOG_LEVEL_INFO,
+	 "%s: %ld bytes using %d mem areas",
+	 rmem_chunk->name, mem, rmem_chunk->num_mem_areas);
+}
+
+void
+g_mem_chunk_info (void)
+{
+  GRealMemChunk *mem_chunk;
+  gint count;
+  
+  count = 0;
+#ifndef __KORBIT__
+  g_mutex_lock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  mem_chunk = mem_chunks;
+  while (mem_chunk)
+    {
+      count += 1;
+      mem_chunk = mem_chunk->next;
+    }
+#ifndef __KORBIT__
+  g_mutex_unlock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  g_log (g_log_domain_glib, G_LOG_LEVEL_INFO, "%d mem chunks", count);
+  
+#ifndef __KORBIT__
+  g_mutex_lock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  mem_chunk = mem_chunks;
+#ifndef __KORBIT__
+  g_mutex_unlock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+
+  while (mem_chunk)
+    {
+      g_mem_chunk_print ((GMemChunk*) mem_chunk);
+      mem_chunk = mem_chunk->next;
+    }  
+}
+
+void
+g_blow_chunks (void)
+{
+  GRealMemChunk *mem_chunk;
+  
+#ifndef __KORBIT__
+  g_mutex_lock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  mem_chunk = mem_chunks;
+#ifndef __KORBIT__
+  g_mutex_unlock (mem_chunks_lock);
+#endif /* !__KORBIT__ */
+  while (mem_chunk)
+    {
+      g_mem_chunk_clean ((GMemChunk*) mem_chunk);
+      mem_chunk = mem_chunk->next;
+    }
+}
+
+
+static gulong
+g_mem_chunk_compute_size (gulong size,
+			  gulong min_size)
+{
+  gulong power_of_2;
+  gulong lower, upper;
+  
+  power_of_2 = 16;
+  while (power_of_2 < size)
+    power_of_2 <<= 1;
+  
+  lower = power_of_2 >> 1;
+  upper = power_of_2;
+  
+  if (size - lower < upper - size && lower >= min_size)
+    return lower;
+  else
+    return upper;
+}
+
+static gint
+g_mem_chunk_area_compare (GMemArea *a,
+			  GMemArea *b)
+{
+  if (a->mem > b->mem)
+	return 1;
+  else if (a->mem < b->mem)
+	return -1;
+  return 0;
+}
+
+static gint
+g_mem_chunk_area_search (GMemArea *a,
+			 gchar    *addr)
+{
+  if (a->mem <= addr)
+    {
+      if (addr < &a->mem[a->index])
+	return 0;
+      return 1;
+    }
+  return -1;
+}
+
+/* generic allocators
+ */
+struct _GAllocator /* from gmem.c */
+{
+  gchar		*name;
+  guint16	 n_preallocs;
+  guint		 is_unused : 1;
+  guint		 type : 4;
+  GAllocator	*last;
+  GMemChunk	*mem_chunk;
+  gpointer	 dummy; /* implementation specific */
+};
+
+GAllocator*
+g_allocator_new (const gchar *name,
+		 guint        n_preallocs)
+{
+  GAllocator *allocator;
+
+  g_return_val_if_fail (name != NULL, NULL);
+
+  allocator = g_new0 (GAllocator, 1);
+  allocator->name = g_strdup (name);
+  allocator->n_preallocs = CLAMP (n_preallocs, 1, 65535);
+  allocator->is_unused = TRUE;
+  allocator->type = 0;
+  allocator->last = NULL;
+  allocator->mem_chunk = NULL;
+  allocator->dummy = NULL;
+
+  return allocator;
+}
+
+void
+g_allocator_free (GAllocator *allocator)
+{
+  g_return_if_fail (allocator != NULL);
+  g_return_if_fail (allocator->is_unused == TRUE);
+
+  g_free (allocator->name);
+  if (allocator->mem_chunk)
+    g_mem_chunk_destroy (allocator->mem_chunk);
+
+  g_free (allocator);
+}
+
+void
+g_mem_init (void)
+{
+#ifndef __KORBIT__
+  mem_chunks_lock = g_mutex_new();
+#endif /* !__KORBIT__ */
+}
diff -urN linux-2.4.1/net/korbit/kglib/gprimes.c linux-2.4.1-korbit/net/korbit/kglib/gprimes.c
--- linux-2.4.1/net/korbit/kglib/gprimes.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gprimes.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,79 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include "glib.h"
+
+static const guint g_primes[] =
+{
+  11,
+  19,
+  37,
+  73,
+  109,
+  163,
+  251,
+  367,
+  557,
+  823,
+  1237,
+  1861,
+  2777,
+  4177,
+  6247,
+  9371,
+  14057,
+  21089,
+  31627,
+  47431,
+  71143,
+  106721,
+  160073,
+  240101,
+  360163,
+  540217,
+  810343,
+  1215497,
+  1823231,
+  2734867,
+  4102283,
+  6153409,
+  9230113,
+  13845163,
+};
+
+static const guint g_nprimes = sizeof (g_primes) / sizeof (g_primes[0]);
+
+guint
+g_spaced_primes_closest (guint num)
+{
+  gint i;
+
+  for (i = 0; i < g_nprimes; i++)
+    if (g_primes[i] > num)
+      return g_primes[i];
+
+  return g_primes[g_nprimes - 1];
+}
diff -urN linux-2.4.1/net/korbit/kglib/gslist.c linux-2.4.1-korbit/net/korbit/kglib/gslist.c
--- linux-2.4.1/net/korbit/kglib/gslist.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gslist.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,591 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include "glib.h"
+
+
+struct _GAllocator /* from gmem.c */
+{
+  gchar         *name;
+  guint16        n_preallocs;
+  guint          is_unused : 1;
+  guint          type : 4;
+  GAllocator    *last;
+  GMemChunk     *mem_chunk;
+  GSList        *free_lists; /* implementation specific */
+};
+
+G_LOCK_DEFINE_STATIC (current_allocator);
+static GAllocator       *current_allocator = NULL;
+
+/* HOLDS: current_allocator_lock */
+static void
+g_slist_validate_allocator (GAllocator *allocator)
+{
+  g_return_if_fail (allocator != NULL);
+  g_return_if_fail (allocator->is_unused == TRUE);
+
+  if (allocator->type != G_ALLOCATOR_SLIST)
+    {
+      allocator->type = G_ALLOCATOR_SLIST;
+      if (allocator->mem_chunk)
+	{
+	  g_mem_chunk_destroy (allocator->mem_chunk);
+	  allocator->mem_chunk = NULL;
+	}
+    }
+
+  if (!allocator->mem_chunk)
+    {
+      allocator->mem_chunk = g_mem_chunk_new (allocator->name,
+					      sizeof (GSList),
+					      sizeof (GSList) * allocator->n_preallocs,
+					      G_ALLOC_ONLY);
+      allocator->free_lists = NULL;
+    }
+
+  allocator->is_unused = FALSE;
+}
+
+void
+g_slist_push_allocator (GAllocator *allocator)
+{
+  G_LOCK (current_allocator);
+  g_slist_validate_allocator (allocator);
+  allocator->last = current_allocator;
+  current_allocator = allocator;
+  G_UNLOCK (current_allocator);
+}
+
+void
+g_slist_pop_allocator (void)
+{
+  G_LOCK (current_allocator);
+  if (current_allocator)
+    {
+      GAllocator *allocator;
+
+      allocator = current_allocator;
+      current_allocator = allocator->last;
+      allocator->last = NULL;
+      allocator->is_unused = TRUE;
+    }
+  G_UNLOCK (current_allocator);
+}
+
+GSList*
+g_slist_alloc (void)
+{
+  GSList *list;
+
+  G_LOCK (current_allocator);
+  if (!current_allocator)
+    {
+      GAllocator *allocator = g_allocator_new ("GLib default GSList allocator",
+					       128);
+      g_slist_validate_allocator (allocator);
+      allocator->last = NULL;
+      current_allocator = allocator; 
+    }
+  if (!current_allocator->free_lists)
+    {
+      list = g_chunk_new (GSList, current_allocator->mem_chunk);
+      list->data = NULL;
+    }
+  else
+    {
+      if (current_allocator->free_lists->data)
+	{
+	  list = current_allocator->free_lists->data;
+	  current_allocator->free_lists->data = list->next;
+	  list->data = NULL;
+	}
+      else
+	{
+	  list = current_allocator->free_lists;
+	  current_allocator->free_lists = list->next;
+	}
+    }
+  G_UNLOCK (current_allocator);
+  
+  list->next = NULL;
+
+  return list;
+}
+
+void
+g_slist_free (GSList *list)
+{
+  if (list)
+    {
+      list->data = list->next;
+      G_LOCK (current_allocator);
+      list->next = current_allocator->free_lists;
+      current_allocator->free_lists = list;
+      G_UNLOCK (current_allocator);
+    }
+}
+
+void
+g_slist_free_1 (GSList *list)
+{
+  if (list)
+    {
+      list->data = NULL;
+      G_LOCK (current_allocator);
+      list->next = current_allocator->free_lists;
+      current_allocator->free_lists = list;
+      G_UNLOCK (current_allocator);
+    }
+}
+
+GSList*
+g_slist_append (GSList   *list,
+		gpointer  data)
+{
+  GSList *new_list;
+  GSList *last;
+
+  new_list = g_slist_alloc ();
+  new_list->data = data;
+
+  if (list)
+    {
+      last = g_slist_last (list);
+      /* g_assert (last != NULL); */
+      last->next = new_list;
+
+      return list;
+    }
+  else
+      return new_list;
+}
+
+GSList*
+g_slist_prepend (GSList   *list,
+		 gpointer  data)
+{
+  GSList *new_list;
+
+  new_list = g_slist_alloc ();
+  new_list->data = data;
+  new_list->next = list;
+
+  return new_list;
+}
+
+GSList*
+g_slist_insert (GSList   *list,
+		gpointer  data,
+		gint      position)
+{
+  GSList *prev_list;
+  GSList *tmp_list;
+  GSList *new_list;
+
+  if (position < 0)
+    return g_slist_append (list, data);
+  else if (position == 0)
+    return g_slist_prepend (list, data);
+
+  new_list = g_slist_alloc ();
+  new_list->data = data;
+
+  if (!list)
+    return new_list;
+
+  prev_list = NULL;
+  tmp_list = list;
+
+  while ((position-- > 0) && tmp_list)
+    {
+      prev_list = tmp_list;
+      tmp_list = tmp_list->next;
+    }
+
+  if (prev_list)
+    {
+      new_list->next = prev_list->next;
+      prev_list->next = new_list;
+    }
+  else
+    {
+      new_list->next = list;
+      list = new_list;
+    }
+
+  return list;
+}
+
+GSList *
+g_slist_concat (GSList *list1, GSList *list2)
+{
+  if (list2)
+    {
+      if (list1)
+	g_slist_last (list1)->next = list2;
+      else
+	list1 = list2;
+    }
+
+  return list1;
+}
+
+GSList*
+g_slist_remove (GSList   *list,
+		gpointer  data)
+{
+  GSList *tmp;
+  GSList *prev;
+
+  prev = NULL;
+  tmp = list;
+
+  while (tmp)
+    {
+      if (tmp->data == data)
+	{
+	  if (prev)
+	    prev->next = tmp->next;
+	  if (list == tmp)
+	    list = list->next;
+
+	  tmp->next = NULL;
+	  g_slist_free (tmp);
+
+	  break;
+	}
+
+      prev = tmp;
+      tmp = tmp->next;
+    }
+
+  return list;
+}
+
+GSList*
+g_slist_remove_link (GSList *list,
+		     GSList *link)
+{
+  GSList *tmp;
+  GSList *prev;
+
+  prev = NULL;
+  tmp = list;
+
+  while (tmp)
+    {
+      if (tmp == link)
+	{
+	  if (prev)
+	    prev->next = tmp->next;
+	  if (list == tmp)
+	    list = list->next;
+
+	  tmp->next = NULL;
+	  break;
+	}
+
+      prev = tmp;
+      tmp = tmp->next;
+    }
+
+  return list;
+}
+
+GSList*
+g_slist_copy (GSList *list)
+{
+  GSList *new_list = NULL;
+
+  if (list)
+    {
+      GSList *last;
+
+      new_list = g_slist_alloc ();
+      new_list->data = list->data;
+      last = new_list;
+      list = list->next;
+      while (list)
+	{
+	  last->next = g_slist_alloc ();
+	  last = last->next;
+	  last->data = list->data;
+	  list = list->next;
+	}
+    }
+
+  return new_list;
+}
+
+GSList*
+g_slist_reverse (GSList *list)
+{
+  GSList *prev = NULL;
+
+  while (list)
+    {
+      GSList *next = list->next;
+
+      list->next = prev;
+
+      prev = list;
+      list = next;
+    }
+
+  return prev;
+}
+
+GSList*
+g_slist_nth (GSList *list,
+	     guint   n)
+{
+  while ((n-- > 0) && list)
+    list = list->next;
+
+  return list;
+}
+
+gpointer
+g_slist_nth_data (GSList   *list,
+		  guint     n)
+{
+  while ((n-- > 0) && list)
+    list = list->next;
+
+  return list ? list->data : NULL;
+}
+
+GSList*
+g_slist_find (GSList   *list,
+	      gpointer  data)
+{
+  while (list)
+    {
+      if (list->data == data)
+	break;
+      list = list->next;
+    }
+
+  return list;
+}
+
+GSList*
+g_slist_find_custom (GSList      *list,
+		     gpointer     data,
+		     GCompareFunc func)
+{
+  g_return_val_if_fail (func != NULL, list);
+
+  while (list)
+    {
+      if (! func (list->data, data))
+	return list;
+      list = list->next;
+    }
+
+  return NULL;
+}
+
+gint
+g_slist_position (GSList *list,
+		  GSList *link)
+{
+  gint i;
+
+  i = 0;
+  while (list)
+    {
+      if (list == link)
+	return i;
+      i++;
+      list = list->next;
+    }
+
+  return -1;
+}
+
+gint
+g_slist_index (GSList   *list,
+	       gpointer data)
+{
+  gint i;
+
+  i = 0;
+  while (list)
+    {
+      if (list->data == data)
+	return i;
+      i++;
+      list = list->next;
+    }
+
+  return -1;
+}
+
+GSList*
+g_slist_last (GSList *list)
+{
+  if (list)
+    {
+      while (list->next)
+	list = list->next;
+    }
+
+  return list;
+}
+
+guint
+g_slist_length (GSList *list)
+{
+  guint length;
+
+  length = 0;
+  while (list)
+    {
+      length++;
+      list = list->next;
+    }
+
+  return length;
+}
+
+void
+g_slist_foreach (GSList   *list,
+		 GFunc     func,
+		 gpointer  user_data)
+{
+  while (list)
+    {
+      (*func) (list->data, user_data);
+      list = list->next;
+    }
+}
+
+GSList*
+g_slist_insert_sorted (GSList       *list,
+                       gpointer      data,
+                       GCompareFunc  func)
+{
+  GSList *tmp_list = list;
+  GSList *prev_list = NULL;
+  GSList *new_list;
+  gint cmp;
+ 
+  g_return_val_if_fail (func != NULL, list);
+
+  if (!list)
+    {
+      new_list = g_slist_alloc();
+      new_list->data = data;
+      return new_list;
+    }
+ 
+  cmp = (*func) (data, tmp_list->data);
+ 
+  while ((tmp_list->next) && (cmp > 0))
+    {
+      prev_list = tmp_list;
+      tmp_list = tmp_list->next;
+      cmp = (*func) (data, tmp_list->data);
+    }
+
+  new_list = g_slist_alloc();
+  new_list->data = data;
+
+  if ((!tmp_list->next) && (cmp > 0))
+    {
+      tmp_list->next = new_list;
+      return list;
+    }
+  
+  if (prev_list)
+    {
+      prev_list->next = new_list;
+      new_list->next = tmp_list;
+      return list;
+    }
+  else
+    {
+      new_list->next = list;
+      return new_list;
+    }
+}
+
+static GSList* 
+g_slist_sort_merge  (GSList      *l1, 
+		     GSList      *l2,
+		     GCompareFunc compare_func)
+{
+  GSList list, *l;
+
+  l=&list;
+
+  while (l1 && l2)
+    {
+      if (compare_func(l1->data,l2->data) < 0)
+        {
+	  l=l->next=l1;
+	  l1=l1->next;
+        } 
+      else 
+	{
+	  l=l->next=l2;
+	  l2=l2->next;
+        }
+    }
+  l->next= l1 ? l1 : l2;
+  
+  return list.next;
+}
+
+GSList* 
+g_slist_sort (GSList       *list,
+	      GCompareFunc compare_func)
+{
+  GSList *l1, *l2;
+
+  if (!list) 
+    return NULL;
+  if (!list->next) 
+    return list;
+
+  l1 = list; 
+  l2 = list->next;
+
+  while ((l2 = l2->next) != NULL)
+    {
+      if ((l2 = l2->next) == NULL) 
+	break;
+      l1=l1->next;
+    }
+  l2 = l1->next; 
+  l1->next = NULL;
+
+  return g_slist_sort_merge (g_slist_sort (list, compare_func),
+			     g_slist_sort (l2,   compare_func),
+			     compare_func);
+}
diff -urN linux-2.4.1/net/korbit/kglib/gstrfuncs.c linux-2.4.1-korbit/net/korbit/kglib/gstrfuncs.c
--- linux-2.4.1/net/korbit/kglib/gstrfuncs.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gstrfuncs.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,1308 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include <ctype.h>		/* For tolower() */
+#if !defined (HAVE_STRSIGNAL) || !defined(NO_SYS_SIGLIST_DECL)
+#include <signal.h>
+#endif
+#include "glib.h"
+/* do not include <unistd.h> in this place since it
+ * inteferes with g_strsignal() on some OSes
+ */
+
+gchar*
+g_strdup (const gchar *str) {
+  gchar *new_str;
+
+  if (str)
+    {
+      new_str = g_new (char, strlen (str) + 1);
+      strcpy (new_str, str);
+    }
+  else
+    new_str = NULL;
+
+  return new_str;
+}
+
+gpointer
+g_memdup (gconstpointer mem,
+	  guint         byte_size)
+{
+  gpointer new_mem;
+
+  if (mem)
+    {
+      new_mem = g_malloc (byte_size);
+      memcpy (new_mem, mem, byte_size);
+    }
+  else
+    new_mem = NULL;
+
+  return new_mem;
+}
+
+gchar*
+g_strndup (const gchar *str,
+	   guint        n)
+{
+  gchar *new_str;
+
+  if (str)
+    {
+      new_str = g_new (gchar, n + 1);
+      strncpy (new_str, str, n);
+      new_str[n] = '\0';
+    }
+  else
+    new_str = NULL;
+
+  return new_str;
+}
+
+gchar*
+g_strnfill (guint length,
+	    gchar fill_char)
+{
+  register gchar *str, *s, *end;
+
+  str = g_new (gchar, length + 1);
+  s = str;
+  end = str + length;
+  while (s < end)
+    *(s++) = fill_char;
+  *s = 0;
+
+  return str;
+}
+
+gchar*
+g_strdup_vprintf (const gchar *format,
+		  va_list      args1)
+{
+  gchar *buffer;
+  va_list args2;
+
+  G_VA_COPY (args2, args1);
+
+  buffer = g_new (gchar, g_printf_string_upper_bound (format, args1));
+
+  vsprintf (buffer, format, args2);
+  va_end (args2);
+
+  return buffer;
+}
+
+gchar*
+g_strdup_printf (const gchar *format,
+		 ...)
+{
+  gchar *buffer;
+  va_list args;
+
+  va_start (args, format);
+  buffer = g_strdup_vprintf (format, args);
+  va_end (args);
+
+  return buffer;
+}
+
+gchar*
+g_strconcat (const gchar *string1, ...)
+{
+  guint	  l;
+  va_list args;
+  gchar	  *s;
+  gchar	  *concat;
+
+  g_return_val_if_fail (string1 != NULL, NULL);
+
+  l = 1 + strlen (string1);
+  va_start (args, string1);
+  s = va_arg (args, gchar*);
+  while (s)
+    {
+      l += strlen (s);
+      s = va_arg (args, gchar*);
+    }
+  va_end (args);
+
+  concat = g_new (gchar, l);
+  concat[0] = 0;
+
+  strcat (concat, string1);
+  va_start (args, string1);
+  s = va_arg (args, gchar*);
+  while (s)
+    {
+      strcat (concat, s);
+      s = va_arg (args, gchar*);
+    }
+  va_end (args);
+
+  return concat;
+}
+
+#ifndef __KORBIT__
+gdouble
+g_strtod (const gchar *nptr,
+	  gchar **endptr)
+{
+  gchar *fail_pos_1;
+  gchar *fail_pos_2;
+  gdouble val_1;
+  gdouble val_2 = 0;
+
+  g_return_val_if_fail (nptr != NULL, 0);
+
+  fail_pos_1 = NULL;
+  fail_pos_2 = NULL;
+
+  val_1 = strtod (nptr, &fail_pos_1);
+
+  if (fail_pos_1 && fail_pos_1[0] != 0)
+    {
+      gchar *old_locale;
+
+      old_locale = g_strdup (setlocale (LC_NUMERIC, NULL));
+      setlocale (LC_NUMERIC, "C");
+      val_2 = strtod (nptr, &fail_pos_2);
+      setlocale (LC_NUMERIC, old_locale);
+      g_free (old_locale);
+    }
+
+  if (!fail_pos_1 || fail_pos_1[0] == 0 || fail_pos_1 >= fail_pos_2)
+    {
+      if (endptr)
+	*endptr = fail_pos_1;
+      return val_1;
+    }
+  else
+    {
+      if (endptr)
+	*endptr = fail_pos_2;
+      return val_2;
+    }
+}
+#endif /* !__KORBIT__ */
+
+gchar*
+g_strerror (gint errnum)
+{
+#ifndef __KORBIT__
+  static GStaticPrivate msg_private = G_STATIC_PRIVATE_INIT;
+  char *msg;
+#endif
+
+#ifdef __KORBIT__
+#undef HAVE_STRERROR
+#define NO_SYS_ERRLIST 1
+#endif
+
+#if defined(HAVE_STRERROR)
+  return strerror (errnum);
+#elif NO_SYS_ERRLIST
+  switch (errnum)
+    {
+#ifdef E2BIG
+    case E2BIG: return "argument list too long";
+#endif
+#ifdef EACCES
+    case EACCES: return "permission denied";
+#endif
+#ifdef EADDRINUSE
+    case EADDRINUSE: return "address already in use";
+#endif
+#ifdef EADDRNOTAVAIL
+    case EADDRNOTAVAIL: return "can't assign requested address";
+#endif
+#ifdef EADV
+    case EADV: return "advertise error";
+#endif
+#ifdef EAFNOSUPPORT
+    case EAFNOSUPPORT: return "address family not supported by protocol family";
+#endif
+#ifdef EAGAIN
+    case EAGAIN: return "try again";
+#endif
+#ifdef EALIGN
+    case EALIGN: return "EALIGN";
+#endif
+#ifdef EALREADY
+    case EALREADY: return "operation already in progress";
+#endif
+#ifdef EBADE
+    case EBADE: return "bad exchange descriptor";
+#endif
+#ifdef EBADF
+    case EBADF: return "bad file number";
+#endif
+#ifdef EBADFD
+    case EBADFD: return "file descriptor in bad state";
+#endif
+#ifdef EBADMSG
+    case EBADMSG: return "not a data message";
+#endif
+#ifdef EBADR
+    case EBADR: return "bad request descriptor";
+#endif
+#ifdef EBADRPC
+    case EBADRPC: return "RPC structure is bad";
+#endif
+#ifdef EBADRQC
+    case EBADRQC: return "bad request code";
+#endif
+#ifdef EBADSLT
+    case EBADSLT: return "invalid slot";
+#endif
+#ifdef EBFONT
+    case EBFONT: return "bad font file format";
+#endif
+#ifdef EBUSY
+    case EBUSY: return "mount device busy";
+#endif
+#ifdef ECHILD
+    case ECHILD: return "no children";
+#endif
+#ifdef ECHRNG
+    case ECHRNG: return "channel number out of range";
+#endif
+#ifdef ECOMM
+    case ECOMM: return "communication error on send";
+#endif
+#ifdef ECONNABORTED
+    case ECONNABORTED: return "software caused connection abort";
+#endif
+#ifdef ECONNREFUSED
+    case ECONNREFUSED: return "connection refused";
+#endif
+#ifdef ECONNRESET
+    case ECONNRESET: return "connection reset by peer";
+#endif
+#if defined(EDEADLK) && (!defined(EWOULDBLOCK) || (EDEADLK != EWOULDBLOCK)) && (!defined(EDEADLOCK) || (EDEADLK != EDEADLOCK))
+    case EDEADLK: return "resource deadlock avoided";
+#endif
+#ifdef EDEADLOCK
+    case EDEADLOCK: return "resource deadlock avoided";
+#endif
+#ifdef EDESTADDRREQ
+    case EDESTADDRREQ: return "destination address required";
+#endif
+#ifdef EDIRTY
+    case EDIRTY: return "mounting a dirty fs w/o force";
+#endif
+#ifdef EDOM
+    case EDOM: return "math argument out of range";
+#endif
+#ifdef EDOTDOT
+    case EDOTDOT: return "cross mount point";
+#endif
+#ifdef EDQUOT
+    case EDQUOT: return "disk quota exceeded";
+#endif
+#ifdef EDUPPKG
+    case EDUPPKG: return "duplicate package name";
+#endif
+#ifdef EEXIST
+    case EEXIST: return "file already exists";
+#endif
+#ifdef EFAULT
+    case EFAULT: return "bad address in system call argument";
+#endif
+#ifdef EFBIG
+    case EFBIG: return "file too large";
+#endif
+#ifdef EHOSTDOWN
+    case EHOSTDOWN: return "host is down";
+#endif
+#ifdef EHOSTUNREACH
+    case EHOSTUNREACH: return "host is unreachable";
+#endif
+#ifdef EIDRM
+    case EIDRM: return "identifier removed";
+#endif
+#ifdef EINIT
+    case EINIT: return "initialization error";
+#endif
+#ifdef EINPROGRESS
+    case EINPROGRESS: return "operation now in progress";
+#endif
+#ifdef EINTR
+    case EINTR: return "interrupted system call";
+#endif
+#ifdef EINVAL
+    case EINVAL: return "invalid argument";
+#endif
+#ifdef EIO
+    case EIO: return "I/O error";
+#endif
+#ifdef EISCONN
+    case EISCONN: return "socket is already connected";
+#endif
+#ifdef EISDIR
+    case EISDIR: return "illegal operation on a directory";
+#endif
+#ifdef EISNAME
+    case EISNAM: return "is a name file";
+#endif
+#ifdef ELBIN
+    case ELBIN: return "ELBIN";
+#endif
+#ifdef EL2HLT
+    case EL2HLT: return "level 2 halted";
+#endif
+#ifdef EL2NSYNC
+    case EL2NSYNC: return "level 2 not synchronized";
+#endif
+#ifdef EL3HLT
+    case EL3HLT: return "level 3 halted";
+#endif
+#ifdef EL3RST
+    case EL3RST: return "level 3 reset";
+#endif
+#ifdef ELIBACC
+    case ELIBACC: return "can not access a needed shared library";
+#endif
+#ifdef ELIBBAD
+    case ELIBBAD: return "accessing a corrupted shared library";
+#endif
+#ifdef ELIBEXEC
+    case ELIBEXEC: return "can not exec a shared library directly";
+#endif
+#ifdef ELIBMAX
+    case ELIBMAX: return "attempting to link in more shared libraries than system limit";
+#endif
+#ifdef ELIBSCN
+    case ELIBSCN: return ".lib section in a.out corrupted";
+#endif
+#ifdef ELNRNG
+    case ELNRNG: return "link number out of range";
+#endif
+#ifdef ELOOP
+    case ELOOP: return "too many levels of symbolic links";
+#endif
+#ifdef EMFILE
+    case EMFILE: return "too many open files";
+#endif
+#ifdef EMLINK
+    case EMLINK: return "too many links";
+#endif
+#ifdef EMSGSIZE
+    case EMSGSIZE: return "message too long";
+#endif
+#ifdef EMULTIHOP
+    case EMULTIHOP: return "multihop attempted";
+#endif
+#ifdef ENAMETOOLONG
+    case ENAMETOOLONG: return "file name too long";
+#endif
+#ifdef ENAVAIL
+    case ENAVAIL: return "not available";
+#endif
+#ifdef ENET
+    case ENET: return "ENET";
+#endif
+#ifdef ENETDOWN
+    case ENETDOWN: return "network is down";
+#endif
+#ifdef ENETRESET
+    case ENETRESET: return "network dropped connection on reset";
+#endif
+#ifdef ENETUNREACH
+    case ENETUNREACH: return "network is unreachable";
+#endif
+#ifdef ENFILE
+    case ENFILE: return "file table overflow";
+#endif
+#ifdef ENOANO
+    case ENOANO: return "anode table overflow";
+#endif
+#if defined(ENOBUFS) && (!defined(ENOSR) || (ENOBUFS != ENOSR))
+    case ENOBUFS: return "no buffer space available";
+#endif
+#ifdef ENOCSI
+    case ENOCSI: return "no CSI structure available";
+#endif
+#ifdef ENODATA
+    case ENODATA: return "no data available";
+#endif
+#ifdef ENODEV
+    case ENODEV: return "no such device";
+#endif
+#ifdef ENOENT
+    case ENOENT: return "no such file or directory";
+#endif
+#ifdef ENOEXEC
+    case ENOEXEC: return "exec format error";
+#endif
+#ifdef ENOLCK
+    case ENOLCK: return "no locks available";
+#endif
+#ifdef ENOLINK
+    case ENOLINK: return "link has be severed";
+#endif
+#ifdef ENOMEM
+    case ENOMEM: return "not enough memory";
+#endif
+#ifdef ENOMSG
+    case ENOMSG: return "no message of desired type";
+#endif
+#ifdef ENONET
+    case ENONET: return "machine is not on the network";
+#endif
+#ifdef ENOPKG
+    case ENOPKG: return "package not installed";
+#endif
+#ifdef ENOPROTOOPT
+    case ENOPROTOOPT: return "bad proocol option";
+#endif
+#ifdef ENOSPC
+    case ENOSPC: return "no space left on device";
+#endif
+#ifdef ENOSR
+    case ENOSR: return "out of stream resources";
+#endif
+#ifdef ENOSTR
+    case ENOSTR: return "not a stream device";
+#endif
+#ifdef ENOSYM
+    case ENOSYM: return "unresolved symbol name";
+#endif
+#ifdef ENOSYS
+    case ENOSYS: return "function not implemented";
+#endif
+#ifdef ENOTBLK
+    case ENOTBLK: return "block device required";
+#endif
+#ifdef ENOTCONN
+    case ENOTCONN: return "socket is not connected";
+#endif
+#ifdef ENOTDIR
+    case ENOTDIR: return "not a directory";
+#endif
+#ifdef ENOTEMPTY
+    case ENOTEMPTY: return "directory not empty";
+#endif
+#ifdef ENOTNAM
+    case ENOTNAM: return "not a name file";
+#endif
+#ifdef ENOTSOCK
+    case ENOTSOCK: return "socket operation on non-socket";
+#endif
+#ifdef ENOTTY
+    case ENOTTY: return "inappropriate device for ioctl";
+#endif
+#ifdef ENOTUNIQ
+    case ENOTUNIQ: return "name not unique on network";
+#endif
+#ifdef ENXIO
+    case ENXIO: return "no such device or address";
+#endif
+#ifdef EOPNOTSUPP
+    case EOPNOTSUPP: return "operation not supported on socket";
+#endif
+#ifdef EPERM
+    case EPERM: return "not owner";
+#endif
+#ifdef EPFNOSUPPORT
+    case EPFNOSUPPORT: return "protocol family not supported";
+#endif
+#ifdef EPIPE
+    case EPIPE: return "broken pipe";
+#endif
+#ifdef EPROCLIM
+    case EPROCLIM: return "too many processes";
+#endif
+#ifdef EPROCUNAVAIL
+    case EPROCUNAVAIL: return "bad procedure for program";
+#endif
+#ifdef EPROGMISMATCH
+    case EPROGMISMATCH: return "program version wrong";
+#endif
+#ifdef EPROGUNAVAIL
+    case EPROGUNAVAIL: return "RPC program not available";
+#endif
+#ifdef EPROTO
+    case EPROTO: return "protocol error";
+#endif
+#ifdef EPROTONOSUPPORT
+    case EPROTONOSUPPORT: return "protocol not suppored";
+#endif
+#ifdef EPROTOTYPE
+    case EPROTOTYPE: return "protocol wrong type for socket";
+#endif
+#ifdef ERANGE
+    case ERANGE: return "math result unrepresentable";
+#endif
+#if defined(EREFUSED) && (!defined(ECONNREFUSED) || (EREFUSED != ECONNREFUSED))
+    case EREFUSED: return "EREFUSED";
+#endif
+#ifdef EREMCHG
+    case EREMCHG: return "remote address changed";
+#endif
+#ifdef EREMDEV
+    case EREMDEV: return "remote device";
+#endif
+#ifdef EREMOTE
+    case EREMOTE: return "pathname hit remote file system";
+#endif
+#ifdef EREMOTEIO
+    case EREMOTEIO: return "remote i/o error";
+#endif
+#ifdef EREMOTERELEASE
+    case EREMOTERELEASE: return "EREMOTERELEASE";
+#endif
+#ifdef EROFS
+    case EROFS: return "read-only file system";
+#endif
+#ifdef ERPCMISMATCH
+    case ERPCMISMATCH: return "RPC version is wrong";
+#endif
+#ifdef ERREMOTE
+    case ERREMOTE: return "object is remote";
+#endif
+#ifdef ESHUTDOWN
+    case ESHUTDOWN: return "can't send afer socket shutdown";
+#endif
+#ifdef ESOCKTNOSUPPORT
+    case ESOCKTNOSUPPORT: return "socket type not supported";
+#endif
+#ifdef ESPIPE
+    case ESPIPE: return "invalid seek";
+#endif
+#ifdef ESRCH
+    case ESRCH: return "no such process";
+#endif
+#ifdef ESRMNT
+    case ESRMNT: return "srmount error";
+#endif
+#ifdef ESTALE
+    case ESTALE: return "stale remote file handle";
+#endif
+#ifdef ESUCCESS
+    case ESUCCESS: return "Error 0";
+#endif
+#ifdef ETIME
+    case ETIME: return "timer expired";
+#endif
+#ifdef ETIMEDOUT
+    case ETIMEDOUT: return "connection timed out";
+#endif
+#ifdef ETOOMANYREFS
+    case ETOOMANYREFS: return "too many references: can't splice";
+#endif
+#ifdef ETXTBSY
+    case ETXTBSY: return "text file or pseudo-device busy";
+#endif
+#ifdef EUCLEAN
+    case EUCLEAN: return "structure needs cleaning";
+#endif
+#ifdef EUNATCH
+    case EUNATCH: return "protocol driver not attached";
+#endif
+#ifdef EUSERS
+    case EUSERS: return "too many users";
+#endif
+#ifdef EVERSION
+    case EVERSION: return "version mismatch";
+#endif
+#if defined(EWOULDBLOCK) && (!defined(EAGAIN) || (EWOULDBLOCK != EAGAIN))
+    case EWOULDBLOCK: return "operation would block";
+#endif
+#ifdef EXDEV
+    case EXDEV: return "cross-domain link";
+#endif
+#ifdef EXFULL
+    case EXFULL: return "message tables full";
+#endif
+    }
+#else /* NO_SYS_ERRLIST */
+  extern int sys_nerr;
+  extern char *sys_errlist[];
+
+  if ((errnum > 0) && (errnum <= sys_nerr))
+    return sys_errlist [errnum];
+#endif /* NO_SYS_ERRLIST */
+
+#ifndef __KORBIT__
+  msg = g_static_private_get (&msg_private);
+  if (!msg)
+    {
+      msg = g_new (gchar, 64);
+      g_static_private_set (&msg_private, msg, g_free);
+    }
+
+  sprintf (msg, "unknown error (%d)", errnum);
+
+  return msg;
+#else
+  return "unknown error";
+#endif /* !__KORBIT__ */
+}
+
+gchar*
+g_strsignal (gint signum)
+{
+#ifndef __KORBIT__
+  static GStaticPrivate msg_private = G_STATIC_PRIVATE_INIT;
+  char *msg;
+#endif
+
+#ifdef HAVE_STRSIGNAL
+  extern char *strsignal (int sig);
+  return strsignal (signum);
+#elif NO_SYS_SIGLIST
+  switch (signum)
+    {
+#ifdef SIGHUP
+    case SIGHUP: return "Hangup";
+#endif
+#ifdef SIGINT
+    case SIGINT: return "Interrupt";
+#endif
+#ifdef SIGQUIT
+    case SIGQUIT: return "Quit";
+#endif
+#ifdef SIGILL
+    case SIGILL: return "Illegal instruction";
+#endif
+#ifdef SIGTRAP
+    case SIGTRAP: return "Trace/breakpoint trap";
+#endif
+#ifdef SIGABRT
+    case SIGABRT: return "IOT trap/Abort";
+#endif
+#ifdef SIGBUS
+    case SIGBUS: return "Bus error";
+#endif
+#ifdef SIGFPE
+    case SIGFPE: return "Floating point exception";
+#endif
+#ifdef SIGKILL
+    case SIGKILL: return "Killed";
+#endif
+#ifdef SIGUSR1
+    case SIGUSR1: return "User defined signal 1";
+#endif
+#ifdef SIGSEGV
+    case SIGSEGV: return "Segmentation fault";
+#endif
+#ifdef SIGUSR2
+    case SIGUSR2: return "User defined signal 2";
+#endif
+#ifdef SIGPIPE
+    case SIGPIPE: return "Broken pipe";
+#endif
+#ifdef SIGALRM
+    case SIGALRM: return "Alarm clock";
+#endif
+#ifdef SIGTERM
+    case SIGTERM: return "Terminated";
+#endif
+#ifdef SIGSTKFLT
+    case SIGSTKFLT: return "Stack fault";
+#endif
+#ifdef SIGCHLD
+    case SIGCHLD: return "Child exited";
+#endif
+#ifdef SIGCONT
+    case SIGCONT: return "Continued";
+#endif
+#ifdef SIGSTOP
+    case SIGSTOP: return "Stopped (signal)";
+#endif
+#ifdef SIGTSTP
+    case SIGTSTP: return "Stopped";
+#endif
+#ifdef SIGTTIN
+    case SIGTTIN: return "Stopped (tty input)";
+#endif
+#ifdef SIGTTOU
+    case SIGTTOU: return "Stopped (tty output)";
+#endif
+#ifdef SIGURG
+    case SIGURG: return "Urgent condition";
+#endif
+#ifdef SIGXCPU
+    case SIGXCPU: return "CPU time limit exceeded";
+#endif
+#ifdef SIGXFSZ
+    case SIGXFSZ: return "File size limit exceeded";
+#endif
+#ifdef SIGVTALRM
+    case SIGVTALRM: return "Virtual time alarm";
+#endif
+#ifdef SIGPROF
+    case SIGPROF: return "Profile signal";
+#endif
+#ifdef SIGWINCH
+    case SIGWINCH: return "Window size changed";
+#endif
+#ifdef SIGIO
+    case SIGIO: return "Possible I/O";
+#endif
+#ifdef SIGPWR
+    case SIGPWR: return "Power failure";
+#endif
+#ifdef SIGUNUSED
+    case SIGUNUSED: return "Unused signal";
+#endif
+    }
+#else /* NO_SYS_SIGLIST */
+
+#ifdef NO_SYS_SIGLIST_DECL
+  extern char *sys_siglist[];	/*(see Tue Jan 19 00:44:24 1999 in changelog)*/
+#endif
+
+  return (char*) /* this function should return const --josh */ sys_siglist [signum];
+#endif /* NO_SYS_SIGLIST */
+
+#ifndef __KORBIT__
+  msg = g_static_private_get (&msg_private);
+  if (!msg)
+    {
+      msg = g_new (gchar, 64);
+      g_static_private_set (&msg_private, msg, g_free);
+    }
+
+  sprintf (msg, "unknown signal (%d)", signum);
+
+  return msg;
+#else
+  return "unknown error";
+#endif /* !__KORBIT__ */
+}
+
+guint
+g_printf_string_upper_bound (const gchar* format,
+			     va_list      args)
+{
+  guint len = 1;
+
+  while (*format)
+    {
+      gboolean long_int = FALSE;
+      gboolean extra_long = FALSE;
+      gchar c;
+
+      c = *format++;
+
+      if (c == '%')
+	{
+	  gboolean done = FALSE;
+
+	  while (*format && !done)
+	    {
+	      switch (*format++)
+		{
+		  gchar *string_arg;
+
+		case '*':
+		  len += va_arg (args, int);
+		  break;
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+		  /* add specified format length, since it might exceed the
+		   * size we assume it to have.
+		   */
+		  format -= 1;
+		  len += strtol (format, (char**) &format, 10);
+		  break;
+		case 'h':
+		  /* ignore short int flag, since all args have at least the
+		   * same size as an int
+		   */
+		  break;
+		case 'l':
+		  if (long_int)
+		    extra_long = TRUE; /* linux specific */
+		  else
+		    long_int = TRUE;
+		  break;
+		case 'q':
+		case 'L':
+		  long_int = TRUE;
+		  extra_long = TRUE;
+		  break;
+		case 's':
+		  string_arg = va_arg (args, char *);
+		  if (string_arg)
+		    len += strlen (string_arg);
+		  else
+		    {
+		      /* add enough padding to hold "(null)" identifier */
+		      len += 16;
+		    }
+		  done = TRUE;
+		  break;
+		case 'd':
+		case 'i':
+		case 'o':
+		case 'u':
+		case 'x':
+		case 'X':
+#ifdef	G_HAVE_GINT64
+		  if (extra_long)
+		    (void) va_arg (args, gint64);
+		  else
+#endif	/* G_HAVE_GINT64 */
+		    {
+		      if (long_int)
+			(void) va_arg (args, long);
+		      else
+			(void) va_arg (args, int);
+		    }
+		  len += extra_long ? 64 : 32;
+		  done = TRUE;
+		  break;
+		case 'D':
+		case 'O':
+		case 'U':
+		  (void) va_arg (args, long);
+		  len += 32;
+		  done = TRUE;
+		  break;
+		case 'e':
+		case 'E':
+		case 'f':
+		case 'g':
+#ifdef HAVE_LONG_DOUBLE
+		  if (extra_long)
+		    (void) va_arg (args, long double);
+		  else
+#endif	/* HAVE_LONG_DOUBLE */
+		    (void) va_arg (args, double);
+		  len += extra_long ? 128 : 64;
+		  done = TRUE;
+		  break;
+		case 'c':
+		  (void) va_arg (args, int);
+		  len += 1;
+		  done = TRUE;
+		  break;
+		case 'p':
+		case 'n':
+		  (void) va_arg (args, void*);
+		  len += 32;
+		  done = TRUE;
+		  break;
+		case '%':
+		  len += 1;
+		  done = TRUE;
+		  break;
+		default:
+		  /* ignore unknow/invalid flags */
+		  break;
+		}
+	    }
+	}
+      else
+	len += 1;
+    }
+
+  return len;
+}
+
+void
+g_strdown (gchar *string)
+{
+  register guchar *s;
+
+  g_return_if_fail (string != NULL);
+
+  s = string;
+
+  while (*s)
+    {
+      *s = tolower (*s);
+      s++;
+    }
+}
+
+void
+g_strup (gchar *string)
+{
+  register guchar *s;
+
+  g_return_if_fail (string != NULL);
+
+  s = string;
+
+  while (*s)
+    {
+      *s = toupper (*s);
+      s++;
+    }
+}
+
+void
+g_strreverse (gchar *string)
+{
+  g_return_if_fail (string != NULL);
+
+  if (*string)
+    {
+      register gchar *h, *t;
+
+      h = string;
+      t = string + strlen (string) - 1;
+
+      while (h < t)
+	{
+	  register gchar c;
+
+	  c = *h;
+	  *h = *t;
+	  h++;
+	  *t = c;
+	  t--;
+	}
+    }
+}
+
+gint
+g_strcasecmp (const gchar *s1,
+	      const gchar *s2)
+{
+#ifdef HAVE_STRCASECMP
+  g_return_val_if_fail (s1 != NULL, 0);
+  g_return_val_if_fail (s2 != NULL, 0);
+
+  return strcasecmp (s1, s2);
+#else
+  gint c1, c2;
+
+  g_return_val_if_fail (s1 != NULL, 0);
+  g_return_val_if_fail (s2 != NULL, 0);
+
+  while (*s1 && *s2)
+    {
+      /* According to A. Cox, some platforms have islower's that
+       * don't work right on non-uppercase
+       */
+      c1 = isupper ((guchar)*s1) ? tolower ((guchar)*s1) : *s1;
+      c2 = isupper ((guchar)*s2) ? tolower ((guchar)*s2) : *s2;
+      if (c1 != c2)
+	return (c1 - c2);
+      s1++; s2++;
+    }
+
+  return (((gint)(guchar) *s1) - ((gint)(guchar) *s2));
+#endif
+}
+
+gint
+g_strncasecmp (const gchar *s1,
+	       const gchar *s2,
+	       guint n)
+{
+#ifdef HAVE_STRNCASECMP
+  return strncasecmp (s1, s2, n);
+#else
+  gint c1, c2;
+
+  g_return_val_if_fail (s1 != NULL, 0);
+  g_return_val_if_fail (s2 != NULL, 0);
+
+  while (n-- && *s1 && *s2)
+    {
+      /* According to A. Cox, some platforms have islower's that
+       * don't work right on non-uppercase
+       */
+      c1 = isupper ((guchar)*s1) ? tolower ((guchar)*s1) : *s1;
+      c2 = isupper ((guchar)*s2) ? tolower ((guchar)*s2) : *s2;
+      if (c1 != c2)
+	return (c1 - c2);
+      s1++; s2++;
+    }
+
+  if (n)
+    return (((gint)(guchar) *s1) - ((gint)(guchar) *s2));
+  else
+    return 0;
+#endif
+}
+
+gchar*
+g_strdelimit (gchar	  *string,
+	      const gchar *delimiters,
+	      gchar	   new_delim)
+{
+  register gchar *c;
+
+  g_return_val_if_fail (string != NULL, NULL);
+
+  if (!delimiters)
+    delimiters = G_STR_DELIMITERS;
+
+  for (c = string; *c; c++)
+    {
+      if (strchr (delimiters, *c))
+	*c = new_delim;
+    }
+
+  return string;
+}
+
+gchar*
+g_strescape (gchar *string)
+{
+  gchar *q;
+  gchar *escaped;
+  guint backslashes = 0;
+  gchar *p = string;
+
+  g_return_val_if_fail (string != NULL, NULL);
+
+  while (*p != '\000')
+    backslashes += (*p++ == '\\');
+
+  if (!backslashes)
+    return g_strdup (string);
+
+  escaped = g_new (gchar, strlen (string) + backslashes + 1);
+
+  p = string;
+  q = escaped;
+
+  while (*p != '\000')
+    {
+      if (*p == '\\')
+	*q++ = '\\';
+      *q++ = *p++;
+    }
+  *q = '\000';
+
+  return escaped;
+}
+
+/* blame Elliot for these next five routines */
+gchar*
+g_strchug (gchar *string)
+{
+  guchar *start;
+
+  g_return_val_if_fail (string != NULL, NULL);
+
+  for (start = string; *start && isspace (*start); start++)
+    ;
+
+  g_memmove(string, start, strlen(start) + 1);
+
+  return string;
+}
+
+gchar*
+g_strchomp (gchar *string)
+{
+  gchar *s;
+
+  g_return_val_if_fail (string != NULL, NULL);
+
+  if (!*string)
+    return string;
+
+  for (s = string + strlen (string) - 1; s >= string && isspace ((guchar)*s); 
+       s--)
+    *s = '\0';
+
+  return string;
+}
+
+gchar**
+g_strsplit (const gchar *string,
+	    const gchar *delimiter,
+	    gint         max_tokens)
+{
+  GSList *string_list = NULL, *slist;
+  gchar **str_array, *s;
+  guint i, n = 1;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (delimiter != NULL, NULL);
+
+  if (max_tokens < 1)
+    max_tokens = G_MAXINT;
+
+  s = strstr (string, delimiter);
+  if (s)
+    {
+      guint delimiter_len = strlen (delimiter);
+
+      do
+	{
+	  guint len;
+	  gchar *new_string;
+
+	  len = s - string;
+	  new_string = g_new (gchar, len + 1);
+	  strncpy (new_string, string, len);
+	  new_string[len] = 0;
+	  string_list = g_slist_prepend (string_list, new_string);
+	  n++;
+	  string = s + delimiter_len;
+	  s = strstr (string, delimiter);
+	}
+      while (--max_tokens && s);
+    }
+  if (*string)
+    {
+      n++;
+      string_list = g_slist_prepend (string_list, g_strdup (string));
+    }
+
+  str_array = g_new (gchar*, n);
+
+  i = n - 1;
+
+  str_array[i--] = NULL;
+  for (slist = string_list; slist; slist = slist->next)
+    str_array[i--] = slist->data;
+
+  g_slist_free (string_list);
+
+  return str_array;
+}
+
+void
+g_strfreev (gchar **str_array)
+{
+  if (str_array)
+    {
+      int i;
+
+      for(i = 0; str_array[i] != NULL; i++)
+	g_free(str_array[i]);
+
+      g_free (str_array);
+    }
+}
+
+gchar*
+g_strjoinv (const gchar  *separator,
+	    gchar       **str_array)
+{
+  gchar *string;
+
+  g_return_val_if_fail (str_array != NULL, NULL);
+
+  if (separator == NULL)
+    separator = "";
+
+  if (*str_array)
+    {
+      guint i, len;
+      guint separator_len;
+
+      separator_len = strlen (separator);
+      len = 1 + strlen (str_array[0]);
+      for(i = 1; str_array[i] != NULL; i++)
+	len += separator_len + strlen(str_array[i]);
+
+      string = g_new (gchar, len);
+      *string = 0;
+      strcat (string, *str_array);
+      for (i = 1; str_array[i] != NULL; i++)
+	{
+	  strcat (string, separator);
+	  strcat (string, str_array[i]);
+	}
+      }
+  else
+    string = g_strdup ("");
+
+  return string;
+}
+
+gchar*
+g_strjoin (const gchar  *separator,
+	   ...)
+{
+  gchar *string, *s;
+  va_list args;
+  guint len;
+  guint separator_len;
+
+  if (separator == NULL)
+    separator = "";
+
+  separator_len = strlen (separator);
+
+  va_start (args, separator);
+
+  s = va_arg (args, gchar*);
+
+  if (s)
+    {
+      len = strlen (s);
+      
+      s = va_arg (args, gchar*);
+      while (s)
+	{
+	  len += separator_len + strlen (s);
+	  s = va_arg (args, gchar*);
+	}
+      va_end (args);
+      
+      string = g_new (gchar, len + 1);
+      *string = 0;
+      
+      va_start (args, separator);
+      
+      s = va_arg (args, gchar*);
+      strcat (string, s);
+      
+      s = va_arg (args, gchar*);
+      while (s)
+	{
+	  strcat (string, separator);
+	  strcat (string, s);
+	  s = va_arg (args, gchar*);
+	}
+    }
+  else
+    string = g_strdup ("");
+  
+  va_end (args);
+
+  return string;
+}
diff -urN linux-2.4.1/net/korbit/kglib/gstring.c linux-2.4.1-korbit/net/korbit/kglib/gstring.c
--- linux-2.4.1/net/korbit/kglib/gstring.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gstring.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,508 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include "glib.h"
+
+
+typedef struct _GRealStringChunk GRealStringChunk;
+typedef struct _GRealString      GRealString;
+
+struct _GRealStringChunk
+{
+  GHashTable *const_table;
+  GSList     *storage_list;
+  gint        storage_next;
+  gint        this_size;
+  gint        default_size;
+};
+
+struct _GRealString
+{
+  gchar *str;
+  gint   len;
+  gint   alloc;
+};
+
+G_LOCK_DEFINE_STATIC (string_mem_chunk);
+static GMemChunk *string_mem_chunk = NULL;
+
+/* Hash Functions.
+ */
+
+gint
+g_str_equal (gconstpointer v, gconstpointer v2)
+{
+  return strcmp ((const gchar*) v, (const gchar*)v2) == 0;
+}
+
+/* 31 bit hash function */
+guint
+g_str_hash (gconstpointer key)
+{
+  const char *p = key;
+  guint h = *p;
+  
+  if (h)
+    for (p += 1; *p != '\0'; p++)
+      h = (h << 5) - h + *p;
+  
+  return h;
+}
+
+/* String Chunks.
+ */
+
+GStringChunk*
+g_string_chunk_new (gint default_size)
+{
+  GRealStringChunk *new_chunk = g_new (GRealStringChunk, 1);
+  gint size = 1;
+
+  while (size < default_size)
+    size <<= 1;
+
+  new_chunk->const_table       = NULL;
+  new_chunk->storage_list      = NULL;
+  new_chunk->storage_next      = size;
+  new_chunk->default_size      = size;
+  new_chunk->this_size         = size;
+
+  return (GStringChunk*) new_chunk;
+}
+
+void
+g_string_chunk_free (GStringChunk *fchunk)
+{
+  GRealStringChunk *chunk = (GRealStringChunk*) fchunk;
+  GSList *tmp_list;
+
+  g_return_if_fail (chunk != NULL);
+
+  if (chunk->storage_list)
+    {
+      for (tmp_list = chunk->storage_list; tmp_list; tmp_list = tmp_list->next)
+	g_free (tmp_list->data);
+
+      g_slist_free (chunk->storage_list);
+    }
+
+  if (chunk->const_table)
+    g_hash_table_destroy (chunk->const_table);
+
+  g_free (chunk);
+}
+
+gchar*
+g_string_chunk_insert (GStringChunk *fchunk,
+		       const gchar  *string)
+{
+  GRealStringChunk *chunk = (GRealStringChunk*) fchunk;
+  gint len = strlen (string);
+  char* pos;
+
+  g_return_val_if_fail (chunk != NULL, NULL);
+
+  if ((chunk->storage_next + len + 1) > chunk->this_size)
+    {
+      gint new_size = chunk->default_size;
+
+      while (new_size < len+1)
+	new_size <<= 1;
+
+      chunk->storage_list = g_slist_prepend (chunk->storage_list,
+					     g_new (char, new_size));
+
+      chunk->this_size = new_size;
+      chunk->storage_next = 0;
+    }
+
+  pos = ((char*)chunk->storage_list->data) + chunk->storage_next;
+
+  strcpy (pos, string);
+
+  chunk->storage_next += len + 1;
+
+  return pos;
+}
+
+gchar*
+g_string_chunk_insert_const (GStringChunk *fchunk,
+			     const gchar  *string)
+{
+  GRealStringChunk *chunk = (GRealStringChunk*) fchunk;
+  char* lookup;
+
+  g_return_val_if_fail (chunk != NULL, NULL);
+
+  if (!chunk->const_table)
+    chunk->const_table = g_hash_table_new (g_str_hash, g_str_equal);
+
+  lookup = (char*) g_hash_table_lookup (chunk->const_table, (gchar *)string);
+
+  if (!lookup)
+    {
+      lookup = g_string_chunk_insert (fchunk, string);
+      g_hash_table_insert (chunk->const_table, lookup, lookup);
+    }
+
+  return lookup;
+}
+
+/* Strings.
+ */
+static gint
+nearest_pow (gint num)
+{
+  gint n = 1;
+
+  while (n < num)
+    n <<= 1;
+
+  return n;
+}
+
+static void
+g_string_maybe_expand (GRealString* string, gint len)
+{
+  if (string->len + len >= string->alloc)
+    {
+      string->alloc = nearest_pow (string->len + len + 1);
+      string->str = g_realloc (string->str, string->alloc);
+    }
+}
+
+GString*
+g_string_sized_new (guint dfl_size)
+{
+  GRealString *string;
+
+  G_LOCK (string_mem_chunk);
+  if (!string_mem_chunk)
+    string_mem_chunk = g_mem_chunk_new ("string mem chunk",
+					sizeof (GRealString),
+					1024, G_ALLOC_AND_FREE);
+
+  string = g_chunk_new (GRealString, string_mem_chunk);
+  G_UNLOCK (string_mem_chunk);
+
+  string->alloc = 0;
+  string->len   = 0;
+  string->str   = NULL;
+
+  g_string_maybe_expand (string, MAX (dfl_size, 2));
+  string->str[0] = 0;
+
+  return (GString*) string;
+}
+
+GString*
+g_string_new (const gchar *init)
+{
+  GString *string;
+
+  string = g_string_sized_new (2);
+
+  if (init)
+    g_string_append (string, init);
+
+  return string;
+}
+
+void
+g_string_free (GString *string,
+	       gint free_segment)
+{
+  g_return_if_fail (string != NULL);
+
+  if (free_segment)
+    g_free (string->str);
+
+  G_LOCK (string_mem_chunk);
+  g_mem_chunk_free (string_mem_chunk, string);
+  G_UNLOCK (string_mem_chunk);
+}
+
+GString*
+g_string_assign (GString *lval,
+		 const gchar *rval)
+{
+  g_return_val_if_fail (lval != NULL, NULL);
+  g_return_val_if_fail (rval != NULL, NULL);
+  
+  g_string_truncate (lval, 0);
+  g_string_append (lval, rval);
+
+  return lval;
+}
+
+GString*
+g_string_truncate (GString* fstring,
+		   gint len)
+{
+  GRealString *string = (GRealString*)fstring;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (len >= 0, NULL);
+
+  string->len = len;
+
+  string->str[len] = 0;
+
+  return fstring;
+}
+
+GString*
+g_string_append (GString *fstring,
+		 const gchar *val)
+{
+  GRealString *string = (GRealString*)fstring;
+  int len;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (val != NULL, fstring);
+  
+  len = strlen (val);
+  g_string_maybe_expand (string, len);
+
+  strcpy (string->str + string->len, val);
+
+  string->len += len;
+
+  return fstring;
+}
+
+GString*
+g_string_append_c (GString *fstring,
+		   gchar c)
+{
+  GRealString *string = (GRealString*)fstring;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_string_maybe_expand (string, 1);
+
+  string->str[string->len++] = c;
+  string->str[string->len] = 0;
+
+  return fstring;
+}
+
+GString*
+g_string_prepend (GString *fstring,
+		  const gchar *val)
+{
+  GRealString *string = (GRealString*)fstring;
+  gint len;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (val != NULL, fstring);
+
+  len = strlen (val);
+  g_string_maybe_expand (string, len);
+
+  g_memmove (string->str + len, string->str, string->len);
+
+  strncpy (string->str, val, len);
+
+  string->len += len;
+
+  string->str[string->len] = 0;
+
+  return fstring;
+}
+
+GString*
+g_string_prepend_c (GString *fstring,
+		    gchar    c)
+{
+  GRealString *string = (GRealString*)fstring;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_string_maybe_expand (string, 1);
+
+  g_memmove (string->str + 1, string->str, string->len);
+
+  string->str[0] = c;
+
+  string->len += 1;
+
+  string->str[string->len] = 0;
+
+  return fstring;
+}
+
+GString*
+g_string_insert (GString     *fstring,
+		 gint         pos,
+		 const gchar *val)
+{
+  GRealString *string = (GRealString*)fstring;
+  gint len;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (val != NULL, fstring);
+  g_return_val_if_fail (pos >= 0, fstring);
+  g_return_val_if_fail (pos <= string->len, fstring);
+
+  len = strlen (val);
+  g_string_maybe_expand (string, len);
+
+  g_memmove (string->str + pos + len, string->str + pos, string->len - pos);
+
+  strncpy (string->str + pos, val, len);
+
+  string->len += len;
+
+  string->str[string->len] = 0;
+
+  return fstring;
+}
+
+GString *
+g_string_insert_c (GString *fstring,
+		   gint     pos,
+		   gchar    c)
+{
+  GRealString *string = (GRealString*)fstring;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (pos <= string->len, fstring);
+
+  g_string_maybe_expand (string, 1);
+
+  g_memmove (string->str + pos + 1, string->str + pos, string->len - pos);
+
+  string->str[pos] = c;
+
+  string->len += 1;
+
+  string->str[string->len] = 0;
+
+  return fstring;
+}
+
+GString*
+g_string_erase (GString *fstring,
+		gint pos,
+		gint len)
+{
+  GRealString *string = (GRealString*)fstring;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (len >= 0, fstring);
+  g_return_val_if_fail (pos >= 0, fstring);
+  g_return_val_if_fail (pos <= string->len, fstring);
+  g_return_val_if_fail (pos + len <= string->len, fstring);
+
+  if (pos + len < string->len)
+    g_memmove (string->str + pos, string->str + pos + len, string->len - (pos + len));
+
+  string->len -= len;
+  
+  string->str[string->len] = 0;
+
+  return fstring;
+}
+
+GString*
+g_string_down (GString *fstring)
+{
+  GRealString *string = (GRealString*)fstring;
+  guchar *s;
+
+  g_return_val_if_fail (string != NULL, NULL);
+
+  s = string->str;
+
+  while (*s)
+    {
+      *s = tolower (*s);
+      s++;
+    }
+
+  return fstring;
+}
+
+GString*
+g_string_up (GString *fstring)
+{
+  GRealString *string = (GRealString*)fstring;
+  guchar *s;
+
+  g_return_val_if_fail (string != NULL, NULL);
+
+  s = string->str;
+
+  while (*s)
+    {
+      *s = toupper (*s);
+      s++;
+    }
+
+  return fstring;
+}
+
+static void
+g_string_sprintfa_int (GString     *string,
+		       const gchar *fmt,
+		       va_list      args)
+{
+  gchar *buffer;
+
+  buffer = g_strdup_vprintf (fmt, args);
+  g_string_append (string, buffer);
+  g_free (buffer);
+}
+
+void
+g_string_sprintf (GString *string,
+		  const gchar *fmt,
+		  ...)
+{
+  va_list args;
+
+  g_string_truncate (string, 0);
+
+  va_start (args, fmt);
+  g_string_sprintfa_int (string, fmt, args);
+  va_end (args);
+}
+
+void
+g_string_sprintfa (GString *string,
+		   const gchar *fmt,
+		   ...)
+{
+  va_list args;
+
+  va_start (args, fmt);
+  g_string_sprintfa_int (string, fmt, args);
+  va_end (args);
+}
diff -urN linux-2.4.1/net/korbit/kglib/gtree.c linux-2.4.1-korbit/net/korbit/kglib/gtree.c
--- linux-2.4.1/net/korbit/kglib/gtree.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gtree.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,740 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include "glib.h"
+
+
+typedef struct _GRealTree  GRealTree;
+typedef struct _GTreeNode  GTreeNode;
+
+struct _GRealTree
+{
+  GTreeNode *root;
+  GCompareFunc key_compare;
+};
+
+struct _GTreeNode
+{
+  gint balance;      /* height (left) - height (right) */
+  GTreeNode *left;   /* left subtree */
+  GTreeNode *right;  /* right subtree */
+  gpointer key;      /* key for this node */
+  gpointer value;    /* value stored at this node */
+};
+
+
+static GTreeNode* g_tree_node_new                   (gpointer        key,
+						     gpointer        value);
+static void       g_tree_node_destroy               (GTreeNode      *node);
+static GTreeNode* g_tree_node_insert                (GTreeNode      *node,
+						     GCompareFunc    compare,
+						     gpointer        key,
+						     gpointer        value,
+						     gint           *inserted);
+static GTreeNode* g_tree_node_remove                (GTreeNode      *node,
+						     GCompareFunc    compare,
+						     gpointer        key);
+static GTreeNode* g_tree_node_balance               (GTreeNode      *node);
+static GTreeNode* g_tree_node_remove_leftmost       (GTreeNode      *node,
+						     GTreeNode     **leftmost);
+static GTreeNode* g_tree_node_restore_left_balance  (GTreeNode      *node,
+						     gint            old_balance);
+static GTreeNode* g_tree_node_restore_right_balance (GTreeNode      *node,
+						     gint            old_balance);
+static gpointer   g_tree_node_lookup                (GTreeNode      *node,
+						     GCompareFunc    compare,
+						     gpointer        key);
+static gint       g_tree_node_count                 (GTreeNode      *node);
+static gint       g_tree_node_pre_order             (GTreeNode      *node,
+						     GTraverseFunc   traverse_func,
+						     gpointer        data);
+static gint       g_tree_node_in_order              (GTreeNode      *node,
+						     GTraverseFunc   traverse_func,
+						     gpointer        data);
+static gint       g_tree_node_post_order            (GTreeNode      *node,
+						     GTraverseFunc   traverse_func,
+						     gpointer        data);
+static gpointer   g_tree_node_search                (GTreeNode      *node,
+						     GSearchFunc     search_func,
+						     gpointer        data);
+static gint       g_tree_node_height                (GTreeNode      *node);
+static GTreeNode* g_tree_node_rotate_left           (GTreeNode      *node);
+static GTreeNode* g_tree_node_rotate_right          (GTreeNode      *node);
+static void       g_tree_node_check                 (GTreeNode      *node);
+
+
+G_LOCK_DEFINE_STATIC (g_tree_global);
+static GMemChunk *node_mem_chunk = NULL;
+static GTreeNode *node_free_list = NULL;
+
+
+static GTreeNode*
+g_tree_node_new (gpointer key,
+		 gpointer value)
+{
+  GTreeNode *node;
+
+  G_LOCK (g_tree_global);
+  if (node_free_list)
+    {
+      node = node_free_list;
+      node_free_list = node->right;
+    }
+  else
+    {
+      if (!node_mem_chunk)
+	node_mem_chunk = g_mem_chunk_new ("GLib GTreeNode mem chunk",
+					  sizeof (GTreeNode),
+					  1024,
+					  G_ALLOC_ONLY);
+
+      node = g_chunk_new (GTreeNode, node_mem_chunk);
+   }
+  G_UNLOCK (g_tree_global);
+
+  node->balance = 0;
+  node->left = NULL;
+  node->right = NULL;
+  node->key = key;
+  node->value = value;
+
+  return node;
+}
+
+static void
+g_tree_node_destroy (GTreeNode *node)
+{
+  if (node)
+    {
+      g_tree_node_destroy (node->right);
+      g_tree_node_destroy (node->left);
+      G_LOCK (g_tree_global);
+      node->right = node_free_list;
+      node_free_list = node;
+      G_UNLOCK (g_tree_global);
+   }
+}
+
+
+GTree*
+g_tree_new (GCompareFunc key_compare_func)
+{
+  GRealTree *rtree;
+
+  g_return_val_if_fail (key_compare_func != NULL, NULL);
+
+  rtree = g_new (GRealTree, 1);
+  rtree->root = NULL;
+  rtree->key_compare = key_compare_func;
+
+  return (GTree*) rtree;
+}
+
+void
+g_tree_destroy (GTree *tree)
+{
+  GRealTree *rtree;
+
+  g_return_if_fail (tree != NULL);
+
+  rtree = (GRealTree*) tree;
+
+  g_tree_node_destroy (rtree->root);
+  g_free (rtree);
+}
+
+void
+g_tree_insert (GTree    *tree,
+	       gpointer  key,
+	       gpointer  value)
+{
+  GRealTree *rtree;
+  gint inserted;
+
+  g_return_if_fail (tree != NULL);
+
+  rtree = (GRealTree*) tree;
+
+  inserted = FALSE;
+  rtree->root = g_tree_node_insert (rtree->root, rtree->key_compare,
+				    key, value, &inserted);
+}
+
+void
+g_tree_remove (GTree    *tree,
+	       gpointer  key)
+{
+  GRealTree *rtree;
+
+  g_return_if_fail (tree != NULL);
+
+  rtree = (GRealTree*) tree;
+
+  rtree->root = g_tree_node_remove (rtree->root, rtree->key_compare, key);
+}
+
+gpointer
+g_tree_lookup (GTree    *tree,
+	       gpointer  key)
+{
+  GRealTree *rtree;
+
+  g_return_val_if_fail (tree != NULL, NULL);
+
+  rtree = (GRealTree*) tree;
+
+  return g_tree_node_lookup (rtree->root, rtree->key_compare, key);
+}
+
+void
+g_tree_traverse (GTree         *tree,
+		 GTraverseFunc  traverse_func,
+		 GTraverseType  traverse_type,
+		 gpointer       data)
+{
+  GRealTree *rtree;
+
+  g_return_if_fail (tree != NULL);
+
+  rtree = (GRealTree*) tree;
+
+  if (!rtree->root)
+    return;
+
+  switch (traverse_type)
+    {
+    case G_PRE_ORDER:
+      g_tree_node_pre_order (rtree->root, traverse_func, data);
+      break;
+
+    case G_IN_ORDER:
+      g_tree_node_in_order (rtree->root, traverse_func, data);
+      break;
+
+    case G_POST_ORDER:
+      g_tree_node_post_order (rtree->root, traverse_func, data);
+      break;
+    
+    case G_LEVEL_ORDER:
+      g_warning ("g_tree_traverse(): traverse type G_LEVEL_ORDER isn't implemented.");
+      break;
+    }
+}
+
+gpointer
+g_tree_search (GTree       *tree,
+	       GSearchFunc  search_func,
+	       gpointer     data)
+{
+  GRealTree *rtree;
+
+  g_return_val_if_fail (tree != NULL, NULL);
+
+  rtree = (GRealTree*) tree;
+
+  if (rtree->root)
+    return g_tree_node_search (rtree->root, search_func, data);
+  else
+    return NULL;
+}
+
+gint
+g_tree_height (GTree *tree)
+{
+  GRealTree *rtree;
+
+  g_return_val_if_fail (tree != NULL, 0);
+
+  rtree = (GRealTree*) tree;
+
+  if (rtree->root)
+    return g_tree_node_height (rtree->root);
+  else
+    return 0;
+}
+
+gint
+g_tree_nnodes (GTree *tree)
+{
+  GRealTree *rtree;
+
+  g_return_val_if_fail (tree != NULL, 0);
+
+  rtree = (GRealTree*) tree;
+
+  if (rtree->root)
+    return g_tree_node_count (rtree->root);
+  else
+    return 0;
+}
+
+static GTreeNode*
+g_tree_node_insert (GTreeNode    *node,
+		    GCompareFunc  compare,
+		    gpointer      key,
+		    gpointer      value,
+		    gint         *inserted)
+{
+  gint old_balance;
+  gint cmp;
+
+  if (!node)
+    {
+      *inserted = TRUE;
+      return g_tree_node_new (key, value);
+    }
+
+  cmp = (* compare) (key, node->key);
+  if (cmp == 0)
+    {
+      *inserted = FALSE;
+      node->value = value;
+      return node;
+    }
+
+  if (cmp < 0)
+    {
+      if (node->left)
+	{
+	  old_balance = node->left->balance;
+	  node->left = g_tree_node_insert (node->left, compare, key, value, inserted);
+
+	  if ((old_balance != node->left->balance) && node->left->balance)
+	    node->balance -= 1;
+	}
+      else
+	{
+	  *inserted = TRUE;
+	  node->left = g_tree_node_new (key, value);
+	  node->balance -= 1;
+	}
+    }
+  else if (cmp > 0)
+    {
+      if (node->right)
+	{
+	  old_balance = node->right->balance;
+	  node->right = g_tree_node_insert (node->right, compare, key, value, inserted);
+
+	  if ((old_balance != node->right->balance) && node->right->balance)
+	    node->balance += 1;
+	}
+      else
+	{
+	  *inserted = TRUE;
+	  node->right = g_tree_node_new (key, value);
+	  node->balance += 1;
+	}
+    }
+
+  if (*inserted)
+    {
+      if ((node->balance < -1) || (node->balance > 1))
+	node = g_tree_node_balance (node);
+    }
+
+  return node;
+}
+
+static GTreeNode*
+g_tree_node_remove (GTreeNode    *node,
+		    GCompareFunc  compare,
+		    gpointer      key)
+{
+  GTreeNode *new_root;
+  gint old_balance;
+  gint cmp;
+
+  if (!node)
+    return NULL;
+
+  cmp = (* compare) (key, node->key);
+  if (cmp == 0)
+    {
+      GTreeNode *garbage;
+
+      garbage = node;
+
+      if (!node->right)
+	{
+	  node = node->left;
+	}
+      else
+	{
+	  old_balance = node->right->balance;
+	  node->right = g_tree_node_remove_leftmost (node->right, &new_root);
+	  new_root->left = node->left;
+	  new_root->right = node->right;
+	  new_root->balance = node->balance;
+	  node = g_tree_node_restore_right_balance (new_root, old_balance);
+	}
+
+      G_LOCK (g_tree_global);
+      garbage->right = node_free_list;
+      node_free_list = garbage;
+      G_UNLOCK (g_tree_global);
+   }
+  else if (cmp < 0)
+    {
+      if (node->left)
+	{
+	  old_balance = node->left->balance;
+	  node->left = g_tree_node_remove (node->left, compare, key);
+	  node = g_tree_node_restore_left_balance (node, old_balance);
+	}
+    }
+  else if (cmp > 0)
+    {
+      if (node->right)
+	{
+	  old_balance = node->right->balance;
+	  node->right = g_tree_node_remove (node->right, compare, key);
+	  node = g_tree_node_restore_right_balance (node, old_balance);
+	}
+    }
+
+  return node;
+}
+
+static GTreeNode*
+g_tree_node_balance (GTreeNode *node)
+{
+  if (node->balance < -1)
+    {
+      if (node->left->balance > 0)
+	node->left = g_tree_node_rotate_left (node->left);
+      node = g_tree_node_rotate_right (node);
+    }
+  else if (node->balance > 1)
+    {
+      if (node->right->balance < 0)
+	node->right = g_tree_node_rotate_right (node->right);
+      node = g_tree_node_rotate_left (node);
+    }
+
+  return node;
+}
+
+static GTreeNode*
+g_tree_node_remove_leftmost (GTreeNode  *node,
+			     GTreeNode **leftmost)
+{
+  gint old_balance;
+
+  if (!node->left)
+    {
+      *leftmost = node;
+      return node->right;
+    }
+
+  old_balance = node->left->balance;
+  node->left = g_tree_node_remove_leftmost (node->left, leftmost);
+  return g_tree_node_restore_left_balance (node, old_balance);
+}
+
+static GTreeNode*
+g_tree_node_restore_left_balance (GTreeNode *node,
+				  gint       old_balance)
+{
+  if (!node->left)
+    node->balance += 1;
+  else if ((node->left->balance != old_balance) &&
+	   (node->left->balance == 0))
+    node->balance += 1;
+
+  if (node->balance > 1)
+    return g_tree_node_balance (node);
+  return node;
+}
+
+static GTreeNode*
+g_tree_node_restore_right_balance (GTreeNode *node,
+				   gint       old_balance)
+{
+  if (!node->right)
+    node->balance -= 1;
+  else if ((node->right->balance != old_balance) &&
+	   (node->right->balance == 0))
+    node->balance -= 1;
+
+  if (node->balance < -1)
+    return g_tree_node_balance (node);
+  return node;
+}
+
+static gpointer
+g_tree_node_lookup (GTreeNode    *node,
+		    GCompareFunc  compare,
+		    gpointer      key)
+{
+  gint cmp;
+
+  if (!node)
+    return NULL;
+
+  cmp = (* compare) (key, node->key);
+  if (cmp == 0)
+    return node->value;
+
+  if (cmp < 0)
+    {
+      if (node->left)
+	return g_tree_node_lookup (node->left, compare, key);
+    }
+  else if (cmp > 0)
+    {
+      if (node->right)
+	return g_tree_node_lookup (node->right, compare, key);
+    }
+
+  return NULL;
+}
+
+static gint
+g_tree_node_count (GTreeNode *node)
+{
+  gint count;
+
+  count = 1;
+  if (node->left)
+    count += g_tree_node_count (node->left);
+  if (node->right)
+    count += g_tree_node_count (node->right);
+
+  return count;
+}
+
+static gint
+g_tree_node_pre_order (GTreeNode     *node,
+		       GTraverseFunc  traverse_func,
+		       gpointer       data)
+{
+  if ((*traverse_func) (node->key, node->value, data))
+    return TRUE;
+  if (node->left)
+    {
+      if (g_tree_node_pre_order (node->left, traverse_func, data))
+	return TRUE;
+    }
+  if (node->right)
+    {
+      if (g_tree_node_pre_order (node->right, traverse_func, data))
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gint
+g_tree_node_in_order (GTreeNode     *node,
+		      GTraverseFunc  traverse_func,
+		      gpointer       data)
+{
+  if (node->left)
+    {
+      if (g_tree_node_in_order (node->left, traverse_func, data))
+	return TRUE;
+    }
+  if ((*traverse_func) (node->key, node->value, data))
+    return TRUE;
+  if (node->right)
+    {
+      if (g_tree_node_in_order (node->right, traverse_func, data))
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gint
+g_tree_node_post_order (GTreeNode     *node,
+			GTraverseFunc  traverse_func,
+			gpointer       data)
+{
+  if (node->left)
+    {
+      if (g_tree_node_post_order (node->left, traverse_func, data))
+	return TRUE;
+    }
+  if (node->right)
+    {
+      if (g_tree_node_post_order (node->right, traverse_func, data))
+	return TRUE;
+    }
+  if ((*traverse_func) (node->key, node->value, data))
+    return TRUE;
+
+  return FALSE;
+}
+
+static gpointer
+g_tree_node_search (GTreeNode   *node,
+		    GSearchFunc  search_func,
+		    gpointer     data)
+{
+  gint dir;
+
+  if (!node)
+    return NULL;
+
+  do {
+    dir = (* search_func) (node->key, data);
+    if (dir == 0)
+      return node->value;
+
+    if (dir < 0)
+      node = node->left;
+    else if (dir > 0)
+      node = node->right;
+  } while (node && (dir != 0));
+
+  return NULL;
+}
+
+static gint
+g_tree_node_height (GTreeNode *node)
+{
+  gint left_height;
+  gint right_height;
+
+  if (node)
+    {
+      left_height = 0;
+      right_height = 0;
+
+      if (node->left)
+	left_height = g_tree_node_height (node->left);
+
+      if (node->right)
+	right_height = g_tree_node_height (node->right);
+
+      return MAX (left_height, right_height) + 1;
+    }
+
+  return 0;
+}
+
+static GTreeNode*
+g_tree_node_rotate_left (GTreeNode *node)
+{
+  GTreeNode *left;
+  GTreeNode *right;
+  gint a_bal;
+  gint b_bal;
+
+  left = node->left;
+  right = node->right;
+
+  node->right = right->left;
+  right->left = node;
+
+  a_bal = node->balance;
+  b_bal = right->balance;
+
+  if (b_bal <= 0)
+    {
+      if (a_bal >= 1)
+	right->balance = b_bal - 1;
+      else
+	right->balance = a_bal + b_bal - 2;
+      node->balance = a_bal - 1;
+    }
+  else
+    {
+      if (a_bal <= b_bal)
+	right->balance = a_bal - 2;
+      else
+	right->balance = b_bal - 1;
+      node->balance = a_bal - b_bal - 1;
+    }
+
+  return right;
+}
+
+static GTreeNode*
+g_tree_node_rotate_right (GTreeNode *node)
+{
+  GTreeNode *left;
+  gint a_bal;
+  gint b_bal;
+
+  left = node->left;
+
+  node->left = left->right;
+  left->right = node;
+
+  a_bal = node->balance;
+  b_bal = left->balance;
+
+  if (b_bal <= 0)
+    {
+      if (b_bal > a_bal)
+	left->balance = b_bal + 1;
+      else
+	left->balance = a_bal + 2;
+      node->balance = a_bal - b_bal + 1;
+    }
+  else
+    {
+      if (a_bal <= -1)
+	left->balance = b_bal + 1;
+      else
+	left->balance = a_bal + b_bal + 2;
+      node->balance = a_bal + 1;
+    }
+
+  return left;
+}
+
+static void
+g_tree_node_check (GTreeNode *node)
+{
+  gint left_height;
+  gint right_height;
+  gint balance;
+  
+  if (node)
+    {
+      left_height = 0;
+      right_height = 0;
+      
+      if (node->left)
+	left_height = g_tree_node_height (node->left);
+      if (node->right)
+	right_height = g_tree_node_height (node->right);
+      
+      balance = right_height - left_height;
+      if (balance != node->balance)
+	g_log (g_log_domain_glib, G_LOG_LEVEL_INFO,
+	       "g_tree_node_check: failed: %d ( %d )\n",
+	       balance, node->balance);
+      
+      if (node->left)
+	g_tree_node_check (node->left);
+      if (node->right)
+	g_tree_node_check (node->right);
+    }
+}
diff -urN linux-2.4.1/net/korbit/kglib/gutils.c linux-2.4.1-korbit/net/korbit/kglib/gutils.c
--- linux-2.4.1/net/korbit/kglib/gutils.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/gutils.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1,915 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1998  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#define G_INLINE_FUNC extern
+#define G_CAN_INLINE 1
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#ifdef HAVE_PWD_H
+#include <pwd.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+
+#ifdef NATIVE_WIN32
+#  define STRICT			/* Strict typing, please */
+#  include <windows.h>
+#  include <direct.h>
+#  include <errno.h>
+#  include <ctype.h>
+#  ifdef _MSC_VER
+#    include <io.h>
+#  endif /* _MSC_VER */
+#endif /* NATIVE_WIN32 */
+
+/* implement Glib's inline functions
+ */
+#include "glib.h"
+
+#ifdef	MAXPATHLEN
+#define	G_PATH_LENGTH	(MAXPATHLEN + 1)
+#elif	defined (PATH_MAX)
+#define	G_PATH_LENGTH	(PATH_MAX + 1)
+#else	/* !MAXPATHLEN */
+#define G_PATH_LENGTH   (2048 + 1)
+#endif	/* !MAXPATHLEN && !PATH_MAX */
+
+const guint glib_major_version = 1;
+const guint glib_minor_version = 2;
+const guint glib_micro_version = 8;
+const guint glib_interface_age = 8;
+const guint glib_binary_age = 8;
+
+#if defined (NATIVE_WIN32) && defined (__LCC__)
+int __stdcall 
+LibMain (void         *hinstDll,
+	 unsigned long dwReason,
+	 void         *reserved)
+{
+  return 1;
+}
+#endif /* NATIVE_WIN32 && __LCC__ */
+
+void
+g_atexit (GVoidFunc func)
+{
+  gint result;
+  gchar *error = NULL;
+
+  /* keep this in sync with glib.h */
+
+#ifdef	G_NATIVE_ATEXIT
+  result = ATEXIT (func);
+  if (result)
+    error = g_strerror (errno);
+#elif defined (HAVE_ATEXIT)
+#  ifdef NeXT /* @#%@! NeXTStep */
+  result = !atexit ((void (*)(void)) func);
+  if (result)
+    error = g_strerror (errno);
+#  else
+  result = atexit ((void (*)(void)) func);
+  if (result)
+    error = g_strerror (errno);
+#  endif /* NeXT */
+#elif defined (HAVE_ON_EXIT)
+  result = on_exit ((void (*)(int, void *)) func, NULL);
+  if (result)
+    error = g_strerror (errno);
+#else
+  result = 0;
+  error = "no implementation";
+#endif /* G_NATIVE_ATEXIT */
+
+  if (error)
+    g_error ("Could not register atexit() function: %s", error);
+}
+
+gint
+g_snprintf (gchar	*str,
+	    gulong	 n,
+	    gchar const *fmt,
+	    ...)
+{
+#ifdef	HAVE_VSNPRINTF
+  va_list args;
+  gint retval;
+  
+  g_return_val_if_fail (str != NULL, 0);
+  g_return_val_if_fail (n > 0, 0);
+  g_return_val_if_fail (fmt != NULL, 0);
+
+  va_start (args, fmt);
+  retval = vsnprintf (str, n, fmt, args);
+  va_end (args);
+
+  if (retval < 0)
+    {
+      str[n-1] = '\0';
+      retval = strlen (str);
+    }
+
+  return retval;
+#else	/* !HAVE_VSNPRINTF */
+  gchar *printed;
+  va_list args;
+  
+  g_return_val_if_fail (str != NULL, 0);
+  g_return_val_if_fail (n > 0, 0);
+  g_return_val_if_fail (fmt != NULL, 0);
+
+  va_start (args, fmt);
+  printed = g_strdup_vprintf (fmt, args);
+  va_end (args);
+  
+  strncpy (str, printed, n);
+  str[n-1] = '\0';
+
+  g_free (printed);
+  
+  return strlen (str);
+#endif	/* !HAVE_VSNPRINTF */
+}
+
+gint
+g_vsnprintf (gchar	 *str,
+	     gulong	  n,
+	     gchar const *fmt,
+	     va_list      args)
+{
+#ifdef	HAVE_VSNPRINTF
+  gint retval;
+
+  g_return_val_if_fail (str != NULL, 0);
+  g_return_val_if_fail (n > 0, 0);
+  g_return_val_if_fail (fmt != NULL, 0);
+  
+  retval = vsnprintf (str, n, fmt, args);
+  
+  if (retval < 0)
+    {
+      str[n-1] = '\0';
+      retval = strlen (str);
+    }
+
+  return retval;
+#else	/* !HAVE_VSNPRINTF */
+  gchar *printed;
+  
+  g_return_val_if_fail (str != NULL, 0);
+  g_return_val_if_fail (n > 0, 0);
+  g_return_val_if_fail (fmt != NULL, 0);
+
+  printed = g_strdup_vprintf (fmt, args);
+  strncpy (str, printed, n);
+  str[n-1] = '\0';
+
+  g_free (printed);
+  
+  return strlen (str);
+#endif /* !HAVE_VSNPRINTF */
+}
+
+guint	     
+g_parse_debug_string  (const gchar *string, 
+		       GDebugKey   *keys, 
+		       guint	    nkeys)
+{
+  guint i;
+  guint result = 0;
+  
+  g_return_val_if_fail (string != NULL, 0);
+  
+  if (!g_strcasecmp (string, "all"))
+    {
+      for (i=0; i<nkeys; i++)
+	result |= keys[i].value;
+    }
+  else
+    {
+      gchar *str = g_strdup (string);
+      gchar *p = str;
+      gchar *q;
+      gboolean done = FALSE;
+      
+      while (*p && !done)
+	{
+	  q = strchr (p, ':');
+	  if (!q)
+	    {
+	      q = p + strlen(p);
+	      done = TRUE;
+	    }
+	  
+	  *q = 0;
+	  
+	  for (i=0; i<nkeys; i++)
+	    if (!g_strcasecmp(keys[i].key, p))
+	      result |= keys[i].value;
+	  
+	  p = q+1;
+	}
+      
+      g_free (str);
+    }
+  
+  return result;
+}
+
+gchar*
+g_basename (const gchar	   *file_name)
+{
+  register gchar *base;
+  
+  g_return_val_if_fail (file_name != NULL, NULL);
+  
+  base = strrchr (file_name, G_DIR_SEPARATOR);
+  if (base)
+    return base + 1;
+
+#ifdef NATIVE_WIN32
+  if (isalpha (file_name[0]) && file_name[1] == ':')
+    return (gchar*) file_name + 2;
+#endif /* NATIVE_WIN32 */
+  
+  return (gchar*) file_name;
+}
+
+gboolean
+g_path_is_absolute (const gchar *file_name)
+{
+  g_return_val_if_fail (file_name != NULL, FALSE);
+  
+  if (file_name[0] == G_DIR_SEPARATOR)
+    return TRUE;
+
+#ifdef NATIVE_WIN32
+  if (isalpha (file_name[0]) && file_name[1] == ':' && file_name[2] == G_DIR_SEPARATOR)
+    return TRUE;
+#endif
+
+  return FALSE;
+}
+
+gchar*
+g_path_skip_root (gchar *file_name)
+{
+  g_return_val_if_fail (file_name != NULL, NULL);
+  
+  if (file_name[0] == G_DIR_SEPARATOR)
+    return file_name + 1;
+
+#ifdef NATIVE_WIN32
+  if (isalpha (file_name[0]) && file_name[1] == ':' && file_name[2] == G_DIR_SEPARATOR)
+    return file_name + 3;
+#endif
+
+  return NULL;
+}
+
+gchar*
+g_dirname (const gchar	   *file_name)
+{
+  register gchar *base;
+  register guint len;
+  
+  g_return_val_if_fail (file_name != NULL, NULL);
+  
+  base = strrchr (file_name, G_DIR_SEPARATOR);
+  if (!base)
+    return g_strdup (".");
+  while (base > file_name && *base == G_DIR_SEPARATOR)
+    base--;
+  len = (guint) 1 + base - file_name;
+  
+  base = g_new (gchar, len + 1);
+  g_memmove (base, file_name, len);
+  base[len] = 0;
+  
+  return base;
+}
+
+#ifndef __KORBIT__
+gchar*
+g_get_current_dir (void)
+{
+  gchar *buffer;
+  gchar *dir;
+
+  buffer = g_new (gchar, G_PATH_LENGTH);
+  *buffer = 0;
+  
+  /* We don't use getcwd(3) on SUNOS, because, it does a popen("pwd")
+   * and, if that wasn't bad enough, hangs in doing so.
+   */
+#if	defined (sun) && !defined (__SVR4)
+  dir = getwd (buffer);
+#else	/* !sun */
+  dir = getcwd (buffer, G_PATH_LENGTH - 1);
+#endif	/* !sun */
+  
+  if (!dir || !*buffer)
+    {
+      /* hm, should we g_error() out here?
+       * this can happen if e.g. "./" has mode \0000
+       */
+      buffer[0] = G_DIR_SEPARATOR;
+      buffer[1] = 0;
+    }
+
+  dir = g_strdup (buffer);
+  g_free (buffer);
+  
+  return dir;
+}
+#endif /* !__KORBIT__ */
+
+gchar*
+g_getenv (const gchar *variable)
+{
+#ifndef NATIVE_WIN32
+  g_return_val_if_fail (variable != NULL, NULL);
+
+  return getenv (variable);
+#else
+  gchar *v;
+  guint k;
+  static gchar *p = NULL;
+  static gint l;
+  gchar dummy[2];
+
+  g_return_val_if_fail (variable != NULL, NULL);
+  
+  v = getenv (variable);
+  if (!v)
+    return NULL;
+  
+  /* On Windows NT, it is relatively typical that environment variables
+   * contain references to other environment variables. Handle that by
+   * calling ExpandEnvironmentStrings.
+   */
+
+  /* First check how much space we need */
+  k = ExpandEnvironmentStrings (v, dummy, 2);
+  /* Then allocate that much, and actualy do the expansion */
+  if (p == NULL)
+    {
+      p = g_malloc (k);
+      l = k;
+    }
+  else if (k > l)
+    {
+      p = g_realloc (p, k);
+      l = k;
+    }
+  ExpandEnvironmentStrings (v, p, k);
+  return p;
+#endif
+}
+
+
+G_LOCK_DEFINE_STATIC (g_utils_global);
+
+static	gchar	*g_tmp_dir = NULL;
+static	gchar	*g_user_name = NULL;
+static	gchar	*g_real_name = NULL;
+static	gchar	*g_home_dir = NULL;
+
+/* HOLDS: g_utils_global_lock */
+static void
+g_get_any_init (void)
+{
+  if (!g_tmp_dir)
+    {
+      g_tmp_dir = g_strdup (g_getenv ("TMPDIR"));
+      if (!g_tmp_dir)
+	g_tmp_dir = g_strdup (g_getenv ("TMP"));
+      if (!g_tmp_dir)
+	g_tmp_dir = g_strdup (g_getenv ("TEMP"));
+      
+#ifdef P_tmpdir
+      if (!g_tmp_dir)
+	{
+	  int k;
+	  g_tmp_dir = g_strdup (P_tmpdir);
+	  k = strlen (g_tmp_dir);
+	  if (g_tmp_dir[k-1] == G_DIR_SEPARATOR)
+	    g_tmp_dir[k-1] = '\0';
+	}
+#endif
+      
+      if (!g_tmp_dir)
+	{
+#ifndef NATIVE_WIN32
+	  g_tmp_dir = g_strdup ("/tmp");
+#else /* NATIVE_WIN32 */
+	  g_tmp_dir = g_strdup ("C:\\");
+#endif /* NATIVE_WIN32 */
+	}
+      
+      if (!g_home_dir)
+	g_home_dir = g_strdup (g_getenv ("HOME"));
+      
+#ifdef NATIVE_WIN32
+      if (!g_home_dir)
+	{
+	  /* The official way to specify a home directory on NT is
+	   * the HOMEDRIVE and HOMEPATH environment variables.
+	   *
+	   * This is inside #ifdef NATIVE_WIN32 because with the cygwin dll,
+	   * HOME should be a POSIX style pathname.
+	   */
+	  
+	  if (getenv ("HOMEDRIVE") != NULL && getenv ("HOMEPATH") != NULL)
+	    {
+	      gchar *homedrive, *homepath;
+	      
+	      homedrive = g_strdup (g_getenv ("HOMEDRIVE"));
+	      homepath = g_strdup (g_getenv ("HOMEPATH"));
+	      
+	      g_home_dir = g_strconcat (homedrive, homepath, NULL);
+	      g_free (homedrive);
+	      g_free (homepath);
+	    }
+	}
+#endif /* !NATIVE_WIN32 */
+      
+#ifdef HAVE_PWD_H
+      {
+	struct passwd *pw = NULL;
+	gpointer buffer = NULL;
+	
+#  ifdef HAVE_GETPWUID_R
+        struct passwd pwd;
+        guint bufsize = 64;
+        gint error;
+	
+        do
+          {
+            g_free (buffer);
+            buffer = g_malloc (bufsize);
+	    errno = 0;
+	    
+#    ifdef HAVE_GETPWUID_R_POSIX
+	    error = getpwuid_r (getuid (), &pwd, buffer, bufsize, &pw);
+            error = error < 0 ? errno : error;
+#    else /* !HAVE_GETPWUID_R_POSIX */
+#      ifdef _AIX
+	    error = getpwuid_r (getuid (), &pwd, buffer, bufsize);
+	    pw = error == 0 ? &pwd : NULL;
+#      else /* !_AIX */
+            pw = getpwuid_r (getuid (), &pwd, buffer, bufsize);
+            error = pw ? 0 : errno;
+#      endif /* !_AIX */            
+#    endif /* !HAVE_GETPWUID_R_POSIX */
+	    
+	    if (!pw)
+	      {
+		/* we bail out prematurely if the user id can't be found
+		 * (should be pretty rare case actually), or if the buffer
+		 * should be sufficiently big and lookups are still not
+		 * successfull.
+		 */
+		if (error == 0 || error == ENOENT)
+		  {
+		    g_warning ("getpwuid_r(): failed due to: No such user %d.",
+			       getuid ());
+		    break;
+		  }
+		if (bufsize > 32 * 1024)
+		  {
+		    g_warning ("getpwuid_r(): failed due to: %s.",
+			       g_strerror (error));
+		    break;
+		  }
+		
+		bufsize *= 2;
+	      }
+	  }
+	while (!pw);
+#  endif /* !HAVE_GETPWUID_R */
+	
+	if (!pw)
+	  {
+	    setpwent ();
+	    pw = getpwuid (getuid ());
+	    endpwent ();
+	  }
+	if (pw)
+	  {
+	    g_user_name = g_strdup (pw->pw_name);
+	    g_real_name = g_strdup (pw->pw_gecos);
+	    if (!g_home_dir)
+	      g_home_dir = g_strdup (pw->pw_dir);
+	  }
+	g_free (buffer);
+      }
+      
+#else /* !HAVE_PWD_H */
+      
+#  ifdef NATIVE_WIN32
+      {
+	guint len = 17;
+	gchar buffer[17];
+	
+	if (GetUserName (buffer, &len))
+	  {
+	    g_user_name = g_strdup (buffer);
+	    g_real_name = g_strdup (buffer);
+	  }
+      }
+#  endif /* NATIVE_WIN32 */
+      
+#endif /* !HAVE_PWD_H */
+      
+      if (!g_user_name)
+	g_user_name = g_strdup ("somebody");
+      if (!g_real_name)
+	g_real_name = g_strdup ("Unknown");
+      else
+	{
+	  gchar *p;
+
+	  for (p = g_real_name; *p; p++)
+	    if (*p == ',')
+	      {
+		*p = 0;
+		p = g_strdup (g_real_name);
+		g_free (g_real_name);
+		g_real_name = p;
+		break;
+	      }
+	}
+    }
+}
+
+gchar*
+g_get_user_name (void)
+{
+  G_LOCK (g_utils_global);
+  if (!g_tmp_dir)
+    g_get_any_init ();
+  G_UNLOCK (g_utils_global);
+  
+  return g_user_name;
+}
+
+gchar*
+g_get_real_name (void)
+{
+  G_LOCK (g_utils_global);
+  if (!g_tmp_dir)
+    g_get_any_init ();
+  G_UNLOCK (g_utils_global);
+ 
+  return g_real_name;
+}
+
+/* Return the home directory of the user. If there is a HOME
+ * environment variable, its value is returned, otherwise use some
+ * system-dependent way of finding it out. If no home directory can be
+ * deduced, return NULL.
+ */
+
+gchar*
+g_get_home_dir (void)
+{
+  G_LOCK (g_utils_global);
+  if (!g_tmp_dir)
+    g_get_any_init ();
+  G_UNLOCK (g_utils_global);
+  
+  return g_home_dir;
+}
+
+/* Return a directory to be used to store temporary files. This is the
+ * value of the TMPDIR, TMP or TEMP environment variables (they are
+ * checked in that order). If none of those exist, use P_tmpdir from
+ * stdio.h.  If that isn't defined, return "/tmp" on POSIXly systems,
+ * and C:\ on Windows.
+ */
+
+gchar*
+g_get_tmp_dir (void)
+{
+  G_LOCK (g_utils_global);
+  if (!g_tmp_dir)
+    g_get_any_init ();
+  G_UNLOCK (g_utils_global);
+  
+  return g_tmp_dir;
+}
+
+static gchar *g_prgname = NULL;
+
+gchar*
+g_get_prgname (void)
+{
+  gchar* retval;
+
+  G_LOCK (g_utils_global);
+  retval = g_prgname;
+  G_UNLOCK (g_utils_global);
+
+  return retval;
+}
+
+void
+g_set_prgname (const gchar *prgname)
+{
+  gchar *c;
+    
+  G_LOCK (g_utils_global);
+  c = g_prgname;
+  g_prgname = g_strdup (prgname);
+  g_free (c);
+  G_UNLOCK (g_utils_global);
+}
+
+guint
+g_direct_hash (gconstpointer v)
+{
+  return GPOINTER_TO_UINT (v);
+}
+
+gint
+g_direct_equal (gconstpointer v1,
+		gconstpointer v2)
+{
+  return v1 == v2;
+}
+
+gint
+g_int_equal (gconstpointer v1,
+	     gconstpointer v2)
+{
+  return *((const gint*) v1) == *((const gint*) v2);
+}
+
+guint
+g_int_hash (gconstpointer v)
+{
+  return *(const gint*) v;
+}
+
+#if 0 /* Old IO Channels */
+
+GIOChannel*
+g_iochannel_new (gint fd)
+{
+  GIOChannel *channel = g_new (GIOChannel, 1);
+
+  channel->fd = fd;
+
+#ifdef NATIVE_WIN32
+  channel->peer = 0;
+  channel->peer_fd = 0;
+  channel->offset = 0;
+  channel->need_wakeups = 0;
+#endif /* NATIVE_WIN32 */
+
+  return channel;
+}
+
+void
+g_iochannel_free (GIOChannel *channel)
+{
+  g_return_if_fail (channel != NULL);
+
+  g_free (channel);
+}
+
+void
+g_iochannel_close_and_free (GIOChannel *channel)
+{
+  g_return_if_fail (channel != NULL);
+
+  close (channel->fd);
+
+  g_iochannel_free (channel);
+}
+
+#undef g_iochannel_wakeup_peer
+
+void
+g_iochannel_wakeup_peer (GIOChannel *channel)
+{
+#ifdef NATIVE_WIN32
+  static guint message = 0;
+#endif
+
+  g_return_if_fail (channel != NULL);
+
+#ifdef NATIVE_WIN32
+  if (message == 0)
+    message = RegisterWindowMessage ("gdk-pipe-readable");
+
+#  if 0
+  g_print ("g_iochannel_wakeup_peer: calling PostThreadMessage (%#x, %d, %d, %d)\n",
+	   channel->peer, message, channel->peer_fd, channel->offset);
+#  endif
+  PostThreadMessage (channel->peer, message,
+		     channel->peer_fd, channel->offset);
+#endif /* NATIVE_WIN32 */
+}
+
+#endif /* Old IO Channels */
+
+#ifdef NATIVE_WIN32
+#ifdef _MSC_VER
+
+int
+gwin_ftruncate (gint  fd,
+		guint size)
+{
+  HANDLE hfile;
+  guint curpos;
+
+  g_return_val_if_fail (fd >= 0, -1);
+  
+  hfile = (HANDLE) _get_osfhandle (fd);
+  curpos = SetFilePointer (hfile, 0, NULL, FILE_CURRENT);
+  if (curpos == 0xFFFFFFFF
+      || SetFilePointer (hfile, size, NULL, FILE_BEGIN) == 0xFFFFFFFF
+      || !SetEndOfFile (hfile))
+    {
+      gint error = GetLastError ();
+
+      switch (error)
+	{
+	case ERROR_INVALID_HANDLE:
+	  errno = EBADF;
+	  break;
+	default:
+	  errno = EIO;
+	  break;
+	}
+
+      return -1;
+    }
+
+  return 0;
+}
+
+DIR*
+gwin_opendir (const char *dirname)
+{
+  DIR *result;
+  gchar *mask;
+  guint k;
+
+  g_return_val_if_fail (dirname != NULL, NULL);
+
+  result = g_new0 (DIR, 1);
+  result->find_file_data = g_new0 (WIN32_FIND_DATA, 1);
+  result->dir_name = g_strdup (dirname);
+  
+  k = strlen (result->dir_name);
+  if (k && result->dir_name[k - 1] == '\\')
+    {
+      result->dir_name[k - 1] = '\0';
+      k--;
+    }
+  mask = g_strdup_printf ("%s\\*", result->dir_name);
+
+  result->find_file_handle = (guint) FindFirstFile (mask,
+					     (LPWIN32_FIND_DATA) result->find_file_data);
+  g_free (mask);
+
+  if (result->find_file_handle == (guint) INVALID_HANDLE_VALUE)
+    {
+      int error = GetLastError ();
+
+      g_free (result->dir_name);
+      g_free (result->find_file_data);
+      g_free (result);
+      switch (error)
+	{
+	default:
+	  errno = EIO;
+	  return NULL;
+	}
+    }
+  result->just_opened = TRUE;
+
+  return result;
+}
+
+struct dirent*
+gwin_readdir (DIR *dir)
+{
+  static struct dirent result;
+
+  g_return_val_if_fail (dir != NULL, NULL);
+
+  if (dir->just_opened)
+    dir->just_opened = FALSE;
+  else
+    {
+      if (!FindNextFile ((HANDLE) dir->find_file_handle,
+			 (LPWIN32_FIND_DATA) dir->find_file_data))
+	{
+	  int error = GetLastError ();
+
+	  switch (error)
+	    {
+	    case ERROR_NO_MORE_FILES:
+	      return NULL;
+	    default:
+	      errno = EIO;
+	      return NULL;
+	    }
+	}
+    }
+  strcpy (result.d_name, g_basename (((LPWIN32_FIND_DATA) dir->find_file_data)->cFileName));
+      
+  return &result;
+}
+
+void
+gwin_rewinddir (DIR *dir)
+{
+  gchar *mask;
+
+  g_return_if_fail (dir != NULL);
+
+  if (!FindClose ((HANDLE) dir->find_file_handle))
+    g_warning ("gwin_rewinddir(): FindClose() failed\n");
+
+  mask = g_strdup_printf ("%s\\*", dir->dir_name);
+  dir->find_file_handle = (guint) FindFirstFile (mask,
+					  (LPWIN32_FIND_DATA) dir->find_file_data);
+  g_free (mask);
+
+  if (dir->find_file_handle == (guint) INVALID_HANDLE_VALUE)
+    {
+      int error = GetLastError ();
+
+      switch (error)
+	{
+	default:
+	  errno = EIO;
+	  return;
+	}
+    }
+  dir->just_opened = TRUE;
+}  
+
+gint
+gwin_closedir (DIR *dir)
+{
+  g_return_val_if_fail (dir != NULL, -1);
+
+  if (!FindClose ((HANDLE) dir->find_file_handle))
+    {
+      int error = GetLastError ();
+
+      switch (error)
+	{
+	default:
+	  errno = EIO; return -1;
+	}
+    }
+
+  g_free (dir->dir_name);
+  g_free (dir->find_file_data);
+  g_free (dir);
+
+  return 0;
+}
+
+#endif /* _MSC_VER */
+
+#endif /* NATIVE_WIN32 */
diff -urN linux-2.4.1/net/korbit/kglib/korbit_errno.c linux-2.4.1-korbit/net/korbit/kglib/korbit_errno.c
--- linux-2.4.1/net/korbit/kglib/korbit_errno.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/kglib/korbit_errno.c	Thu Feb  1 11:46:57 2001
@@ -0,0 +1 @@
+int korbit_errno;
diff -urN linux-2.4.1/net/korbit/korbit.h linux-2.4.1-korbit/net/korbit/korbit.h
--- linux-2.4.1/net/korbit/korbit.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/korbit.h	Thu Feb  1 11:46:49 2001
@@ -0,0 +1,53 @@
+
+#ifndef KORBIT_H
+#define KORBIT_H
+
+#ifdef __KERNEL__
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#endif
+
+#include "stdlib.h"
+
+#ifdef __KERNEL__
+static int korbit_get_ior_func(char *buffer, char **start, off_t offset,
+			       int length, int *eof, void *data) {
+  int Len = strlen((char*)data);
+  memcpy(buffer, data, Len);  // Data is the ior...
+  buffer[Len++] = '\n';       // Add a newline to make fredrik happy
+  buffer[Len] = 0;            // Null terminate the buffer...
+  *start = buffer + offset;
+  *eof = 1;
+
+  Len -= offset;
+  if (Len > length)
+    Len = length;
+  if (Len < 0)
+    Len = 0;
+
+  return Len;
+}
+
+#endif
+
+
+static inline void korbit_register_ior(const char *name, CORBA_Object obj, 
+				       CORBA_ORB orb, CORBA_Environment *ev) {
+  char *retval = CORBA_ORB_object_to_string(orb, obj, ev);
+#if defined(__KERNEL__) && defined(CONFIG_PROC_FS)
+  char *procdirname = malloc(strlen(name)+7); // 7 = len("corba/\0")
+  strcpy(procdirname, "corba/");
+  strcpy(procdirname+6, name);
+
+  create_proc_read_entry(procdirname, 0, 0, korbit_get_ior_func, retval);
+
+  free(procdirname);
+  // Don't free the ior in the /proc handling case...
+#else
+  // No procfs support, just print to console... :(
+  g_print("%s IOR:\n%s\n", name, retval);
+  CORBA_free(retval);
+#endif
+}
+#endif
diff -urN linux-2.4.1/net/korbit/modules/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CVS/Entries	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,5 @@
+/Config.in/1.8/Thu Feb  1 09:46:58 2001//
+/Makefile/1.8/Thu Feb  1 09:46:58 2001//
+/Makefile.module/1.2/Thu Feb  1 09:46:58 2001//
+/README/1.1/Thu Feb  1 09:46:58 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CVS/Entries.Log	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,6 @@
+A D/CharDev////
+A D/Console////
+A D/CorbaFS////
+A D/Echo////
+A D/FileServer////
+A D/UserFS////
diff -urN linux-2.4.1/net/korbit/modules/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CVS/Repository	Thu Feb  1 11:46:57 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules
diff -urN linux-2.4.1/net/korbit/modules/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CVS/Root
--- linux-2.4.1/net/korbit/modules/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CVS/Root	Thu Feb  1 11:46:57 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CharDev/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CharDev/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Entries	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,4 @@
+/Makefile/1.3/Thu Feb  1 09:46:58 2001//
+/README/1.1/Thu Feb  1 09:46:58 2001//
+/chardev.idl/1.1/Thu Feb  1 09:46:58 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CharDev/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/CharDev/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Entries.Log	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,3 @@
+A D/kernel////
+A D/kernel-perl////
+A D/userspace////
diff -urN linux-2.4.1/net/korbit/modules/CharDev/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CharDev/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Repository	Thu Feb  1 11:46:58 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CharDev
diff -urN linux-2.4.1/net/korbit/modules/CharDev/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Root
--- linux-2.4.1/net/korbit/modules/CharDev/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/CVS/Root	Thu Feb  1 11:46:58 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CharDev/Makefile linux-2.4.1-korbit/net/korbit/modules/CharDev/Makefile
--- linux-2.4.1/net/korbit/modules/CharDev/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/Makefile	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,11 @@
+#
+# Makefile for KORBit - CharDev
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+subdir-$(CONFIG_CORBA_CHARDEV) := kernel
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/CharDev/README linux-2.4.1-korbit/net/korbit/modules/CharDev/README
--- linux-2.4.1/net/korbit/modules/CharDev/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/README	Thu Feb  1 11:46:58 2001
@@ -0,0 +1 @@
+This module is used to implement a character device with kORBit.
diff -urN linux-2.4.1/net/korbit/modules/CharDev/chardev.idl linux-2.4.1-korbit/net/korbit/modules/CharDev/chardev.idl
--- linux-2.4.1/net/korbit/modules/CharDev/chardev.idl	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/chardev.idl	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,5 @@
+typedef sequence<octet> Buffer;
+
+interface CharDev {
+    long read(out Buffer buffer, in long size);
+};
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CharDev/kernel/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/CVS/Entries	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,4 @@
+/Makefile/1.2/Thu Feb  1 09:46:59 2001//
+/README/1.2/Thu Feb  1 09:46:59 2001//
+/chardev-kernel.c/1.9/Thu Feb  1 09:46:59 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CharDev/kernel/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/CVS/Repository	Thu Feb  1 11:46:59 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CharDev/kernel
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/CVS/Root
--- linux-2.4.1/net/korbit/modules/CharDev/kernel/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/CVS/Root	Thu Feb  1 11:46:59 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel/Makefile linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/Makefile
--- linux-2.4.1/net/korbit/modules/CharDev/kernel/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/Makefile	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,20 @@
+#
+# Makefile for KORBit / chardev
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := corba-chardev-kernel.o
+
+obj-y := chardev-common.o chardev-stubs.o chardev-kernel.o
+obj-m := $(O_TARGET)
+
+include ../../Makefile.module
+
+chardev-kernel.c: chardev.h
+
+chardev.h chardev-stubs.c chardev-common.c: ../chardev.idl
+	$(ORBIT_IDL) ../chardev.idl
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel/README linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/README
--- linux-2.4.1/net/korbit/modules/CharDev/kernel/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/README	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,5 @@
+This module is used to implement the kernel side of the CORBA Character 
+device.
+
+ORB: kORBit
+Status: Working!!!
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel/chardev-kernel.c linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/chardev-kernel.c
--- linux-2.4.1/net/korbit/modules/CharDev/kernel/chardev-kernel.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel/chardev-kernel.c	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,140 @@
+//-----------------------------------------------------------------------------
+//
+// chardev-kernel - Kernel miscdevice to CORBA glue.
+//
+// This file implements a standard Linux Kernel "miscdevice".  This device 
+// operates by forwarding all calls across to a remote CORBA server.  This
+// server is located by reading the file /tmp/chardev-ior at the time the 
+// device is opened.  The device exported is major #10, minor #42.  Create this
+// device with 'mknod' like all the others.
+//
+// No implementations of CORBA functions should block, although I think it 
+// might be just fine, I'm not sure.  Let's just make this a TODO.  :) -CAL
+//
+// TODO: Locking, finish exporting all "miscdevice" functions, send position
+//       on READ request.
+//
+// History:
+//   Keith Wessel  - Initial hack, initial idea
+//   Andy Reitz    - Get it to compile
+//   Chris Lattner - Make it work.  :)
+//
+//-----------------------------------------------------------------------------
+
+
+#include "chardev.h"
+#include <stdio.h>
+#include "orb/orbit.h"
+#include "korbit.h"
+#include <linux/miscdevice.h>
+
+#define DEV_MINOR 42
+
+CORBA_ORB               orb;
+CORBA_Environment       *ev;
+
+static int open_dev(struct inode *inode, struct file *file) {
+  char *iorstr = (char *)malloc(10240);
+  int error = -EINVAL;
+  int fd, len;
+  
+  if (iorstr == 0) return -ENOMEM;
+  
+  if ((fd = open ("/tmp/chardev-ior", O_RDONLY, 0)) == -1) {
+    printk("kORBit: chararacter driver couldn't open /tmp/chardev-ior!\n");
+    goto outfree;
+  }
+
+  len = read(fd, iorstr, 10240);
+  close(fd);
+  if (len == -1) 
+    goto outfree;
+  
+  iorstr[len] = 0; // Null terminate string!
+  
+  printk("CharDEV IOR String = %s\n", iorstr);
+  file->private_data = (void*)CORBA_ORB_string_to_object(orb, iorstr, ev);
+  if (!file->private_data)
+    goto outfree;
+
+  // TODO: Send create_dev message out over CORBA
+  
+  error = 0;
+ outfree:
+  free(iorstr);
+  return error;
+}
+
+static int release_dev(struct inode *inode, struct file *file) {
+  // TODO: Send release_dev message out over CORBA...
+  if (file->private_data)
+    CORBA_free(file->private_data);
+  return 0;
+}
+
+
+static ssize_t read_dev(struct file * file, char * buf, size_t count, 
+			loff_t *ppos) {
+  Buffer *octet_buffer = NULL;
+  if (!file->private_data) return -EINVAL;
+  if (!count) return 0;
+
+  if (!access_ok(VERIFY_WRITE, buf, count))
+    return -EFAULT;
+  
+  CharDev_read(file->private_data, &octet_buffer, count, ev);
+  
+  if (!octet_buffer)
+    return -EPERM;
+  
+  if (copy_to_user(buf, octet_buffer->_buffer, octet_buffer->_length))
+    return -EFAULT;
+
+  // TODO: Should free octet_buffer here!?!?!?
+
+  return octet_buffer->_length;
+}
+
+
+//-----------------------------------------------------------------------------
+//                      Kernel Callbacks for miscdevice
+//-----------------------------------------------------------------------------
+
+
+static struct file_operations dev_fops = {
+  owner:   THIS_MODULE,
+  open:    open_dev,
+  read:    read_dev,
+  release: release_dev,
+  // mmap: mmap_dev,
+  // llseek: llseek_dev,
+  // write: write_dev,
+};
+
+static struct miscdevice cdev = {
+  DEV_MINOR,
+  "CORBA Character device",
+  &dev_fops
+};
+
+
+//-----------------------------------------------------------------------------
+//                     Module Initializion/Finalization
+//-----------------------------------------------------------------------------
+
+static int __init CharDev_init(void) {
+  int argc = 1; 
+  char *argv[] = { "CharDev-kernel", 0 };
+  ev = g_new0(CORBA_Environment,1);
+  orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", ev);
+  
+  // Register the device
+  return misc_register(&cdev);
+}
+
+static void __exit CharDev_exit(void) {
+  misc_deregister(&cdev);
+}
+
+module_init(CharDev_init)
+module_exit(CharDev_exit)
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/CVS/Entries	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,3 @@
+/PerlTest/1.1/Thu Feb  1 09:46:59 2001//
+/README/1.1/Thu Feb  1 09:46:59 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/CVS/Repository	Thu Feb  1 11:46:59 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CharDev/kernel-perl
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/CVS/Root
--- linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/CVS/Root	Thu Feb  1 11:46:59 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/PerlTest linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/PerlTest
--- linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/PerlTest	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/PerlTest	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,17 @@
+#!/usr/bin/perl -w
+
+use CORBA::ORBit idl => [ qw(../chardev.idl) ];
+use Error qw(:try);
+use strict;
+
+my $orb = CORBA::ORB_init("orbit-local-orb");
+open IOR, "/tmp/chardev-ior" or die "no chardev server found!";
+my $ior = <IOR>;
+close IOR;
+#chomp($ior);  # Kill fredrik's newline...
+
+my $chardev = $orb->string_to_object($ior);
+# Echo echoString(in string astring, out long anum);
+my ($ressize, $buf) = $chardev->read(10);
+
+print "Return size = $ressize\nresult = $buf\n";
diff -urN linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/README linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/README
--- linux-2.4.1/net/korbit/modules/CharDev/kernel-perl/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/kernel-perl/README	Thu Feb  1 11:46:59 2001
@@ -0,0 +1,6 @@
+This module is used to test the user side of the CORBA Character 
+device.  It doesn't do anything really complex, just implements a quick
+sanity test for the server.
+
+ORB: ORBit - Perl
+Status: Working!
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/CVS/Entries	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,6 @@
+/Makefile/1.5/Thu Feb  1 09:47:00 2001//
+/README/1.1/Thu Feb  1 09:47:00 2001//
+/RunServer.sh/1.1/Thu Feb  1 09:47:00 2001//
+/chardev-server.c/1.5/Thu Feb  1 09:47:00 2001//
+/chardev-skelimpl.c/1.5/Thu Feb  1 09:47:00 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/CVS/Repository	Thu Feb  1 11:47:00 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CharDev/userspace
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/CVS/Root
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/CVS/Root	Thu Feb  1 11:47:00 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/Makefile linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/Makefile
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/Makefile	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,30 @@
+#
+# Makefile for KORBit / CharDev
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+CFLAGS = -Wall -I/usr/lib/glib/include
+LDFLAGS = -lORBit -lIIOP -lORBitutil
+OBJS = chardev-common.o chardev-skels.o chardev-server.o 
+ORBIT-IDL = /usr/bin/orbit-idl
+
+chardev-server: $(OBJS)
+	gcc -o chardev-server $(OBJS) $(LDFLAGS)
+
+chardev-server.o: chardev.h chardev-skelimpl.c
+
+chardev.h chardev-skels.c chardev-common.c: ../chardev.idl
+	$(ORBIT-IDL) ../chardev.idl
+
+chardev-skelimpl.c:
+
+%.o: %.c
+	gcc -c $< $(CFLAGS)
+clean:
+	rm -f $(OBJS) chardev-server chardev-common.c chardev-skels.c \
+		chardev-stubs.c chardev.h
+
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/README linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/README
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/README	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,4 @@
+This is an example character driver.
+
+ORB: ORBit
+Status: not yet working
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/RunServer.sh linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/RunServer.sh
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/RunServer.sh	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/RunServer.sh	Thu Feb  1 11:47:00 2001
@@ -0,0 +1 @@
+./chardev-server -ORBIIOPUSock=0 -ORBIIOPIPv4=1
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/chardev-server.c linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/chardev-server.c
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/chardev-server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/chardev-server.c	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,77 @@
+//-----------------------------------------------------------------------------
+//
+// chardev-server.c - TEST Kernel miscdevice implementation
+//
+// This file implements the standard server code for a userspace server.  This
+// is basically cut and paste boilerplate code adapted from the CorbaFS server
+// by Fredrik Vraalsen.
+//
+// TODO: Locking, finish exporting all "miscdevice" functions, send position
+//       on READ request.
+//
+// History:
+//   Keith Wessel  - Initial hack, initial idea
+//   Andy Reitz    - Get it to compile
+//   Chris Lattner - Hack'n'slash, make it work, comment it, kill warnings.
+//
+//-----------------------------------------------------------------------------
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <orb/orbit.h>
+
+// #include the C file because all the functions are static.  Bizarre.
+#include "chardev-skelimpl.c"
+
+int main(int argc, char *argv[]) {
+    PortableServer_POA poa;
+    PortableServer_POAManager pm;
+
+    CharDev chardev = CORBA_OBJECT_NIL;
+    impl_POA_CharDev *chardev_impl;
+    PortableServer_ObjectId *objid;
+
+    CORBA_Environment ev;
+    char *retval;
+    CORBA_ORB orb;
+    FILE *IORFILE;
+
+    orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", &ev);
+    poa = (PortableServer_POA)CORBA_ORB_resolve_initial_references(orb, "RootPOA", &ev);
+
+    chardev = impl_CharDev__create(poa, &ev);
+    pm = PortableServer_POA__get_the_POAManager(poa, &ev);
+    PortableServer_POAManager_activate(pm, &ev);
+
+    if (!chardev) {
+	printf("Cannot get objref\n");
+	return 1;
+    }
+
+    chardev_impl = PortableServer_POA_reference_to_servant(poa, chardev, &ev);
+    objid = PortableServer_POA_servant_to_id(poa, chardev_impl, &ev);
+
+    retval = CORBA_ORB_object_to_string(orb, chardev, &ev);
+
+    g_print("FYI, this also goes into /tmp/chardev-ior for you.\n");
+    g_print("%s\n", retval); fflush(stdout);
+ 
+    IORFILE = fopen ("/tmp/chardev-ior", "w");
+    if (IORFILE == NULL) {
+      perror("ERROR: IOR_WRITE_TO_DISK");
+      exit(1);
+    }
+
+    fprintf(IORFILE, "%s", retval);
+    fclose(IORFILE);
+
+    CORBA_free(retval);  // Free the corba string like a good little CORBear
+
+
+    // La dee dah... I will never return for you mister.
+    CORBA_ORB_run(orb, &ev);
+    return 0;
+}
+
diff -urN linux-2.4.1/net/korbit/modules/CharDev/userspace/chardev-skelimpl.c linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/chardev-skelimpl.c
--- linux-2.4.1/net/korbit/modules/CharDev/userspace/chardev-skelimpl.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CharDev/userspace/chardev-skelimpl.c	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,119 @@
+//-----------------------------------------------------------------------------
+//
+// chardev-skelimpl.c - TEST Kernel miscdevice implementation
+//
+// This file implements a CORBA "miscdevice" (character device node).  
+// This device simply outputs a fixed string (set by "message", below) when
+// cat'd.  Pretty simple stuff, but you can obviously do much more creative
+// things with it.
+//
+// TODO: Locking, finish exporting all "miscdevice" functions, send position
+//       on READ request.
+//
+// Right now we have ONE server object with global state, so that when you 
+// read the string from that object, it is finished.  This should be reset
+// whenever an open request is had or when the file position is reset (duh).
+//
+// History:
+//   Keith Wessel  - Initial hack, initial idea
+//   Andy Reitz    - Get it to compile
+//   Chris Lattner - Make it work, comment it, no warnings.
+//
+//-----------------------------------------------------------------------------
+
+#include "chardev.h"
+
+// The message to spit out.
+const char *message = "Hello world!\nI love kORBit\n";
+
+
+/*** App-specific servant structures ***/
+
+typedef struct
+{
+   POA_CharDev servant;
+   PortableServer_POA poa;
+   int AmountRead;
+
+}
+impl_POA_CharDev;
+
+/*** Implementation stub prototypes ***/
+
+static inline void impl_CharDev__destroy(impl_POA_CharDev * servant,
+					 CORBA_Environment * ev);
+static CORBA_long
+impl_CharDev_read(impl_POA_CharDev * servant,
+		  Buffer ** buffer, CORBA_long size, CORBA_Environment * ev);
+
+/*** epv structures ***/
+
+static PortableServer_ServantBase__epv impl_CharDev_base_epv = {
+   NULL,			/* _private data */
+   NULL,			/* finalize routine */
+   NULL,			/* default_POA routine */
+};
+static POA_CharDev__epv impl_CharDev_epv = {
+   NULL,			/* _private */
+   (gpointer) & impl_CharDev_read,
+
+};
+
+/*** vepv structures ***/
+
+static POA_CharDev__vepv impl_CharDev_vepv = {
+   &impl_CharDev_base_epv,
+   &impl_CharDev_epv,
+};
+
+/*** Stub implementations ***/
+
+static CharDev
+impl_CharDev__create(PortableServer_POA poa, CORBA_Environment * ev)
+{
+   CharDev retval;
+   impl_POA_CharDev *newservant;
+   PortableServer_ObjectId *objid;
+
+   newservant = g_new0(impl_POA_CharDev, 1);
+   newservant->servant.vepv = &impl_CharDev_vepv;
+   newservant->poa = poa;
+   newservant->AmountRead = 0;  // Initialize chardev stuff...
+
+   POA_CharDev__init((PortableServer_Servant) newservant, ev);
+   objid = PortableServer_POA_activate_object(poa, newservant, ev);
+   CORBA_free(objid);
+   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);
+
+   return retval;
+}
+
+static inline void
+impl_CharDev__destroy(impl_POA_CharDev * servant, CORBA_Environment * ev)
+{
+   PortableServer_ObjectId *objid;
+
+   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
+   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
+   CORBA_free(objid);
+
+   POA_CharDev__fini((PortableServer_Servant) servant, ev);
+   g_free(servant);
+}
+
+static CORBA_long
+impl_CharDev_read(impl_POA_CharDev * servant,
+		  Buffer ** buffer, CORBA_long ReqSize, CORBA_Environment * ev)
+{
+   int AvailSize = strlen(message)-servant->AmountRead;
+   CORBA_long retval = (ReqSize > AvailSize) ? AvailSize : ReqSize;
+
+   *buffer = Buffer__alloc();
+   (*buffer)->_buffer = CORBA_octet_allocbuf(retval);
+   (*buffer)->_length = retval;
+
+   strncpy((*buffer)->_buffer, message + servant->AmountRead, retval);
+   servant->AmountRead += retval;
+   return retval;
+}
+
diff -urN linux-2.4.1/net/korbit/modules/Config.in linux-2.4.1-korbit/net/korbit/modules/Config.in
--- linux-2.4.1/net/korbit/modules/Config.in	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Config.in	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,11 @@
+# Console server
+#
+dep_tristate '    CORBA Console Server (EXPERIMENTAL)' CONFIG_CORBA_CONSOLE $CONFIG_KORBIT
+
+dep_tristate '    CORBA Echo Server (EXPERIMENTAL)' CONFIG_CORBA_ECHO $CONFIG_KORBIT
+
+dep_tristate '    CORBA FileSystem Access (EXPERIMENTAL)' CONFIG_CORBA_FILESERVER $CONFIG_KORBIT
+
+dep_tristate '    CORBA User-space FileSystem (EXPERIMENTAL)' CONFIG_CORBA_CORBAFS $CONFIG_KORBIT
+
+dep_tristate '    CORBA Character Device Interface (EXPERIMENTAL)' CONFIG_CORBA_CHARDEV $CONFIG_KORBIT
diff -urN linux-2.4.1/net/korbit/modules/Console/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Console/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Entries	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,4 @@
+/Makefile/1.2/Thu Feb  1 09:47:00 2001//
+/README/1.1/Thu Feb  1 09:47:00 2001//
+/console.idl/1.1/Thu Feb  1 09:47:00 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Console/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/Console/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Entries.Log	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,3 @@
+A D/PerlClient////
+A D/client////
+A D/server////
diff -urN linux-2.4.1/net/korbit/modules/Console/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Console/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Repository	Thu Feb  1 11:47:00 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Console
diff -urN linux-2.4.1/net/korbit/modules/Console/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Root
--- linux-2.4.1/net/korbit/modules/Console/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/CVS/Root	Thu Feb  1 11:47:00 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Console/Makefile linux-2.4.1-korbit/net/korbit/modules/Console/Makefile
--- linux-2.4.1/net/korbit/modules/Console/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/Makefile	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,11 @@
+#
+# Makefile for KORBit/modules/Console
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+subdir-$(CONFIG_CORBA_CONSOLE) := server
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/Console/PerlClient/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Console/PerlClient/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/CVS/Entries	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,3 @@
+/Client/1.1/Thu Feb  1 09:47:01 2001//
+/README/1.1/Thu Feb  1 09:47:01 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Console/PerlClient/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Console/PerlClient/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/CVS/Repository	Thu Feb  1 11:47:01 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Console/PerlClient
diff -urN linux-2.4.1/net/korbit/modules/Console/PerlClient/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/CVS/Root
--- linux-2.4.1/net/korbit/modules/Console/PerlClient/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/CVS/Root	Thu Feb  1 11:47:01 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Console/PerlClient/Client linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/Client
--- linux-2.4.1/net/korbit/modules/Console/PerlClient/Client	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/Client	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,14 @@
+#!/usr/bin/perl -w
+
+use CORBA::ORBit idl => [ qw(../console.idl) ];
+use Error qw(:try);
+use strict;
+
+my $orb = CORBA::ORB_init("orbit-local-orb");
+open IOR, "/proc/corba/console-server" or die "no console server found!";
+my $ior = <IOR>;
+close IOR;
+chomp($ior);  # Kill fredrik's newline...
+
+my $console = $orb->string_to_object($ior);
+$console->print("Hello Strange World");
diff -urN linux-2.4.1/net/korbit/modules/Console/PerlClient/README linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/README
--- linux-2.4.1/net/korbit/modules/Console/PerlClient/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/PerlClient/README	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,3 @@
+This is a perl client for the Console server.
+
+ORB: ORBit
diff -urN linux-2.4.1/net/korbit/modules/Console/README linux-2.4.1-korbit/net/korbit/modules/Console/README
--- linux-2.4.1/net/korbit/modules/Console/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/README	Thu Feb  1 11:47:00 2001
@@ -0,0 +1 @@
+The "hello world" testcase.  This is used to write a string to the linux console.
diff -urN linux-2.4.1/net/korbit/modules/Console/client/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Console/client/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Console/client/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/client/CVS/Entries	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,4 @@
+/Makefile/1.2/Thu Feb  1 09:47:01 2001//
+/README/1.1/Thu Feb  1 09:47:01 2001//
+/console-client.c/1.1/Thu Feb  1 09:47:01 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Console/client/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Console/client/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Console/client/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/client/CVS/Repository	Thu Feb  1 11:47:01 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Console/client
diff -urN linux-2.4.1/net/korbit/modules/Console/client/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Console/client/CVS/Root
--- linux-2.4.1/net/korbit/modules/Console/client/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/client/CVS/Root	Thu Feb  1 11:47:01 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Console/client/Makefile linux-2.4.1-korbit/net/korbit/modules/Console/client/Makefile
--- linux-2.4.1/net/korbit/modules/Console/client/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/client/Makefile	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,32 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+PROJECT = console
+
+CFLAGS = -Wall `orbit-config --cflags client` -I../../..
+LDFLAGS = `orbit-config --libs client`
+OBJS = $(PROJECT)-common.o $(PROJECT)-stubs.o $(PROJECT)-client.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-client: $(OBJS)
+	gcc -o $(PROJECT)-client $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-client.c: $(PROJECT).h
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-stubs.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --noskels ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-client
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-stubs.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/Console/client/README linux-2.4.1-korbit/net/korbit/modules/Console/client/README
--- linux-2.4.1/net/korbit/modules/Console/client/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/client/README	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,3 @@
+C Client to access console server.
+
+ORB: ORBit
diff -urN linux-2.4.1/net/korbit/modules/Console/client/console-client.c linux-2.4.1-korbit/net/korbit/modules/Console/client/console-client.c
--- linux-2.4.1/net/korbit/modules/Console/client/console-client.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/client/console-client.c	Thu Feb  1 11:47:01 2001
@@ -0,0 +1,63 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <orb/orbit.h>
+
+#include "console.h"
+
+Console console_client;
+
+int
+main (int argc, char *argv[])
+{
+    CORBA_Environment ev;
+    CORBA_ORB orb;
+    char *Message = "Hey dood, nice hair";
+    int i;
+
+    int niters = 10;
+
+    CORBA_exception_init(&ev);
+    orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", &ev);
+
+#if 0
+    for(i = 0; i < (sizeof(theblah) - 1); i++)
+	theblah[i] = 'a';
+    theblah[sizeof(theblah) - 1] = '\0';
+#endif
+
+    if(argc < 2)
+      {
+	printf("Need a binding ID thing as argv[1]\n");
+	return 1;
+      }
+
+    if(argc >= 3)
+	niters = atoi(argv[2]);
+
+    if (argc >= 4)
+      Message = argv[3];
+
+    console_client = CORBA_ORB_string_to_object(orb, argv[1], &ev);
+    if (!console_client) {
+	printf("Cannot bind to %s\n", argv[1]);
+	return 1;
+    }
+
+    printf("corba = %d, console = %d, foobar = %d\n",
+	CORBA_Object_is_a(console_client, "IDL:CORBA/Object:1.0", &ev),
+	CORBA_Object_is_a(console_client, "IDL:Empty:1.0", &ev),
+	CORBA_Object_is_a(console_client, "IDL:Foo/Bar:1.0", &ev));
+
+    for(i = 0; i < niters; i++) {
+	    Console_print(console_client, Message, &ev);
+	    if(ev._major != CORBA_NO_EXCEPTION) {
+	      printf("we got exception %d from doNothing!\n", ev._major);
+	      return 1;
+	    }
+    }
+
+    CORBA_Object_release(console_client, &ev);
+    CORBA_Object_release((CORBA_Object)orb, &ev);
+
+    return 0;
+}
diff -urN linux-2.4.1/net/korbit/modules/Console/console.idl linux-2.4.1-korbit/net/korbit/modules/Console/console.idl
--- linux-2.4.1/net/korbit/modules/Console/console.idl	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/console.idl	Thu Feb  1 11:47:00 2001
@@ -0,0 +1,3 @@
+interface Console {
+  void print(in string TheString);
+};
diff -urN linux-2.4.1/net/korbit/modules/Console/server/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Console/server/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Console/server/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/CVS/Entries	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,5 @@
+/Makefile/1.7/Thu Feb  1 09:47:02 2001//
+/Makefile.user/1.1/Thu Feb  1 09:47:02 2001//
+/README/1.1/Thu Feb  1 09:47:02 2001//
+/console-server.c/1.7/Thu Feb  1 09:47:02 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Console/server/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Console/server/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Console/server/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/CVS/Repository	Thu Feb  1 11:47:02 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Console/server
diff -urN linux-2.4.1/net/korbit/modules/Console/server/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Console/server/CVS/Root
--- linux-2.4.1/net/korbit/modules/Console/server/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/CVS/Root	Thu Feb  1 11:47:02 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Console/server/Makefile linux-2.4.1-korbit/net/korbit/modules/Console/server/Makefile
--- linux-2.4.1/net/korbit/modules/Console/server/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/Makefile	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,21 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := corba-cons-server.o
+
+obj-y := console-server.o console-skels.o console-common.o
+obj-m := $(O_TARGET)
+
+include ../../Makefile.module
+
+console-server.c: console.h console-common.c console-skels.c
+
+
+console.h console-skels.c: ../console.idl
+	$(ORBIT_IDL) ../console.idl
diff -urN linux-2.4.1/net/korbit/modules/Console/server/Makefile.user linux-2.4.1-korbit/net/korbit/modules/Console/server/Makefile.user
--- linux-2.4.1/net/korbit/modules/Console/server/Makefile.user	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/Makefile.user	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,32 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+PROJECT = console
+
+CFLAGS = -Wall `orbit-config --cflags server` -I../../..
+LDFLAGS = `orbit-config --libs server`
+OBJS = $(PROJECT)-common.o $(PROJECT)-skels.o $(PROJECT)-server.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-server: $(OBJS)
+	gcc -o $(PROJECT)-server $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-server.c: $(PROJECT).h
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-skels.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --nostubs ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-server
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-skels.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/Console/server/README linux-2.4.1-korbit/net/korbit/modules/Console/server/README
--- linux-2.4.1/net/korbit/modules/Console/server/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/README	Thu Feb  1 11:47:02 2001
@@ -0,0 +1 @@
+Kernel module to implement Console server.
diff -urN linux-2.4.1/net/korbit/modules/Console/server/console-server.c linux-2.4.1-korbit/net/korbit/modules/Console/server/console-server.c
--- linux-2.4.1/net/korbit/modules/Console/server/console-server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Console/server/console-server.c	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,85 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <orb/orbit.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include "console.h"
+#include "glib.h"
+#include "korbit.h"
+
+Console console_client = CORBA_OBJECT_NIL;
+
+static void corba_console_print(PortableServer_Servant _servant, 
+                                CORBA_char *TheString,
+                                CORBA_Environment *ev);
+
+PortableServer_ServantBase__epv base_epv = {
+  NULL,
+  NULL,
+  NULL
+};
+POA_Console__epv console_epv = { NULL, corba_console_print };
+POA_Console__vepv poa_console_vepv = { &base_epv, &console_epv };
+POA_Console poa_console_servant = { NULL, &poa_console_vepv };
+
+// MAke this global so that I can unregister the module...
+PortableServer_ObjectId objid = {0, sizeof("myFoo"), "myFoo"};
+CORBA_Environment *ev;
+PortableServer_POA poa;
+
+#ifdef __KERNEL__
+int __init corba_console_init(void) 
+#else
+int main(int argc, char *argv[])
+#endif
+{
+#ifdef __KERNEL__
+    int argc = 1; char *argv[] = { "server", 0 };
+#endif
+    CORBA_ORB orb;
+
+    ev = g_new0(CORBA_Environment, 1);
+    CORBA_exception_init(ev);
+    orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", ev);
+
+    poa = (PortableServer_POA)CORBA_ORB_resolve_initial_references(orb, "RootPOA", ev);
+    PortableServer_POAManager_activate(PortableServer_POA__get_the_POAManager(poa, ev), ev);
+
+    POA_Console__init(&poa_console_servant, ev);
+
+    PortableServer_POA_activate_object_with_id(poa,
+					       &objid, &poa_console_servant, ev);
+
+    console_client = 
+      PortableServer_POA_servant_to_reference(poa, &poa_console_servant, ev);
+    if (!console_client) {
+	printf("Cannot get objref\n");
+	return 1;
+    }
+
+    korbit_register_ior("console-server", console_client, orb, ev);
+
+    CORBA_ORB_run(orb, ev);
+
+    return 0;
+}
+
+#ifdef __KERNEL__
+void corba_console_exit(void) { 
+  PortableServer_POA_deactivate_object(poa, &objid, ev);
+  remove_proc_entry("corba/console-server", 0);
+}
+
+module_init(corba_console_init)
+module_exit(corba_console_exit)
+#endif
+
+static void corba_console_print(PortableServer_Servant _servant, 
+                                CORBA_char *TheString,
+                                CORBA_Environment *ev) {
+  printf("Yo. Dood.  You said: '%s'!\n", TheString);
+}
+
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Entries	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,4 @@
+/CorbaFS.idl/1.7/Thu Feb  1 09:47:02 2001//
+/Makefile/1.4/Thu Feb  1 09:47:02 2001//
+/README/1.2/Thu Feb  1 09:47:02 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Entries.Log	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,3 @@
+A D/client////
+A D/server////
+A D/server-perl////
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Repository	Thu Feb  1 11:47:02 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CorbaFS
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Root
--- linux-2.4.1/net/korbit/modules/CorbaFS/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CVS/Root	Thu Feb  1 11:47:02 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/CorbaFS.idl linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CorbaFS.idl
--- linux-2.4.1/net/korbit/modules/CorbaFS/CorbaFS.idl	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/CorbaFS.idl	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,38 @@
+// -----------------------------------------------------------------------------
+// CorbaDS Module - Implement Kernel functionality in Korba
+// -----------------------------------------------------------------------------
+//
+// Main source of information: 
+//    http://www.cse.unsw.edu.au/~neilb/oss/linux-commentary/vfs.html
+//
+module CorbaFS {
+
+  struct dirent
+  {
+    long inode;           // inode number 
+    string name;          // file name (null-terminated)
+  };
+
+  typedef sequence<dirent> DirEntSeq;
+  typedef sequence<octet> Buffer;
+        
+  interface Inode {
+    void getStatus(out unsigned short mode, out unsigned long uid, out unsigned long gid, 
+                   out unsigned long size, out unsigned long inodeNum, out unsigned short numLinks, 
+                   out long atime, out long mtime, out long ctime);
+    void readpage(out Buffer buffer, in long size, in long offset);
+    void release();
+  };
+
+  interface FileSystem {  
+    Inode getInode(in string path);
+
+    // DirectoryInode  getStatus implementation must have S_IFDIR in the S_IFMT
+    // field of the mode value.
+    DirEntSeq readdir(in string path);
+
+    // SymlinkInode getStatus implementation must have S_IFLNK in the S_IFMT
+    // field of the mode value.
+    string readlink(in string filename);
+  };
+};
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/Makefile linux-2.4.1-korbit/net/korbit/modules/CorbaFS/Makefile
--- linux-2.4.1/net/korbit/modules/CorbaFS/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/Makefile	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,11 @@
+#
+# Makefile for KORBit - CorbaFS
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+subdir-$(CONFIG_CORBA_CORBAFS) := client
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/README linux-2.4.1-korbit/net/korbit/modules/CorbaFS/README
--- linux-2.4.1/net/korbit/modules/CorbaFS/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/README	Thu Feb  1 11:47:02 2001
@@ -0,0 +1,14 @@
+This interface is used to implement linux FileSystems in CORBA.
+
+Status: Working for readonly filesystems.  Write capability is a todo.
+
+This lets you do all kinds of interesting things (just like the user level 
+filesystem proposals would let you do):
+  server/ implements NFS like capability of just exporting an existing FS
+  TODO:   webfs, ftpfs, cvsfs, mysqlfs...
+
+Usage:
+  insmod corba-corbafs.o
+  mount -t corbafs -o IOR:... none /mnt/corbafs
+
+Where the IOR comes from a filesystem server that you run somewhere...
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CVS/Entries	Thu Feb  1 11:47:03 2001
@@ -0,0 +1,6 @@
+/CorbaFS-client.c/1.9/Thu Feb  1 09:47:03 2001//
+/CorbaFS-user-client.c/1.3/Thu Feb  1 09:47:03 2001//
+/Makefile/1.4/Thu Feb  1 09:47:03 2001//
+/Makefile.user/1.1/Thu Feb  1 09:47:03 2001//
+/README/1.1/Thu Feb  1 09:47:03 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CVS/Repository	Thu Feb  1 11:47:03 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CorbaFS/client
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CVS/Root
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CVS/Root	Thu Feb  1 11:47:03 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-client.c linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-client.c
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-client.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-client.c	Fri Feb  2 02:20:21 2001
@@ -0,0 +1,469 @@
+/*
+ * corbafs - Interface glue between native linux VFS layer and CORBA
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/locks.h>
+#include <linux/dirent.h>
+#include <linux/module.h>
+
+#include <asm/uaccess.h>
+#include "CorbaFS.h"
+
+/* some random number */
+#define CORBAFS_MAGIC	0xC02BAF5
+
+// CORBA Stuff...
+CORBA_ORB         orb;
+CORBA_Environment *ev;
+
+
+/*
+ *  FILE OPERATIONS     FILE OPERATIONS     FILE OPERATIONS     FILE OPERATIONS
+ */
+
+/* Declarations for the file_operations structure for normal files...
+ */
+static struct file_operations corbafs_file_operations = {
+        read:           generic_file_read,
+};
+
+
+/* Declarations for the file_operations structure for directories...
+ */
+static int corbafs_readdir(struct file *file, void *data, filldir_t filldir);
+
+static struct file_operations corbafs_dir_operations = {
+	read:		generic_read_dir,
+	readdir:	corbafs_readdir,
+};
+
+
+/*
+ * INODE OPERATIONS    INODE OPERATIONS    INODE OPERATIONS    INODE OPERATIONS
+ */
+
+/* Declarations for the inode_operations structure for symlinks...
+ */
+static int corbafs_readlink(struct dentry *dentry, char *buffer, int buflen);
+static int corbafs_followlink(struct dentry *link, struct nameidata *nd);
+
+static struct inode_operations corbafs_symlink_inode_operations = {
+        readlink:       corbafs_readlink,
+        follow_link:    corbafs_followlink,
+};
+
+
+/* Declarations for the inode_operations structure for directories...
+ */
+static struct dentry *corbafs_lookup(struct inode *dir, struct dentry *dentry);
+
+static struct inode_operations corbafs_dir_inode_operations = {
+	lookup:		corbafs_lookup,
+};
+
+
+/*
+ * OTHER OPERATIONS    OTHER OPERATIONS    OTHER OPERATIONS    OTHER OPERATIONS
+ */
+
+/* Declarations for the corba FS's address space ops...
+ */
+static int corbafs_readpage(struct file *file, struct page * page);
+
+static struct address_space_operations corbafs_aops = {
+	readpage:	corbafs_readpage,
+};
+
+
+/* Declarations for the super_operations structure...
+ */
+static int corbafs_statfs(struct super_block *sb, struct statfs *buf);
+static void corbafs_delete_inode(struct inode *);
+
+static struct super_operations corbafs_ops = {
+	statfs:		corbafs_statfs,
+	delete_inode: corbafs_delete_inode,
+};
+
+
+
+
+/* do_local_path - Modified version of d_path that is used to get the remote 
+ * filename that a dentry represents... 
+ */
+static char *d_local_path(struct dentry *dentry, char *buffer, int buflen) {
+        char * end = buffer+buflen;
+        char * retval;
+        int namelen;
+
+        *--end = '\0';
+        buflen--;
+
+        /* Get '/' right */
+        retval = end-1;
+        *retval = '/';
+        for (;;) {
+                if (IS_ROOT(dentry)) {
+                        if (dentry->d_name.len > 1 || 
+                            dentry->d_name.name[0] != '/' ||
+                            retval != end) {   /* Only for root directory */
+                                namelen = dentry->d_name.len;
+                                buflen -= namelen;
+                                if (buflen >= 0) {
+                                        end -= namelen;
+                                        memcpy(end, dentry->d_name.name, namelen);
+                                }
+                        }
+                        return end;
+                }
+                namelen = dentry->d_name.len;
+                buflen -= namelen + 1;
+                if (buflen < 0)
+                        break;
+                end -= namelen;
+                memcpy(end, dentry->d_name.name, namelen);
+                *--end = '/';
+                retval = end;
+                if (dentry == dentry->d_parent) break;
+                dentry = dentry->d_parent;
+        }
+        return retval;
+}
+
+
+/* corbafs_readpage - This request should be between a file_open and a 
+ * file_release, so file_fd(f) should be valid.  Just read the buffer...
+ */
+static int corbafs_readpage(struct file *f, struct page * page)
+{
+        struct inode *d_inode = f->f_dentry->d_inode;
+        CorbaFS_Inode inode;
+        CorbaFS_Buffer *buffer = NULL;
+        
+        int offset = page->index*PAGE_CACHE_SIZE;
+        int bytesRead;
+        
+#if 0
+        printk("*** READPAGE 0x%p: 0x%lX->0x%lX to 0x%p\n",
+               f, 
+               page->index, 
+               page->index*PAGE_CACHE_SIZE, 
+               page_address(page));
+#endif
+
+        inode = d_inode->u.generic_ip;
+        if (!inode) return -EPERM;
+
+        CorbaFS_Inode_readpage(inode, &buffer, PAGE_CACHE_SIZE, offset, ev);
+        if (!buffer) return -EPERM; /* ??? */
+        
+        bytesRead = buffer->_length;
+        memcpy(page_address(page), buffer->_buffer, bytesRead);
+        
+        if (bytesRead != PAGE_CACHE_SIZE) {  /* EOF? */
+                /* Zero out rest of page for security. */
+                memset((void*)(page_address(page)+bytesRead), 0, 
+                       PAGE_CACHE_SIZE-bytesRead);
+        }
+
+        SetPageUptodate(page);
+        UnlockPage(page);
+        return 0;
+}
+
+
+
+struct inode *corbafs_get_inode(struct super_block *sb, const char *path)
+{
+	struct inode * inode = get_empty_inode();
+        CorbaFS_FileSystem fs_client;
+        CorbaFS_Inode newInode;
+        
+	if (!inode) return 0;
+
+	inode->i_sb = sb;
+	inode->i_dev = sb->s_dev;
+
+	fs_client = sb->u.generic_sbp;
+//printk("\n \n  \nCorbaFS_FileSystem_getInode(0x%X, %s)\n", fs_client, path);
+	newInode = CorbaFS_FileSystem_getInode(fs_client, path, ev);
+//printk("NewInode = 0x%X\n \n  \n   \n", newInode);
+	if (!newInode) {
+		iput(inode);
+		return NULL;
+	}
+
+//printk("CorbaFS_Inode_getStatus\n");
+	CorbaFS_Inode_getStatus(newInode, 
+				&inode->i_mode, &inode->i_uid, &inode->i_gid, 
+				(CORBA_unsigned_long *)&inode->i_size, 
+				(CORBA_unsigned_long *)&inode->i_ino, 
+				&inode->i_nlink, 
+				(CORBA_long *)&inode->i_atime, 
+				(CORBA_long *)&inode->i_mtime, 
+				(CORBA_long *)&inode->i_ctime,
+				ev);
+//printk("Back from CorbaFS_Inode_getStatus\n \n  \n   \n");
+
+	inode->u.generic_ip = (void*)newInode;
+	
+        /* TODO: Map things back correctly??? */
+	inode->i_uid = 0 /*current->fsuid */;
+	inode->i_gid = 0 /*current->fsgid */;
+	
+	inode->i_blksize = PAGE_CACHE_SIZE;
+	inode->i_blocks = 0;
+	inode->i_rdev = 0;
+	inode->i_op = NULL;
+	inode->i_fop = NULL;
+	inode->i_mapping->a_ops = &corbafs_aops;
+	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	
+	switch (inode->i_mode & S_IFMT) {
+	default:
+		/* Do I really want to expose device inodes? */
+		init_special_inode(inode, inode->i_mode, sb->s_dev);
+		break;
+	case S_IFREG:
+		inode->i_fop = &corbafs_file_operations;
+		break;
+	case S_IFDIR:
+		inode->i_op = &corbafs_dir_inode_operations;
+		inode->i_fop = &corbafs_dir_operations;
+		break;
+	case S_IFLNK:
+		inode->i_op = &corbafs_symlink_inode_operations;
+		break;
+	}
+	insert_inode_hash(inode);
+
+	return inode;
+}
+
+static int corbafs_readdir(struct file *file, void *data, filldir_t filldir) 
+{
+        struct inode *inode = file->f_dentry->d_inode;
+        struct super_block *sb = file->f_dentry->d_sb;
+        unsigned offset = file->f_pos;
+        char *path, *page = (char *)__get_free_page(GFP_KERNEL);
+        int i;
+        unsigned char d_type = DT_UNKNOWN;
+        CorbaFS_FileSystem fs_client;
+        CorbaFS_DirEntSeq *dirEntSeq;
+        CorbaFS_dirent *dirEnts;
+        
+        if (offset >= inode->i_size) return 0;
+
+        path = d_local_path(file->f_dentry, page, PAGE_SIZE);
+
+        fs_client = sb->u.generic_sbp;
+        if (!fs_client)
+                return -EPERM; /* ??? */
+
+//        printk("\n \n  \nCorbaFS_FileSystem_readdir(%s)\n", path);
+        
+        dirEntSeq = CorbaFS_FileSystem_readdir(fs_client, path, ev);
+
+//        printk("CorbaFS_FileSystem_readdir = %d\n \n  \n  \n", dirEntSeq->_length);
+
+        if (dirEntSeq->_length == 0) goto full;
+	
+        dirEnts = dirEntSeq->_buffer;
+	i = 0;
+	if (offset) {                   // We have read PART of the directory
+		int idxadj = offset;    // Start reading now from where we left
+		while (idxadj > 0) {        // off...
+			idxadj -= sizeof(struct dirent)+
+				  strlen(dirEnts[i].name);
+			i++;
+		}
+
+		if (idxadj < 0) {    // We should end up with exactly 0.
+			printf("Alert!  Readdir can't resume in the middle "
+			       "of a directory!  stopage.\n");
+			goto full;
+		}
+	}
+
+        for (; i < dirEntSeq->_length; i++) {
+                int myinode  = dirEnts[i].inode;
+                char *myname = dirEnts[i].name;
+		int namelen = strlen(myname);
+
+                if (filldir(data, myname, namelen, offset, myinode, d_type))
+                        goto full;
+                offset += sizeof(struct dirent)+namelen;
+        }
+
+ full:
+        file->f_pos = offset;
+	return 0;
+}
+
+static int corbafs_statfs(struct super_block *sb, struct statfs *buf) {
+	buf->f_type = CORBAFS_MAGIC;
+	buf->f_bsize = PAGE_CACHE_SIZE;
+	buf->f_namelen = 255;
+	return 0;
+}
+
+/*
+ * Lookup the data. Most of the grunt work is done by corbafs_get_inode.
+ */
+static struct dentry *corbafs_lookup(struct inode *dir, struct dentry *dentry)
+{
+        struct inode *New;
+        char *Path, *Page = (char *)__get_free_page(GFP_KERNEL);
+        if (Page == 0) goto out;   /* nomem? */
+
+        Path = d_local_path(dentry, Page, PAGE_SIZE);
+
+        New = corbafs_get_inode(dir->i_sb, Path);
+        free_page((unsigned long)Page);
+
+        if (New) {
+                d_add(dentry, New);
+                return 0;
+        }
+
+out:
+	d_add(dentry, NULL);
+	return 0;
+}
+
+
+static char *corbafs_read_a_link(struct dentry *dentry) {
+        char *path, *page, *s = 0;
+        struct super_block *sb = dentry->d_sb;
+        CorbaFS_FileSystem fs_client;
+        
+        page = (char *)__get_free_page(GFP_KERNEL);
+        if (page == 0) goto out;   /* nomem? */
+
+        path = d_local_path(dentry, page, PAGE_SIZE);
+
+        fs_client = sb->u.generic_sbp;
+//        printk("\n \n  \nCorbaFS_FileSystem_readlink(%s)\n", path);
+        s = CorbaFS_FileSystem_readlink(fs_client, path, ev);
+//        printk("CorbaFS_FileSystem_readlink = %s\n \n  \n   \n", s);
+
+        if (ev->_major != CORBA_NO_EXCEPTION) {
+		if (s) {
+			// CORBA_string_free(s,..);
+			s = 0;
+		}
+                goto outfree;
+	}
+ outfree:
+        free_page((unsigned long)page);
+ out:
+	return s;
+}
+
+
+static int corbafs_readlink(struct dentry *dentry, char *buffer, int buflen) {
+	char *str = corbafs_read_a_link(dentry);
+	int error = -EINVAL;
+
+	if (str) {
+		error = vfs_readlink(dentry, buffer, buflen, str);
+		// TODO: CORBA_string__free the string str.
+	}
+	return error;
+}
+
+/* Fill in nd->dentry
+ */
+static int corbafs_followlink(struct dentry *link, struct nameidata *nd) {
+        int Error = -ENOMEM;
+        char *Path = corbafs_read_a_link(link);
+	if (!Path) goto out;
+
+#if 1
+        printk("Followlink: %s\n", Path);
+#endif
+        Error = vfs_follow_link(nd, Path);
+	// TODO: CORBA_string__free the string str.
+
+ out:
+	return Error;
+}
+
+static void corbafs_delete_inode(struct inode *inode) {
+        CorbaFS_Inode Inode = inode->u.generic_ip;
+//        printk("\n \n  \nCorbaFS_Inode_Release\n");
+        CorbaFS_Inode_release(Inode, ev);
+//        printk("CorbaFS_Inode_Release done\n \n  \n   \n");
+}
+
+static void corbafs_put_super(struct super_block *sb) {
+//	MOD_DEC_USE_COUNT;
+}
+
+static struct super_block *corbafs_read_super(struct super_block * sb, void * data, int silent) {
+	struct dentry *root = 0;
+        struct inode  *root_inode = 0;
+        
+        CorbaFS_FileSystem fs_client;
+        
+	sb->s_blocksize      = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic          = CORBAFS_MAGIC;
+	sb->s_op             = &corbafs_ops;
+
+//printk("corbafs_read_super: '%s'\n", (char*)data);
+
+	// Note that the CORBA IOR is now in *data
+        fs_client = CORBA_ORB_string_to_object(orb, data, ev);
+
+//printk("fs_client: 0x%X\n", fs_client);
+        if (!fs_client) 
+                return NULL;
+
+	sb->u.generic_sbp = fs_client;
+
+        root_inode = corbafs_get_inode(sb, "/");
+//printk("root_inode = 0x%X\n", root_inode);
+	root = d_alloc_root(root_inode);
+	if (!root) {
+		iput(root_inode);
+		return NULL;
+	}
+	sb->s_root = root;
+
+//        MOD_INC_USE_COUNT;
+	return sb;
+}
+
+static DECLARE_FSTYPE(corbafs_fs_type, "corbafs", corbafs_read_super, 0);
+
+static int __init init_corbafs_fs(void) {
+	int argc = 1;
+	char *argv[] = { "client", 0 };
+	ev = g_new0(CORBA_Environment,1);
+	orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", ev);
+		
+	return register_filesystem(&corbafs_fs_type);
+}
+
+static void __exit exit_corbafs_fs(void)
+{
+	// remove object from orb.
+	printf("\n \n  \nCorbaFS_exit()\n");
+	unregister_filesystem(&corbafs_fs_type);
+	CORBA_Object_release((CORBA_Object)orb, ev);
+}
+
+module_init(init_corbafs_fs)
+module_exit(exit_corbafs_fs)
+
+/*
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-common.c linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-common.c
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-common.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-common.c	Thu Feb  1 16:36:08 2001
@@ -0,0 +1,370 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "CorbaFS.h"
+
+#if ( (TC_IMPL_TC_CorbaFS_dirent_0 == 'C') \
+&& (TC_IMPL_TC_CorbaFS_dirent_1 == 'o') \
+&& (TC_IMPL_TC_CorbaFS_dirent_2 == 'r') \
+&& (TC_IMPL_TC_CorbaFS_dirent_3 == 'b') \
+&& (TC_IMPL_TC_CorbaFS_dirent_4 == 'a') \
+&& (TC_IMPL_TC_CorbaFS_dirent_5 == 'F') \
+&& (TC_IMPL_TC_CorbaFS_dirent_6 == 'S') \
+) && !defined(TC_DEF_TC_CorbaFS_dirent)
+#define TC_DEF_TC_CorbaFS_dirent 1
+static const char *anon_subnames_array1[] = { "inode", "name" };
+static const CORBA_TypeCode anon_subtypes_array2[] =
+   { (CORBA_TypeCode) & TC_CORBA_long_struct,
+      (CORBA_TypeCode) & TC_CORBA_string_struct };
+const struct CORBA_TypeCode_struct TC_CorbaFS_dirent_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_struct, "dirent", "IDL:CorbaFS/dirent:1.0",
+   0, 2,
+   (const char **) anon_subnames_array1,
+   (CORBA_TypeCode *) anon_subtypes_array2,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_0 == 'C') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_1 == 'o') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_2 == 'r') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_3 == 'b') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_4 == 'a') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_5 == 'F') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_6 == 'S') \
+) && !defined(TC_DEF_TC_CORBA_sequence_CorbaFS_dirent)
+#define TC_DEF_TC_CORBA_sequence_CorbaFS_dirent 1
+static const CORBA_TypeCode anon_subtypes_array6[] =
+   { (CORBA_TypeCode) & TC_CorbaFS_dirent_struct };
+const struct CORBA_TypeCode_struct TC_CORBA_sequence_CorbaFS_dirent_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_sequence, NULL, NULL,
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array6,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_0 == 'C') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_1 == 'o') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_2 == 'r') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_3 == 'b') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_4 == 'a') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_5 == 'F') \
+&& (TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_6 == 'S') \
+) && !defined(TC_DEF_TC_CORBA_sequence_CorbaFS_dirent)
+#define TC_DEF_TC_CORBA_sequence_CorbaFS_dirent 1
+static const CORBA_TypeCode anon_subtypes_array15[] =
+   { (CORBA_TypeCode) & TC_CorbaFS_dirent_struct };
+const struct CORBA_TypeCode_struct TC_CORBA_sequence_CorbaFS_dirent_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_sequence, NULL, NULL,
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array15,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CorbaFS_DirEntSeq_0 == 'C') \
+&& (TC_IMPL_TC_CorbaFS_DirEntSeq_1 == 'o') \
+&& (TC_IMPL_TC_CorbaFS_DirEntSeq_2 == 'r') \
+&& (TC_IMPL_TC_CorbaFS_DirEntSeq_3 == 'b') \
+&& (TC_IMPL_TC_CorbaFS_DirEntSeq_4 == 'a') \
+&& (TC_IMPL_TC_CorbaFS_DirEntSeq_5 == 'F') \
+&& (TC_IMPL_TC_CorbaFS_DirEntSeq_6 == 'S') \
+) && !defined(TC_DEF_TC_CorbaFS_DirEntSeq)
+#define TC_DEF_TC_CorbaFS_DirEntSeq 1
+static const CORBA_TypeCode anon_subtypes_array19[] =
+   { (CORBA_TypeCode) & TC_CORBA_sequence_CorbaFS_dirent_struct };
+const struct CORBA_TypeCode_struct TC_CorbaFS_DirEntSeq_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_alias, "DirEntSeq", "IDL:CorbaFS/DirEntSeq:1.0",
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array19,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CORBA_sequence_CORBA_octet_0 == 'C') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_1 == 'o') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_2 == 'r') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_3 == 'b') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_4 == 'a') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_5 == 'F') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_6 == 'S') \
+) && !defined(TC_DEF_TC_CORBA_sequence_CORBA_octet)
+#define TC_DEF_TC_CORBA_sequence_CORBA_octet 1
+static const CORBA_TypeCode anon_subtypes_array23[] =
+   { (CORBA_TypeCode) & TC_CORBA_octet_struct };
+const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_octet_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_sequence, NULL, NULL,
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array23,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CORBA_sequence_CORBA_octet_0 == 'C') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_1 == 'o') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_2 == 'r') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_3 == 'b') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_4 == 'a') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_5 == 'F') \
+&& (TC_IMPL_TC_CORBA_sequence_CORBA_octet_6 == 'S') \
+) && !defined(TC_DEF_TC_CORBA_sequence_CORBA_octet)
+#define TC_DEF_TC_CORBA_sequence_CORBA_octet 1
+static const CORBA_TypeCode anon_subtypes_array32[] =
+   { (CORBA_TypeCode) & TC_CORBA_octet_struct };
+const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_octet_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_sequence, NULL, NULL,
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array32,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CorbaFS_Buffer_0 == 'C') \
+&& (TC_IMPL_TC_CorbaFS_Buffer_1 == 'o') \
+&& (TC_IMPL_TC_CorbaFS_Buffer_2 == 'r') \
+&& (TC_IMPL_TC_CorbaFS_Buffer_3 == 'b') \
+&& (TC_IMPL_TC_CorbaFS_Buffer_4 == 'a') \
+&& (TC_IMPL_TC_CorbaFS_Buffer_5 == 'F') \
+&& (TC_IMPL_TC_CorbaFS_Buffer_6 == 'S') \
+) && !defined(TC_DEF_TC_CorbaFS_Buffer)
+#define TC_DEF_TC_CorbaFS_Buffer 1
+static const CORBA_TypeCode anon_subtypes_array36[] =
+   { (CORBA_TypeCode) & TC_CORBA_sequence_CORBA_octet_struct };
+const struct CORBA_TypeCode_struct TC_CorbaFS_Buffer_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_alias, "Buffer", "IDL:CorbaFS/Buffer:1.0",
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array36,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CorbaFS_Inode_0 == 'C') \
+&& (TC_IMPL_TC_CorbaFS_Inode_1 == 'o') \
+&& (TC_IMPL_TC_CorbaFS_Inode_2 == 'r') \
+&& (TC_IMPL_TC_CorbaFS_Inode_3 == 'b') \
+&& (TC_IMPL_TC_CorbaFS_Inode_4 == 'a') \
+&& (TC_IMPL_TC_CorbaFS_Inode_5 == 'F') \
+&& (TC_IMPL_TC_CorbaFS_Inode_6 == 'S') \
+) && !defined(TC_DEF_TC_CorbaFS_Inode)
+#define TC_DEF_TC_CorbaFS_Inode 1
+const struct CORBA_TypeCode_struct TC_CorbaFS_Inode_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_objref, "Inode", "IDL:CorbaFS/Inode:1.0",
+   0, 0,
+   NULL,
+   NULL,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+#if ( (TC_IMPL_TC_CorbaFS_FileSystem_0 == 'C') \
+&& (TC_IMPL_TC_CorbaFS_FileSystem_1 == 'o') \
+&& (TC_IMPL_TC_CorbaFS_FileSystem_2 == 'r') \
+&& (TC_IMPL_TC_CorbaFS_FileSystem_3 == 'b') \
+&& (TC_IMPL_TC_CorbaFS_FileSystem_4 == 'a') \
+&& (TC_IMPL_TC_CorbaFS_FileSystem_5 == 'F') \
+&& (TC_IMPL_TC_CorbaFS_FileSystem_6 == 'S') \
+) && !defined(TC_DEF_TC_CorbaFS_FileSystem)
+#define TC_DEF_TC_CorbaFS_FileSystem 1
+const struct CORBA_TypeCode_struct TC_CorbaFS_FileSystem_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_objref, "FileSystem", "IDL:CorbaFS/FileSystem:1.0",
+   0, 0,
+   NULL,
+   NULL,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+gpointer
+CorbaFS_dirent__free(gpointer mem, gpointer dat, CORBA_boolean free_strings)
+{
+   CorbaFS_dirent *var = mem;
+
+   if (free_strings) {
+      CORBA_string__free(&(var->name), NULL, free_strings);
+   }
+   return (gpointer) (var + 1);
+}
+
+CorbaFS_dirent *
+CorbaFS_dirent__alloc(void)
+{
+   CorbaFS_dirent *retval;
+
+   retval =
+      ORBit_alloc(sizeof(CorbaFS_dirent),
+		  (ORBit_free_childvals) CorbaFS_dirent__free,
+		  GUINT_TO_POINTER(1));
+   memset(&(retval->name), '\0', sizeof(retval->name));
+   return retval;
+}
+
+#if ( (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_0 == 'C') \
+&& (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_1 == 'o') \
+&& (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_2 == 'r') \
+&& (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_3 == 'b') \
+&& (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_4 == 'a') \
+&& (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_5 == 'F') \
+&& (ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_6 == 'S') \
+) && !defined(ORBIT_DEF_CORBA_sequence_CorbaFS_dirent)
+#define ORBIT_DEF_CORBA_sequence_CorbaFS_dirent 1
+
+gpointer
+CORBA_sequence_CorbaFS_dirent__free(gpointer mem, gpointer dat,
+				    CORBA_boolean free_strings)
+{
+   CORBA_sequence_CorbaFS_dirent *val = mem;
+
+   if (val->_release)
+      ORBit_free(val->_buffer, free_strings);
+   return (gpointer) (val + 1);
+}
+
+CORBA_sequence_CorbaFS_dirent *
+CORBA_sequence_CorbaFS_dirent__alloc(void)
+{
+   CORBA_sequence_CorbaFS_dirent *retval;
+
+   retval =
+      ORBit_alloc(sizeof(CORBA_sequence_CorbaFS_dirent),
+		  (ORBit_free_childvals) CORBA_sequence_CorbaFS_dirent__free,
+		  GUINT_TO_POINTER(1));
+   retval->_maximum = 0;
+   retval->_length = 0;
+   retval->_buffer = NULL;
+   retval->_release = CORBA_FALSE;
+   return retval;
+}
+
+CorbaFS_dirent *
+CORBA_sequence_CorbaFS_dirent_allocbuf(CORBA_unsigned_long len)
+{
+   CorbaFS_dirent *retval =
+      ORBit_alloc(sizeof(CorbaFS_dirent) * len,
+		  (ORBit_free_childvals) CorbaFS_dirent__free,
+		  GUINT_TO_POINTER(len));
+
+   memset(retval, '\0', sizeof(CorbaFS_dirent) * len);
+   return retval;
+}
+#endif
+
+gpointer
+CorbaFS_DirEntSeq__free(gpointer mem, gpointer dat,
+			CORBA_boolean free_strings)
+{
+   return CORBA_sequence_CorbaFS_dirent__free(mem, dat, free_strings);
+}
+
+CorbaFS_DirEntSeq *
+CorbaFS_DirEntSeq__alloc(void)
+{
+   return CORBA_sequence_CorbaFS_dirent__alloc();
+}
+
+#if ( (ORBIT_IMPL_CORBA_sequence_CORBA_octet_0 == 'C') \
+&& (ORBIT_IMPL_CORBA_sequence_CORBA_octet_1 == 'o') \
+&& (ORBIT_IMPL_CORBA_sequence_CORBA_octet_2 == 'r') \
+&& (ORBIT_IMPL_CORBA_sequence_CORBA_octet_3 == 'b') \
+&& (ORBIT_IMPL_CORBA_sequence_CORBA_octet_4 == 'a') \
+&& (ORBIT_IMPL_CORBA_sequence_CORBA_octet_5 == 'F') \
+&& (ORBIT_IMPL_CORBA_sequence_CORBA_octet_6 == 'S') \
+) && !defined(ORBIT_DEF_CORBA_sequence_CORBA_octet)
+#define ORBIT_DEF_CORBA_sequence_CORBA_octet 1
+
+gpointer
+CORBA_sequence_CORBA_octet__free(gpointer mem, gpointer dat,
+				 CORBA_boolean free_strings)
+{
+   CORBA_sequence_CORBA_octet *val = mem;
+
+   if (val->_release)
+      ORBit_free(val->_buffer, free_strings);
+   return (gpointer) (val + 1);
+}
+
+CORBA_sequence_CORBA_octet *
+CORBA_sequence_CORBA_octet__alloc(void)
+{
+   CORBA_sequence_CORBA_octet *retval;
+
+   retval =
+      ORBit_alloc(sizeof(CORBA_sequence_CORBA_octet),
+		  (ORBit_free_childvals) CORBA_sequence_CORBA_octet__free,
+		  GUINT_TO_POINTER(1));
+   retval->_maximum = 0;
+   retval->_length = 0;
+   retval->_buffer = NULL;
+   retval->_release = CORBA_FALSE;
+   return retval;
+}
+
+CORBA_octet *
+CORBA_sequence_CORBA_octet_allocbuf(CORBA_unsigned_long len)
+{
+   CORBA_octet *retval =
+      ORBit_alloc(sizeof(CORBA_octet) * len, (ORBit_free_childvals) NULL,
+		  GUINT_TO_POINTER(len));
+
+   return retval;
+}
+#endif
+
+gpointer
+CorbaFS_Buffer__free(gpointer mem, gpointer dat, CORBA_boolean free_strings)
+{
+   return CORBA_sequence_CORBA_octet__free(mem, dat, free_strings);
+}
+
+CorbaFS_Buffer *
+CorbaFS_Buffer__alloc(void)
+{
+   return CORBA_sequence_CORBA_octet__alloc();
+}
+
+CORBA_unsigned_long CorbaFS_Inode__classid = 0;
+CORBA_unsigned_long CorbaFS_FileSystem__classid = 0;
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-stubs.c linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-stubs.c
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-stubs.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-stubs.c	Thu Feb  1 16:36:08 2001
@@ -0,0 +1,791 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "CorbaFS.h"
+
+void
+CorbaFS_Inode_getStatus(CorbaFS_Inode _obj, CORBA_unsigned_short * mode,
+			CORBA_unsigned_long * uid, CORBA_unsigned_long * gid,
+			CORBA_unsigned_long * size,
+			CORBA_unsigned_long * inodeNum,
+			CORBA_unsigned_short * numLinks, CORBA_long * atime,
+			CORBA_long * mtime, CORBA_long * ctime,
+			CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+
+   if (_obj->servant && _obj->vepv && CorbaFS_Inode__classid) {
+      
+	 ((POA_CorbaFS_Inode__epv *) _obj->vepv[CorbaFS_Inode__classid])->
+	 getStatus(_obj->servant, mode, uid, gid, size, inodeNum, numLinks,
+		   atime, mtime, ctime, ev);
+      return;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[10];
+      }
+      _ORBIT_operation_name_data =
+      {
+      10, "getStatus"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 14 };
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
+	 
+	    (*((guint16 *) & ((*mode)))) =
+	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 2;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & ((*uid)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	 (*((guint32 *) & ((*gid)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	 (*((guint32 *) & ((*size)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	 (*((guint32 *) & ((*inodeNum)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	 (*((guint16 *) & ((*numLinks)))) =
+	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 2;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & ((*atime)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	 (*((guint32 *) & ((*mtime)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	 (*((guint32 *) & ((*ctime)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
+	 (*mode) = *((CORBA_unsigned_short *) _ORBIT_curptr);
+	 _ORBIT_curptr += 2;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 (*uid) = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 (*gid) = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 (*size) = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 (*inodeNum) = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 (*numLinks) = *((CORBA_unsigned_short *) _ORBIT_curptr);
+	 _ORBIT_curptr += 2;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 (*atime) = *((CORBA_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 (*mtime) = *((CORBA_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 (*ctime) = *((CORBA_long *) _ORBIT_curptr);
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return;
+      }
+   }
+}
+void
+CorbaFS_Inode_readpage(CorbaFS_Inode _obj, CorbaFS_Buffer ** buffer,
+		       const CORBA_long size, const CORBA_long offset,
+		       CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+   register CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+   if (_obj->servant && _obj->vepv && CorbaFS_Inode__classid) {
+      
+	 ((POA_CorbaFS_Inode__epv *) _obj->vepv[CorbaFS_Inode__classid])->
+	 readpage(_obj->servant, buffer, size, offset, ev);
+      return;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[9];
+      }
+      _ORBIT_operation_name_data =
+      {
+      9, "readpage"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 13 };
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+				       (_ORBIT_send_buffer), 4);
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     &(size), sizeof(size));
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     &(offset), sizeof(offset));
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      *buffer = CorbaFS_Buffer__alloc();
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & (((**buffer))._length))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	 _ORBIT_curptr += 4;
+	 
+	    ((**buffer))._buffer =
+	    CORBA_sequence_CORBA_octet_allocbuf(((**buffer))._length);
+	 ((**buffer))._release = CORBA_TRUE;
+	 memcpy(((**buffer))._buffer, _ORBIT_curptr,
+		sizeof(((**buffer))._buffer[_ORBIT_tmpvar_1]) *
+		((**buffer))._length);
+	 _ORBIT_curptr +=
+	    sizeof(((**buffer))._buffer[_ORBIT_tmpvar_1]) *
+	    ((**buffer))._length;
+      } else {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 ((**buffer))._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 
+	    ((**buffer))._buffer =
+	    CORBA_sequence_CORBA_octet_allocbuf(((**buffer))._length);
+	 ((**buffer))._release = CORBA_TRUE;
+	 memcpy(((**buffer))._buffer, _ORBIT_curptr,
+		sizeof(((**buffer))._buffer[_ORBIT_tmpvar_1]) *
+		((**buffer))._length);
+	 _ORBIT_curptr +=
+	    sizeof(((**buffer))._buffer[_ORBIT_tmpvar_1]) *
+	    ((**buffer))._length;
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return;
+      }
+   }
+}
+void
+CorbaFS_Inode_release(CorbaFS_Inode _obj, CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+
+   if (_obj->servant && _obj->vepv && CorbaFS_Inode__classid) {
+      
+	 ((POA_CorbaFS_Inode__epv *) _obj->vepv[CorbaFS_Inode__classid])->
+	 release(_obj->servant, ev);
+      return;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[8];
+      }
+      _ORBIT_operation_name_data =
+      {
+      8, "release"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 12 };
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+      } else {
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return;
+      }
+   }
+}
+CorbaFS_Inode
+CorbaFS_FileSystem_getInode(CorbaFS_FileSystem _obj, const CORBA_char * path,
+			    CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+   CorbaFS_Inode _ORBIT_retval;
+
+   if (_obj->servant && _obj->vepv && CorbaFS_FileSystem__classid) {
+      _ORBIT_retval =
+	 ((POA_CorbaFS_FileSystem__epv *) _obj->
+	  vepv[CorbaFS_FileSystem__classid])->getInode(_obj->servant, path,
+						       ev);
+      return _ORBIT_retval;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[9];
+      }
+      _ORBIT_operation_name_data =
+      {
+      9, "getInode"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 13 };
+      register CORBA_unsigned_long _ORBIT_tmpvar_0;
+      CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_tmpvar_1 = strlen(path) + 1;
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+				       (_ORBIT_send_buffer), 4);
+      {
+	 guchar *_ORBIT_t;
+
+	 _ORBIT_t = alloca(sizeof(_ORBIT_tmpvar_1));
+	 memcpy(_ORBIT_t, &(_ORBIT_tmpvar_1), sizeof(_ORBIT_tmpvar_1));
+	 giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
+					(_ORBIT_send_buffer), (_ORBIT_t),
+					sizeof(_ORBIT_tmpvar_1));
+      }
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     (path),
+				     sizeof(path[_ORBIT_tmpvar_0]) *
+				     _ORBIT_tmpvar_1);
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
+	 _ORBIT_retval =
+	    ORBit_demarshal_object(_ORBIT_recv_buffer,
+				   GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				   connection->orb_data);
+	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      } else {
+	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
+	 _ORBIT_retval =
+	    ORBit_demarshal_object(_ORBIT_recv_buffer,
+				   GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				   connection->orb_data);
+	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return _ORBIT_retval;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return _ORBIT_retval;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return _ORBIT_retval;
+      }
+   }
+}
+CorbaFS_DirEntSeq *
+CorbaFS_FileSystem_readdir(CorbaFS_FileSystem _obj, const CORBA_char * path,
+			   CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+   CorbaFS_DirEntSeq *_ORBIT_retval;
+   register CORBA_unsigned_long _ORBIT_tmpvar_5;
+   register CORBA_unsigned_long _ORBIT_tmpvar_6;
+   CORBA_unsigned_long _ORBIT_tmpvar_7;
+
+   if (_obj->servant && _obj->vepv && CorbaFS_FileSystem__classid) {
+      _ORBIT_retval =
+	 ((POA_CorbaFS_FileSystem__epv *) _obj->
+	  vepv[CorbaFS_FileSystem__classid])->readdir(_obj->servant, path,
+						      ev);
+      return _ORBIT_retval;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[8];
+      }
+      _ORBIT_operation_name_data =
+      {
+      8, "readdir"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 12 };
+      register CORBA_unsigned_long _ORBIT_tmpvar_0;
+      CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_tmpvar_1 = strlen(path) + 1;
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+				       (_ORBIT_send_buffer), 4);
+      {
+	 guchar *_ORBIT_t;
+
+	 _ORBIT_t = alloca(sizeof(_ORBIT_tmpvar_1));
+	 memcpy(_ORBIT_t, &(_ORBIT_tmpvar_1), sizeof(_ORBIT_tmpvar_1));
+	 giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
+					(_ORBIT_send_buffer), (_ORBIT_t),
+					sizeof(_ORBIT_tmpvar_1));
+      }
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     (path),
+				     sizeof(path[_ORBIT_tmpvar_0]) *
+				     _ORBIT_tmpvar_1);
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_retval = CorbaFS_DirEntSeq__alloc();
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & ((*_ORBIT_retval)._length))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	 _ORBIT_curptr += 4;
+	 
+	    (*_ORBIT_retval)._buffer =
+	    CORBA_sequence_CorbaFS_dirent_allocbuf((*_ORBIT_retval)._length);
+	 (*_ORBIT_retval)._release = CORBA_TRUE;
+	 for (_ORBIT_tmpvar_5 = 0; _ORBIT_tmpvar_5 < (*_ORBIT_retval)._length;
+	      _ORBIT_tmpvar_5++) {
+	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	    
+	       (*
+	     ((guint32 *) &
+	   ((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].inode))) =
+GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	    
+	       (*((guint32 *) & (_ORBIT_tmpvar_7))) =
+	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	    _ORBIT_curptr += 4;
+	    
+	       (*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].name =
+	       CORBA_string_alloc(_ORBIT_tmpvar_7);
+	    memcpy((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].name,
+		   _ORBIT_curptr,
+		   sizeof((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].
+			  name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7);
+	    _ORBIT_curptr +=
+	       sizeof((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].
+		      name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
+	 }
+
+      } else {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 (*_ORBIT_retval)._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 
+	    (*_ORBIT_retval)._buffer =
+	    CORBA_sequence_CorbaFS_dirent_allocbuf((*_ORBIT_retval)._length);
+	 (*_ORBIT_retval)._release = CORBA_TRUE;
+	 for (_ORBIT_tmpvar_5 = 0; _ORBIT_tmpvar_5 < (*_ORBIT_retval)._length;
+	      _ORBIT_tmpvar_5++) {
+	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	    (*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].inode = *((CORBA_long *) _ORBIT_curptr);
+	    _ORBIT_curptr += 4;
+	    _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	    _ORBIT_curptr += 4;
+	    
+	       (*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].name =
+	       CORBA_string_alloc(_ORBIT_tmpvar_7);
+	    memcpy((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].name,
+		   _ORBIT_curptr,
+		   sizeof((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].
+			  name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7);
+	    _ORBIT_curptr +=
+	       sizeof((*_ORBIT_retval)._buffer[_ORBIT_tmpvar_5].
+		      name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
+	 }
+
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return _ORBIT_retval;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return _ORBIT_retval;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return _ORBIT_retval;
+      }
+   }
+}
+CORBA_char *
+CorbaFS_FileSystem_readlink(CorbaFS_FileSystem _obj,
+			    const CORBA_char * filename,
+			    CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+   CORBA_char *_ORBIT_retval;
+   register CORBA_unsigned_long _ORBIT_tmpvar_4;
+   CORBA_unsigned_long _ORBIT_tmpvar_5;
+
+   if (_obj->servant && _obj->vepv && CorbaFS_FileSystem__classid) {
+      _ORBIT_retval =
+	 ((POA_CorbaFS_FileSystem__epv *) _obj->
+	  vepv[CorbaFS_FileSystem__classid])->readlink(_obj->servant,
+						       filename, ev);
+      return _ORBIT_retval;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[9];
+      }
+      _ORBIT_operation_name_data =
+      {
+      9, "readlink"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 13 };
+      register CORBA_unsigned_long _ORBIT_tmpvar_0;
+      CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_tmpvar_1 = strlen(filename) + 1;
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+				       (_ORBIT_send_buffer), 4);
+      {
+	 guchar *_ORBIT_t;
+
+	 _ORBIT_t = alloca(sizeof(_ORBIT_tmpvar_1));
+	 memcpy(_ORBIT_t, &(_ORBIT_tmpvar_1), sizeof(_ORBIT_tmpvar_1));
+	 giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
+					(_ORBIT_send_buffer), (_ORBIT_t),
+					sizeof(_ORBIT_tmpvar_1));
+      }
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     (filename),
+				     sizeof(filename[_ORBIT_tmpvar_0]) *
+				     _ORBIT_tmpvar_1);
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & (_ORBIT_tmpvar_5))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	 _ORBIT_curptr += 4;
+	 _ORBIT_retval = CORBA_string_alloc(_ORBIT_tmpvar_5);
+	 memcpy(_ORBIT_retval, _ORBIT_curptr,
+		sizeof(_ORBIT_retval[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5);
+	 _ORBIT_curptr +=
+	    sizeof(_ORBIT_retval[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
+      } else {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 _ORBIT_retval = CORBA_string_alloc(_ORBIT_tmpvar_5);
+	 memcpy(_ORBIT_retval, _ORBIT_curptr,
+		sizeof(_ORBIT_retval[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5);
+	 _ORBIT_curptr +=
+	    sizeof(_ORBIT_retval[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return _ORBIT_retval;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return _ORBIT_retval;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return _ORBIT_retval;
+      }
+   }
+}
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-user-client.c linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-user-client.c
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS-user-client.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS-user-client.c	Thu Feb  1 11:47:03 2001
@@ -0,0 +1,92 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <orb/orbit.h>
+
+#include "CorbaFS.h"
+
+CorbaFS_FileSystem fs;
+
+int
+main (int argc, char *argv[])
+{
+    CORBA_Environment ev;
+    CORBA_ORB orb;
+    CorbaFS_Inode inode;
+    CorbaFS_Buffer *buffer;
+    CorbaFS_DirEntSeq *dirents;
+    CorbaFS_dirent *dirent;
+    
+    CORBA_unsigned_short mode;
+    CORBA_unsigned_long uid;
+    CORBA_unsigned_long gid;
+    CORBA_unsigned_long size;
+    CORBA_unsigned_long inodeNum;
+    CORBA_unsigned_short numLinks;
+    CORBA_long atime;
+    CORBA_long mtime;
+    CORBA_long ctime;
+    
+    int i;
+    
+    int niters = 10;
+
+    CORBA_exception_init(&ev);
+    orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", &ev);
+
+    if(argc < 2)
+      {
+	printf("Need a binding ID thing as argv[1]\n");
+	return 1;
+      }
+
+
+    fs = CORBA_ORB_string_to_object(orb, argv[1], &ev);
+    if (!fs) {
+	printf("Cannot bind to %s\n", argv[1]);
+	return 1;
+    }
+    
+    if (argc >= 3)
+            inode = CorbaFS_FileSystem_getInode(fs, argv[2], &ev);
+    else
+            inode = CorbaFS_FileSystem_getInode(fs, "/proc/cpuinfo", &ev);
+    
+    if (!inode)
+    {
+            printf("Cannot get inode\n");
+    }
+
+    CorbaFS_Inode_getStatus(inode, 
+                            &mode,
+                            &uid,
+                            &gid,
+                            &size,
+                            &inodeNum,
+                            &numLinks,
+                            &atime,
+                            &mtime,
+                            &ctime,
+                            &ev);
+    
+    printf("inode = %x\n", inode);
+    CorbaFS_Inode_readpage(inode, &buffer, 1000, 100, &ev);
+    printf("readpage got %d bytes\n", buffer->_length);
+    printf("readpage returned : %s\n", buffer->_buffer);
+
+    if (argc >= 3)
+            dirents = CorbaFS_FileSystem_readdir(fs, argv[2], &ev);
+    else
+            dirents = CorbaFS_FileSystem_readdir(fs, "/", &ev);
+
+    dirent = dirents->_buffer;
+    for (i = 0; i < dirents->_length; i++)
+    {
+            printf("%d = %s\n", dirent->inode, dirent->name);
+            dirent++;
+    }
+    
+    CORBA_Object_release(fs, &ev);
+    CORBA_Object_release((CORBA_Object)orb, &ev);
+
+    return 0;
+}
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS.h linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS.h
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/CorbaFS.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/CorbaFS.h	Thu Feb  1 16:36:08 2001
@@ -0,0 +1,349 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <glib.h>
+#define ORBIT_IDL_SERIAL 9
+#include <orb/orbit.h>
+
+#ifndef CorbaFS_H
+#define CorbaFS_H 1
+#ifdef __cplusplus
+extern "C"
+{
+#endif				/* __cplusplus */
+
+/** typedefs **/
+#if !defined(_CorbaFS_dirent_defined)
+#define _CorbaFS_dirent_defined 1
+   typedef struct
+   {
+      CORBA_long inode;
+      CORBA_char *name;
+   }
+   CorbaFS_dirent;
+
+#if !defined(TC_IMPL_TC_CorbaFS_dirent_0)
+#define TC_IMPL_TC_CorbaFS_dirent_0 'C'
+#define TC_IMPL_TC_CorbaFS_dirent_1 'o'
+#define TC_IMPL_TC_CorbaFS_dirent_2 'r'
+#define TC_IMPL_TC_CorbaFS_dirent_3 'b'
+#define TC_IMPL_TC_CorbaFS_dirent_4 'a'
+#define TC_IMPL_TC_CorbaFS_dirent_5 'F'
+#define TC_IMPL_TC_CorbaFS_dirent_6 'S'
+   extern const struct CORBA_TypeCode_struct TC_CorbaFS_dirent_struct;
+#define TC_CorbaFS_dirent ((CORBA_TypeCode)&TC_CorbaFS_dirent_struct)
+#endif
+   extern CorbaFS_dirent *CorbaFS_dirent__alloc(void);
+   extern gpointer CorbaFS_dirent__free(gpointer mem, gpointer dat,
+					CORBA_boolean free_strings);	/* ORBit internal use */
+#endif
+#if !defined(ORBIT_DECL_CORBA_sequence_CorbaFS_dirent) && !defined(_CORBA_sequence_CorbaFS_dirent_defined)
+#define ORBIT_DECL_CORBA_sequence_CorbaFS_dirent 1
+#define _CORBA_sequence_CorbaFS_dirent_defined 1
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_0 'C'
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_1 'o'
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_2 'r'
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_3 'b'
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_4 'a'
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_5 'F'
+#define ORBIT_IMPL_CORBA_sequence_CorbaFS_dirent_6 'S'
+   typedef struct
+   {
+      CORBA_unsigned_long _maximum,
+       _length;
+      CorbaFS_dirent *_buffer;
+      CORBA_boolean _release;
+   }
+   CORBA_sequence_CorbaFS_dirent;
+#if !defined(TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_0)
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_0 'C'
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_1 'o'
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_2 'r'
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_3 'b'
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_4 'a'
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_5 'F'
+#define TC_IMPL_TC_CORBA_sequence_CorbaFS_dirent_6 'S'
+   extern const struct CORBA_TypeCode_struct
+      TC_CORBA_sequence_CorbaFS_dirent_struct;
+#define TC_CORBA_sequence_CorbaFS_dirent ((CORBA_TypeCode)&TC_CORBA_sequence_CorbaFS_dirent_struct)
+#endif
+   extern CORBA_sequence_CorbaFS_dirent
+      *CORBA_sequence_CorbaFS_dirent__alloc(void);
+   extern gpointer CORBA_sequence_CorbaFS_dirent__free(gpointer mem,
+						       gpointer dat,
+						       CORBA_boolean free_strings);	/* ORBit internal use */
+   CorbaFS_dirent *CORBA_sequence_CorbaFS_dirent_allocbuf(CORBA_unsigned_long
+							  len);
+#endif
+#if !defined(_CorbaFS_DirEntSeq_defined)
+#define _CorbaFS_DirEntSeq_defined 1
+   typedef CORBA_sequence_CorbaFS_dirent CorbaFS_DirEntSeq;
+#if !defined(TC_IMPL_TC_CorbaFS_DirEntSeq_0)
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_0 'C'
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_1 'o'
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_2 'r'
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_3 'b'
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_4 'a'
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_5 'F'
+#define TC_IMPL_TC_CorbaFS_DirEntSeq_6 'S'
+   extern const struct CORBA_TypeCode_struct TC_CorbaFS_DirEntSeq_struct;
+#define TC_CorbaFS_DirEntSeq ((CORBA_TypeCode)&TC_CorbaFS_DirEntSeq_struct)
+#endif
+   extern CorbaFS_DirEntSeq *CorbaFS_DirEntSeq__alloc(void);
+   extern gpointer CorbaFS_DirEntSeq__free(gpointer mem, gpointer dat,
+					   CORBA_boolean free_strings);	/* ORBit internal use */
+#endif
+#if !defined(ORBIT_DECL_CORBA_sequence_CORBA_octet) && !defined(_CORBA_sequence_CORBA_octet_defined)
+#define ORBIT_DECL_CORBA_sequence_CORBA_octet 1
+#define _CORBA_sequence_CORBA_octet_defined 1
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_0 'C'
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_1 'o'
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_2 'r'
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_3 'b'
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_4 'a'
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_5 'F'
+#define ORBIT_IMPL_CORBA_sequence_CORBA_octet_6 'S'
+   typedef struct
+   {
+      CORBA_unsigned_long _maximum,
+       _length;
+      CORBA_octet *_buffer;
+      CORBA_boolean _release;
+   }
+   CORBA_sequence_CORBA_octet;
+#if !defined(TC_IMPL_TC_CORBA_sequence_CORBA_octet_0)
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_0 'C'
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_1 'o'
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_2 'r'
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_3 'b'
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_4 'a'
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_5 'F'
+#define TC_IMPL_TC_CORBA_sequence_CORBA_octet_6 'S'
+   extern const struct CORBA_TypeCode_struct
+      TC_CORBA_sequence_CORBA_octet_struct;
+#define TC_CORBA_sequence_CORBA_octet ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_octet_struct)
+#endif
+   extern CORBA_sequence_CORBA_octet *CORBA_sequence_CORBA_octet__alloc(void);
+   extern gpointer CORBA_sequence_CORBA_octet__free(gpointer mem,
+						    gpointer dat,
+						    CORBA_boolean free_strings);	/* ORBit internal use */
+   CORBA_octet *CORBA_sequence_CORBA_octet_allocbuf(CORBA_unsigned_long len);
+#endif
+#if !defined(_CorbaFS_Buffer_defined)
+#define _CorbaFS_Buffer_defined 1
+   typedef CORBA_sequence_CORBA_octet CorbaFS_Buffer;
+#if !defined(TC_IMPL_TC_CorbaFS_Buffer_0)
+#define TC_IMPL_TC_CorbaFS_Buffer_0 'C'
+#define TC_IMPL_TC_CorbaFS_Buffer_1 'o'
+#define TC_IMPL_TC_CorbaFS_Buffer_2 'r'
+#define TC_IMPL_TC_CorbaFS_Buffer_3 'b'
+#define TC_IMPL_TC_CorbaFS_Buffer_4 'a'
+#define TC_IMPL_TC_CorbaFS_Buffer_5 'F'
+#define TC_IMPL_TC_CorbaFS_Buffer_6 'S'
+   extern const struct CORBA_TypeCode_struct TC_CorbaFS_Buffer_struct;
+#define TC_CorbaFS_Buffer ((CORBA_TypeCode)&TC_CorbaFS_Buffer_struct)
+#endif
+   extern CorbaFS_Buffer *CorbaFS_Buffer__alloc(void);
+   extern gpointer CorbaFS_Buffer__free(gpointer mem, gpointer dat,
+					CORBA_boolean free_strings);	/* ORBit internal use */
+#endif
+#if !defined(ORBIT_DECL_CorbaFS_Inode) && !defined(_CorbaFS_Inode_defined)
+#define ORBIT_DECL_CorbaFS_Inode 1
+#define _CorbaFS_Inode_defined 1
+#define CorbaFS_Inode__free CORBA_Object__free
+   typedef CORBA_Object CorbaFS_Inode;
+   extern CORBA_unsigned_long CorbaFS_Inode__classid;
+#if !defined(TC_IMPL_TC_CorbaFS_Inode_0)
+#define TC_IMPL_TC_CorbaFS_Inode_0 'C'
+#define TC_IMPL_TC_CorbaFS_Inode_1 'o'
+#define TC_IMPL_TC_CorbaFS_Inode_2 'r'
+#define TC_IMPL_TC_CorbaFS_Inode_3 'b'
+#define TC_IMPL_TC_CorbaFS_Inode_4 'a'
+#define TC_IMPL_TC_CorbaFS_Inode_5 'F'
+#define TC_IMPL_TC_CorbaFS_Inode_6 'S'
+   extern const struct CORBA_TypeCode_struct TC_CorbaFS_Inode_struct;
+#define TC_CorbaFS_Inode ((CORBA_TypeCode)&TC_CorbaFS_Inode_struct)
+#endif
+#endif
+#if !defined(ORBIT_DECL_CorbaFS_FileSystem) && !defined(_CorbaFS_FileSystem_defined)
+#define ORBIT_DECL_CorbaFS_FileSystem 1
+#define _CorbaFS_FileSystem_defined 1
+#define CorbaFS_FileSystem__free CORBA_Object__free
+   typedef CORBA_Object CorbaFS_FileSystem;
+   extern CORBA_unsigned_long CorbaFS_FileSystem__classid;
+#if !defined(TC_IMPL_TC_CorbaFS_FileSystem_0)
+#define TC_IMPL_TC_CorbaFS_FileSystem_0 'C'
+#define TC_IMPL_TC_CorbaFS_FileSystem_1 'o'
+#define TC_IMPL_TC_CorbaFS_FileSystem_2 'r'
+#define TC_IMPL_TC_CorbaFS_FileSystem_3 'b'
+#define TC_IMPL_TC_CorbaFS_FileSystem_4 'a'
+#define TC_IMPL_TC_CorbaFS_FileSystem_5 'F'
+#define TC_IMPL_TC_CorbaFS_FileSystem_6 'S'
+   extern const struct CORBA_TypeCode_struct TC_CorbaFS_FileSystem_struct;
+#define TC_CorbaFS_FileSystem ((CORBA_TypeCode)&TC_CorbaFS_FileSystem_struct)
+#endif
+#endif
+
+/** POA structures **/
+   typedef struct
+   {
+      void *_private;
+      void (*getStatus) (PortableServer_Servant _servant,
+			 CORBA_unsigned_short * mode,
+			 CORBA_unsigned_long * uid, CORBA_unsigned_long * gid,
+			 CORBA_unsigned_long * size,
+			 CORBA_unsigned_long * inodeNum,
+			 CORBA_unsigned_short * numLinks, CORBA_long * atime,
+			 CORBA_long * mtime, CORBA_long * ctime,
+			 CORBA_Environment * ev);
+      void (*readpage) (PortableServer_Servant _servant,
+			CorbaFS_Buffer ** buffer, const CORBA_long size,
+			const CORBA_long offset, CORBA_Environment * ev);
+      void (*release) (PortableServer_Servant _servant,
+		       CORBA_Environment * ev);
+   }
+   POA_CorbaFS_Inode__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_CorbaFS_Inode__epv *CorbaFS_Inode_epv;
+   }
+   POA_CorbaFS_Inode__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_CorbaFS_Inode__vepv *vepv;
+   }
+   POA_CorbaFS_Inode;
+   extern void POA_CorbaFS_Inode__init(PortableServer_Servant servant,
+				       CORBA_Environment * ev);
+   extern void POA_CorbaFS_Inode__fini(PortableServer_Servant servant,
+				       CORBA_Environment * ev);
+   typedef struct
+   {
+      void *_private;
+      
+	 CorbaFS_Inode(*getInode) (PortableServer_Servant _servant,
+				   const CORBA_char * path,
+				   CORBA_Environment * ev);
+      CorbaFS_DirEntSeq *(*readdir) (PortableServer_Servant _servant,
+				     const CORBA_char * path,
+				     CORBA_Environment * ev);
+      CORBA_char *(*readlink) (PortableServer_Servant _servant,
+			       const CORBA_char * filename,
+			       CORBA_Environment * ev);
+   }
+   POA_CorbaFS_FileSystem__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_CorbaFS_FileSystem__epv *CorbaFS_FileSystem_epv;
+   }
+   POA_CorbaFS_FileSystem__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_CorbaFS_FileSystem__vepv *vepv;
+   }
+   POA_CorbaFS_FileSystem;
+   extern void POA_CorbaFS_FileSystem__init(PortableServer_Servant servant,
+					    CORBA_Environment * ev);
+   extern void POA_CorbaFS_FileSystem__fini(PortableServer_Servant servant,
+					    CORBA_Environment * ev);
+
+/** prototypes **/
+   void CorbaFS_Inode_getStatus(CorbaFS_Inode _obj,
+				CORBA_unsigned_short * mode,
+				CORBA_unsigned_long * uid,
+				CORBA_unsigned_long * gid,
+				CORBA_unsigned_long * size,
+				CORBA_unsigned_long * inodeNum,
+				CORBA_unsigned_short * numLinks,
+				CORBA_long * atime, CORBA_long * mtime,
+				CORBA_long * ctime, CORBA_Environment * ev);
+   void CorbaFS_Inode_readpage(CorbaFS_Inode _obj, CorbaFS_Buffer ** buffer,
+			       const CORBA_long size, const CORBA_long offset,
+			       CORBA_Environment * ev);
+   void CorbaFS_Inode_release(CorbaFS_Inode _obj, CORBA_Environment * ev);
+   CorbaFS_Inode CorbaFS_FileSystem_getInode(CorbaFS_FileSystem _obj,
+					     const CORBA_char * path,
+					     CORBA_Environment * ev);
+   CorbaFS_DirEntSeq *CorbaFS_FileSystem_readdir(CorbaFS_FileSystem _obj,
+						 const CORBA_char * path,
+						 CORBA_Environment * ev);
+   CORBA_char *CorbaFS_FileSystem_readlink(CorbaFS_FileSystem _obj,
+					   const CORBA_char * filename,
+					   CORBA_Environment * ev);
+
+   void _ORBIT_skel_CorbaFS_Inode_getStatus(POA_CorbaFS_Inode *
+					    _ORBIT_servant,
+					    GIOPRecvBuffer *
+					    _ORBIT_recv_buffer,
+					    CORBA_Environment * ev,
+					    void (*_impl_getStatus)
+					    (PortableServer_Servant _servant,
+					     CORBA_unsigned_short * mode,
+					     CORBA_unsigned_long * uid,
+					     CORBA_unsigned_long * gid,
+					     CORBA_unsigned_long * size,
+					     CORBA_unsigned_long * inodeNum,
+					     CORBA_unsigned_short * numLinks,
+					     CORBA_long * atime,
+					     CORBA_long * mtime,
+					     CORBA_long * ctime,
+					     CORBA_Environment * ev));
+   void _ORBIT_skel_CorbaFS_Inode_readpage(POA_CorbaFS_Inode * _ORBIT_servant,
+					   GIOPRecvBuffer *
+					   _ORBIT_recv_buffer,
+					   CORBA_Environment * ev,
+					   void (*_impl_readpage)
+					   (PortableServer_Servant _servant,
+					    CorbaFS_Buffer ** buffer,
+					    const CORBA_long size,
+					    const CORBA_long offset,
+					    CORBA_Environment * ev));
+   void _ORBIT_skel_CorbaFS_Inode_release(POA_CorbaFS_Inode * _ORBIT_servant,
+					  GIOPRecvBuffer * _ORBIT_recv_buffer,
+					  CORBA_Environment * ev,
+					  void (*_impl_release)
+					  (PortableServer_Servant _servant,
+					   CORBA_Environment * ev));
+   void _ORBIT_skel_CorbaFS_FileSystem_getInode(POA_CorbaFS_FileSystem *
+						_ORBIT_servant,
+						GIOPRecvBuffer *
+						_ORBIT_recv_buffer,
+						CORBA_Environment * ev,
+						CorbaFS_Inode(*_impl_getInode)
+						(PortableServer_Servant
+						 _servant,
+						 const CORBA_char * path,
+						 CORBA_Environment * ev));
+   void _ORBIT_skel_CorbaFS_FileSystem_readdir(POA_CorbaFS_FileSystem *
+					       _ORBIT_servant,
+					       GIOPRecvBuffer *
+					       _ORBIT_recv_buffer,
+					       CORBA_Environment * ev,
+					       CorbaFS_DirEntSeq *
+					       (*_impl_readdir)
+					       (PortableServer_Servant
+						_servant,
+						const CORBA_char * path,
+						CORBA_Environment * ev));
+   void _ORBIT_skel_CorbaFS_FileSystem_readlink(POA_CorbaFS_FileSystem *
+						_ORBIT_servant,
+						GIOPRecvBuffer *
+						_ORBIT_recv_buffer,
+						CORBA_Environment * ev,
+						CORBA_char *
+						(*_impl_readlink)
+						(PortableServer_Servant
+						 _servant,
+						 const CORBA_char * filename,
+						 CORBA_Environment * ev));
+#ifdef __cplusplus
+}
+#endif				/* __cplusplus */
+
+#endif
+#undef ORBIT_IDL_SERIAL
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/Makefile linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/Makefile
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/Makefile	Thu Feb  1 11:47:03 2001
@@ -0,0 +1,20 @@
+#
+# Makefile for KORBit CorbaFS client
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := corba-corbafs-client.o
+
+obj-y := CorbaFS-common.o CorbaFS-stubs.o CorbaFS-client.o
+obj-m := $(O_TARGET)
+
+include ../../Makefile.module
+
+CorbaFS-client.c: CorbaFS.h
+
+CorbaFS.h CorbaFS-common.c CorbaFS-stubs.c: ../CorbaFS.idl
+	$(ORBIT_IDL) --noskels ../CorbaFS.idl
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/Makefile.user linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/Makefile.user
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/Makefile.user	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/Makefile.user	Thu Feb  1 11:47:03 2001
@@ -0,0 +1,32 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+PROJECT = CorbaFS
+
+CFLAGS = -Wall `orbit-config --cflags client` -I../../..
+LDFLAGS = `orbit-config --libs client`
+OBJS = $(PROJECT)-common.o $(PROJECT)-stubs.o $(PROJECT)-user-client.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-user-client: $(OBJS)
+	gcc -o $(PROJECT)-user-client $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-user-client.o: $(PROJECT).h
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-stubs.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --noskels ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-user-client
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-skels.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/client/README linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/README
--- linux-2.4.1/net/korbit/modules/CorbaFS/client/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/client/README	Thu Feb  1 11:47:03 2001
@@ -0,0 +1,4 @@
+This module implements the kernel VFS->kORBit interface.  This is called a 'client'
+because it actually USES a CORBA object that is exported from someplace else.
+
+ORB: kORBit
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CVS/Entries	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,6 @@
+/CorbaFS-server.c/1.8/Thu Feb  1 09:47:03 2001//
+/CorbaFS-skelimpl.c/1.10/Thu Feb  1 09:47:04 2001//
+/Makefile/1.5/Thu Feb  1 09:47:04 2001//
+/README/1.2/Thu Feb  1 09:47:04 2001//
+/RunServer.sh/1.1/Thu Feb  1 09:47:04 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CVS/Repository	Thu Feb  1 11:47:03 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CorbaFS/server
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CVS/Root
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CVS/Root	Thu Feb  1 11:47:03 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/CorbaFS-server.c linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CorbaFS-server.c
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/CorbaFS-server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CorbaFS-server.c	Thu Feb  1 11:47:03 2001
@@ -0,0 +1,37 @@
+#include <stdio.h>
+#include "CorbaFS-skelimpl.c"
+
+CORBA_ORB               orb;
+PortableServer_POA      poa;
+CORBA_Environment       *ev;
+PortableServer_ObjectId *objid;
+
+int main(int argc, char *argv[]) {
+        CorbaFS_FileSystem          fs;
+        impl_POA_CorbaFS_FileSystem *fs_impl;
+        
+        PortableServer_POAManager pm;
+        ev = g_new0(CORBA_Environment,1);
+        
+        CORBA_exception_init(ev);
+	printf("Make sure you use TCP/IP and not Unix sockets!\n");
+        
+        orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", ev);
+        poa = (PortableServer_POA)
+                CORBA_ORB_resolve_initial_references(orb,
+                                                     "RootPOA", 
+                                                     ev);
+        fs = impl_CorbaFS_FileSystem__create(poa, ev);
+
+        pm = PortableServer_POA__get_the_POAManager(poa, ev);
+        PortableServer_POAManager_activate(pm, ev);
+
+        fs_impl = PortableServer_POA_reference_to_servant( poa, fs, ev );
+        objid = PortableServer_POA_servant_to_id( poa, fs_impl, ev );
+
+        printf("CorbaFS-server:\n%s\n", CORBA_ORB_object_to_string(orb, fs, ev));
+
+        CORBA_ORB_run(orb, ev);
+
+        return 0;
+}
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/CorbaFS-skelimpl.c linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CorbaFS-skelimpl.c
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/CorbaFS-skelimpl.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/CorbaFS-skelimpl.c	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,353 @@
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <dirent.h>
+
+#include "CorbaFS.h"
+
+/*** App-specific servant structures ***/
+
+#define printf(fmt, args...) fprintf(stderr, fmt, ##args);
+
+typedef struct
+{
+   POA_CorbaFS_Inode servant;
+   PortableServer_POA poa;
+
+        CORBA_char *path;
+#if 0
+        CORBA_unsigned_short mode;
+        CORBA_unsigned_long uid;
+        CORBA_unsigned_long gid;
+        CORBA_unsigned_long size;
+        CORBA_unsigned_long inodeNum;
+        CORBA_unsigned_short numLinks;
+        CORBA_long atime;
+        CORBA_long mtime;
+        CORBA_long ctime;
+#endif
+}
+impl_POA_CorbaFS_Inode;
+
+typedef struct
+{
+   POA_CorbaFS_FileSystem servant;
+   PortableServer_POA poa;
+
+}
+impl_POA_CorbaFS_FileSystem;
+
+/*** Implementation stub prototypes ***/
+
+static void impl_CorbaFS_Inode__destroy(impl_POA_CorbaFS_Inode * servant,
+					CORBA_Environment * ev);
+static void
+impl_CorbaFS_Inode_getStatus(impl_POA_CorbaFS_Inode * servant,
+			     CORBA_unsigned_short * mode,
+			     CORBA_unsigned_long * uid,
+			     CORBA_unsigned_long * gid,
+			     CORBA_unsigned_long * size,
+			     CORBA_unsigned_long * inodeNum,
+			     CORBA_unsigned_short * numLinks,
+			     CORBA_long * atime,
+			     CORBA_long * mtime,
+			     CORBA_long * ctime, CORBA_Environment * ev);
+
+static void
+impl_CorbaFS_Inode_readpage(impl_POA_CorbaFS_Inode * servant,
+			    CorbaFS_Buffer ** buffer,
+			    CORBA_long size,
+			    CORBA_long offset, CORBA_Environment * ev);
+
+static void
+impl_CorbaFS_Inode_release(impl_POA_CorbaFS_Inode * servant,
+			   CORBA_Environment * ev);
+
+static void impl_CorbaFS_FileSystem__destroy(impl_POA_CorbaFS_FileSystem *
+					     servant, CORBA_Environment * ev);
+static CorbaFS_Inode
+impl_CorbaFS_FileSystem_getInode(impl_POA_CorbaFS_FileSystem * servant,
+				 CORBA_char * path, CORBA_Environment * ev);
+
+static CorbaFS_DirEntSeq
+   *impl_CorbaFS_FileSystem_readdir(impl_POA_CorbaFS_FileSystem * servant,
+				    CORBA_char * path,
+
+				    CORBA_Environment * ev);
+
+static CORBA_char
+   *impl_CorbaFS_FileSystem_readlink(impl_POA_CorbaFS_FileSystem * servant,
+				     CORBA_char * filename,
+				     CORBA_Environment * ev);
+
+/*** epv structures ***/
+
+static PortableServer_ServantBase__epv impl_CorbaFS_Inode_base_epv = {
+   NULL,			/* _private data */
+   NULL,			/* finalize routine */
+   NULL,			/* default_POA routine */
+};
+static POA_CorbaFS_Inode__epv impl_CorbaFS_Inode_epv = {
+   NULL,			/* _private */
+   (gpointer) & impl_CorbaFS_Inode_getStatus,
+
+   (gpointer) & impl_CorbaFS_Inode_readpage,
+
+   (gpointer) & impl_CorbaFS_Inode_release,
+
+};
+static PortableServer_ServantBase__epv impl_CorbaFS_FileSystem_base_epv = {
+   NULL,			/* _private data */
+   NULL,			/* finalize routine */
+   NULL,			/* default_POA routine */
+};
+static POA_CorbaFS_FileSystem__epv impl_CorbaFS_FileSystem_epv = {
+   NULL,			/* _private */
+   (gpointer) & impl_CorbaFS_FileSystem_getInode,
+
+   (gpointer) & impl_CorbaFS_FileSystem_readdir,
+
+   (gpointer) & impl_CorbaFS_FileSystem_readlink,
+
+};
+
+/*** vepv structures ***/
+
+static POA_CorbaFS_Inode__vepv impl_CorbaFS_Inode_vepv = {
+   &impl_CorbaFS_Inode_base_epv,
+   &impl_CorbaFS_Inode_epv,
+};
+static POA_CorbaFS_FileSystem__vepv impl_CorbaFS_FileSystem_vepv = {
+   &impl_CorbaFS_FileSystem_base_epv,
+   &impl_CorbaFS_FileSystem_epv,
+};
+
+/*** Stub implementations ***/
+
+static CorbaFS_Inode
+impl_CorbaFS_Inode__create(PortableServer_POA poa, CORBA_Environment * ev)
+{
+   CorbaFS_Inode retval;
+   impl_POA_CorbaFS_Inode *newservant;
+   PortableServer_ObjectId *objid;
+
+   newservant = g_new0(impl_POA_CorbaFS_Inode, 1);
+   newservant->servant.vepv = &impl_CorbaFS_Inode_vepv;
+   newservant->poa = poa;
+   POA_CorbaFS_Inode__init((PortableServer_Servant) newservant, ev);
+   objid = PortableServer_POA_activate_object(poa, newservant, ev);
+   CORBA_free(objid);
+   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);
+
+   return retval;
+}
+
+static void
+impl_CorbaFS_Inode__destroy(impl_POA_CorbaFS_Inode * servant,
+			    CORBA_Environment * ev)
+{
+   PortableServer_ObjectId *objid;
+
+   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
+   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
+   CORBA_free(objid);
+
+   POA_CorbaFS_Inode__fini((PortableServer_Servant) servant, ev);
+   g_free(servant);
+}
+
+static void
+impl_CorbaFS_Inode_getStatus(impl_POA_CorbaFS_Inode * servant,
+			     CORBA_unsigned_short * mode,
+			     CORBA_unsigned_long * uid,
+			     CORBA_unsigned_long * gid,
+			     CORBA_unsigned_long * size,
+			     CORBA_unsigned_long * inodeNum,
+			     CORBA_unsigned_short * numLinks,
+			     CORBA_long * atime,
+			     CORBA_long * mtime,
+			     CORBA_long * ctime, CORBA_Environment * ev)
+{
+        struct stat buf;
+
+        printf("Inode_getStatus()\n");
+        printf("Inode path = %s\n", servant->path);
+        lstat(servant->path, &buf);
+        
+        *mode = buf.st_mode;
+        *uid = buf.st_uid;
+        *gid = buf.st_gid;
+        *size = buf.st_size;
+        *inodeNum = buf.st_ino;
+        *numLinks = buf.st_nlink;
+        *atime = buf.st_atime;
+        *mtime = buf.st_mtime;
+        *ctime = buf.st_ctime;
+}
+
+static void
+impl_CorbaFS_Inode_readpage(impl_POA_CorbaFS_Inode * servant,
+			    CorbaFS_Buffer ** buffer,
+			    CORBA_long size,
+			    CORBA_long offset, CORBA_Environment * ev)
+{
+        int fd = -1, c = 0;
+        
+        printf("Inode_readpage(buffer, %d, %d)\n", size, offset);
+        printf("Inode_readpage : path = %s\n", servant->path);
+
+        *buffer = CorbaFS_Buffer__alloc();
+        (*buffer)->_maximum = size;
+        (*buffer)->_buffer = CORBA_octet_allocbuf(size);
+        
+        memset((*buffer)->_buffer, size, 0);
+
+        fd = open(servant->path, O_RDONLY);
+        printf("Inode_readpage : fd = %d\n", fd);
+        lseek(fd, offset, SEEK_SET);
+        c = read(fd, (*buffer)->_buffer, size);
+        printf("Inode_readpage : read %d bytes\n", c);
+        (*buffer)->_length = c;
+        close(fd);
+}
+
+static void
+impl_CorbaFS_Inode_release(impl_POA_CorbaFS_Inode * servant,
+			   CORBA_Environment * ev)
+{
+        printf("Inode_release()\n");
+}
+
+static CorbaFS_FileSystem
+impl_CorbaFS_FileSystem__create(PortableServer_POA poa,
+				CORBA_Environment * ev)
+{
+   CorbaFS_FileSystem retval;
+   impl_POA_CorbaFS_FileSystem *newservant;
+   PortableServer_ObjectId *objid;
+
+   newservant = g_new0(impl_POA_CorbaFS_FileSystem, 1);
+   newservant->servant.vepv = &impl_CorbaFS_FileSystem_vepv;
+   newservant->poa = poa;
+   POA_CorbaFS_FileSystem__init((PortableServer_Servant) newservant, ev);
+   objid = PortableServer_POA_activate_object(poa, newservant, ev);
+   CORBA_free(objid);
+   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);
+
+   return retval;
+}
+
+static void
+impl_CorbaFS_FileSystem__destroy(impl_POA_CorbaFS_FileSystem * servant,
+				 CORBA_Environment * ev)
+{
+   PortableServer_ObjectId *objid;
+
+   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
+   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
+   CORBA_free(objid);
+
+   POA_CorbaFS_FileSystem__fini((PortableServer_Servant) servant, ev);
+   g_free(servant);
+}
+
+static CorbaFS_Inode
+impl_CorbaFS_FileSystem_getInode(impl_POA_CorbaFS_FileSystem * servant,
+				 CORBA_char * path, CORBA_Environment * ev)
+{
+   CorbaFS_Inode retval;
+   impl_POA_CorbaFS_Inode *inode;
+   
+   printf("FileSystem_getInode(%s)\n", path);
+
+   retval = impl_CorbaFS_Inode__create(servant->poa, ev);
+
+   inode = PortableServer_POA_reference_to_servant( servant->poa, retval, ev );
+   inode->path = CORBA_string_dup(path);
+#if 0
+   inode->mode = 0040777; /* world-readable directory */
+   inode->uid = 0;
+   inode->gid = 0;
+   inode->size = 4096;
+   inode->inodeNum = inodeNum++;
+   inode->numLinks = 1;
+   inode->atime = 0;
+   inode->mtime = 100;
+   inode->ctime = 10000;
+#endif
+
+   return retval;
+}
+
+static CorbaFS_DirEntSeq *
+impl_CorbaFS_FileSystem_readdir(impl_POA_CorbaFS_FileSystem * servant,
+				CORBA_char * path, CORBA_Environment * ev)
+{
+   CorbaFS_DirEntSeq *retval;
+   CorbaFS_dirent *dirent;
+
+   DIR *dir;
+   struct dirent *dirp;
+   int c;
+   
+   printf("FileSystem_readdir(%s)\n", path);
+
+   retval = CorbaFS_DirEntSeq__alloc();
+   retval->_maximum = 0;
+   retval->_length = 0;
+
+   dir = opendir(path);
+   if (dir == NULL)
+           return retval;
+   
+   c = 0;
+   while ((dirp = readdir(dir)))
+           c++;
+   
+   rewinddir(dir);
+   
+   printf("%d directories\n", c);
+   
+   retval->_buffer = CORBA_sequence_CorbaFS_dirent_allocbuf(c);
+   retval->_maximum = c;
+   dirent = retval->_buffer;
+   
+   c = 0;
+   while ((dirp = readdir(dir)) && (c < retval->_maximum)) 
+   {
+           printf("Adding directory %d : %s (%d)\n", c, dirp->d_name, dirp->d_ino);
+           
+           dirent[c].inode = dirp->d_ino;
+           dirent[c].name = CORBA_string_dup(dirp->d_name);
+           c++;
+   }
+   retval->_length = c;
+
+   closedir(dir);
+   
+   return retval;
+}
+
+static CORBA_char *
+impl_CorbaFS_FileSystem_readlink(impl_POA_CorbaFS_FileSystem * servant,
+				 CORBA_char * filename,
+				 CORBA_Environment * ev)
+{
+   CORBA_char *retval = CORBA_OBJECT_NIL;
+   char tmp[MAXPATHLEN + 1];
+   int len;
+   
+   printf("FileSystem_readlink(%s) = ", filename);
+   len = readlink(filename, tmp, MAXPATHLEN);
+   if (len != -1)
+   {
+           tmp[len] = '\0';
+           retval = CORBA_string_dup(tmp);
+   }
+
+   printf("%s\n", retval);
+   
+   return retval;
+}
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/Makefile linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/Makefile
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/Makefile	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,32 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+PROJECT = CorbaFS
+
+CFLAGS = -Wall `orbit-config --cflags server` -I../../..
+LDFLAGS = `orbit-config --libs server`
+OBJS = $(PROJECT)-common.o $(PROJECT)-skels.o $(PROJECT)-server.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-server: $(OBJS)
+	gcc -o $(PROJECT)-server $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-server.o: $(PROJECT).h $(PROJECT)-skelimpl.c
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-skels.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --nostubs ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-server
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-skels.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/README linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/README
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/README	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,8 @@
+This server provides an NFS like capability of exporting an existing filesystem.
+
+ORB: ORBit
+Status: Working! (for readonly fs's)
+
+NOTE!!!!:  When starting this server make sure you pass ORBit the options to
+           have it use ipv4 sockets and not unix domain sockets, or else bad
+           things will happen.  You can use the included RunServer script.
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server/RunServer.sh linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/RunServer.sh
--- linux-2.4.1/net/korbit/modules/CorbaFS/server/RunServer.sh	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server/RunServer.sh	Thu Feb  1 11:47:04 2001
@@ -0,0 +1 @@
+./CorbaFS-server -ORBIIOPUSock=0 -ORBIIOPIPv4=1
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/CVS/Entries
--- linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/CVS/Entries	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,3 @@
+/PerlServer/1.2/Thu Feb  1 09:47:04 2001//
+/README/1.1/Thu Feb  1 09:47:04 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/CVS/Repository
--- linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/CVS/Repository	Thu Feb  1 11:47:04 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/CorbaFS/server-perl
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/CVS/Root linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/CVS/Root
--- linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/CVS/Root	Thu Feb  1 11:47:04 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/PerlServer linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/PerlServer
--- linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/PerlServer	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/PerlServer	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,67 @@
+#!/usr/bin/perl -w
+use CORBA::ORBit idl => [ qw(../CorbaFS.idl) ];
+use Error qw(:try);
+use strict;
+
+
+package MyFSInode;
+@MyFSInode::ISA = qw(POA_CorbaFS::Inode);
+
+sub new {
+  my $self = bless { name => shift };
+  print "INODE CREATED: $self->{name}!\n";
+}
+
+sub getStatus {
+  my ($self) = @_;
+  print "$self->getStatus()\n";
+}
+
+sub readpage {
+  return "";
+}
+
+sub release {
+}
+
+
+package MyFileSystem;
+@MyFileSystem::ISA = qw(POA_CorbaFS::FileSystem);
+
+sub new {
+  my $self = bless { root => '/home' };
+}
+
+sub getInode {
+  my $path = shift;
+  print "getInode($path)\n";
+  return new MyFSInode($path);
+}
+
+sub readdir {
+  my $path = shift;
+  print "readdir($path)\n";
+  return [ { inode => 1, name => '...' } ];
+}
+
+sub readlink {
+  my $path = shift;
+  print "readlink($path)\n";
+  return "fredrik";
+}
+
+
+package Main;
+
+my $orb = CORBA::ORB_init("orbit-local-orb");
+my $poa = $orb->resolve_initial_references("RootPOA");
+
+my $Server = new MyFileSystem();
+my $id = $poa->activate_object($Server);
+my $ref = $orb->object_to_string($poa->id_to_reference($id));
+
+print "$ref\n";
+
+print "Running orb:\n";
+$orb->run();
+exit(0);
diff -urN linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/README linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/README
--- linux-2.4.1/net/korbit/modules/CorbaFS/server-perl/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/CorbaFS/server-perl/README	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,4 @@
+Test filesystem implementation in Perl.
+
+ORB: ORBit/Perl
+Status: horribly broken
diff -urN linux-2.4.1/net/korbit/modules/Echo/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Echo/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Entries	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,4 @@
+/Makefile/1.3/Thu Feb  1 09:47:04 2001//
+/README/1.1/Thu Feb  1 09:47:05 2001//
+/echo.idl/1.1/Thu Feb  1 09:47:05 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Echo/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/Echo/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Entries.Log	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,3 @@
+A D/client////
+A D/client-perl////
+A D/server////
diff -urN linux-2.4.1/net/korbit/modules/Echo/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Echo/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Repository	Thu Feb  1 11:47:04 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Echo
diff -urN linux-2.4.1/net/korbit/modules/Echo/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Root
--- linux-2.4.1/net/korbit/modules/Echo/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/CVS/Root	Thu Feb  1 11:47:04 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Echo/Makefile linux-2.4.1-korbit/net/korbit/modules/Echo/Makefile
--- linux-2.4.1/net/korbit/modules/Echo/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/Makefile	Thu Feb  1 11:47:04 2001
@@ -0,0 +1,11 @@
+#
+# Makefile for KORBit/modules/Console
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+subdir-$(CONFIG_CORBA_ECHO) := client server
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/Echo/README linux-2.4.1-korbit/net/korbit/modules/Echo/README
--- linux-2.4.1/net/korbit/modules/Echo/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/README	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,2 @@
+The Echo test is very similar to the console test, but it also "returns" a 
+"random" number.  The random number, in our case, is simply a constant.
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Echo/client/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Echo/client/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/CVS/Entries	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,6 @@
+/Makefile/1.4/Thu Feb  1 09:47:05 2001//
+/Makefile.user/1.1/Thu Feb  1 09:47:05 2001//
+/README/1.1/Thu Feb  1 09:47:05 2001//
+/RunClient.sh/1.1/Thu Feb  1 09:47:05 2001//
+/echo-client.c/1.6/Thu Feb  1 09:47:05 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Echo/client/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Echo/client/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/CVS/Repository	Thu Feb  1 11:47:05 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Echo/client
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Echo/client/CVS/Root
--- linux-2.4.1/net/korbit/modules/Echo/client/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/CVS/Root	Thu Feb  1 11:47:05 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/Makefile linux-2.4.1-korbit/net/korbit/modules/Echo/client/Makefile
--- linux-2.4.1/net/korbit/modules/Echo/client/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/Makefile	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,20 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := corba-echo-client.o
+
+obj-y := echo-common.o echo-stubs.o echo-client.o
+obj-m := $(O_TARGET)
+
+include ../../Makefile.module
+
+echo-client.c: echo.h
+
+echo.h echo-common.c echo-stubs.c: ../echo.idl
+	$(ORBIT_IDL) --noskels ../echo.idl
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/Makefile.user linux-2.4.1-korbit/net/korbit/modules/Echo/client/Makefile.user
--- linux-2.4.1/net/korbit/modules/Echo/client/Makefile.user	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/Makefile.user	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,32 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+PROJECT = echo
+
+CFLAGS = -Wall `orbit-config --cflags client` -I../../..
+LDFLAGS = `orbit-config --libs client`
+OBJS = $(PROJECT)-common.o $(PROJECT)-stubs.o $(PROJECT)-client.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-client: $(OBJS)
+	gcc -o $(PROJECT)-client $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-client.c: $(PROJECT).h
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-stubs.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --noskels ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-client
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-stubs.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/README linux-2.4.1-korbit/net/korbit/modules/Echo/client/README
--- linux-2.4.1/net/korbit/modules/Echo/client/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/README	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,4 @@
+This simply tests the Echo service.
+
+ORB: ORBit
+Status: working
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/RunClient.sh linux-2.4.1-korbit/net/korbit/modules/Echo/client/RunClient.sh
--- linux-2.4.1/net/korbit/modules/Echo/client/RunClient.sh	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/RunClient.sh	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,3 @@
+#!/bin/sh
+date
+./echo-client `cat /proc/corba/echo-server` 5
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/echo-client.c linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo-client.c
--- linux-2.4.1/net/korbit/modules/Echo/client/echo-client.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo-client.c	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,119 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <orb/orbit.h>
+
+#ifdef __KERNEL__
+#include <linux/init.h>
+#include <linux/module.h>
+#include "korbit.h"
+#endif
+#include "echo.h"
+
+Echo echo_client, bec;
+
+#define BATCH_SIZE 1
+
+
+#ifndef __KERNEL__
+int main (int argc, char *argv[]) {
+#else
+int __init corba_echo_init(void) {
+    int argc = 1; char *argv[] = { "echo-client", 0, 0 };
+#endif
+    CORBA_Environment ev;
+    CORBA_ORB orb;
+    CORBA_long rv;
+    char buf[30];
+    int i, j;
+
+    int niters = 5;
+
+#ifndef __KERNEL__    
+    struct timeval start, end;
+    long diff, diffsum = 0;
+#endif
+
+    CORBA_exception_init(&ev);
+    orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", &ev);
+
+#ifdef __KERNEL__
+    {
+            int c, fd = open("/tmp/echo-ior", O_RDONLY, 0);
+            if (fd == -1) 
+                    return -1;
+            printf("Reading IOR from /tmp/echo-ior\n");
+            argv[1] = malloc(501);
+            c = read(fd, argv[1], 500);
+            argv[1][c] = '\0';
+            printf("Reading %d bytes: %s\n", c, argv[1]);
+    }
+#else
+    if(argc < 2)
+      {
+	printf("Need an IOR as argv[1]\n");
+	return 1;
+      }
+
+    if(argc == 3)
+	niters = atoi(argv[2]);
+#endif
+
+    echo_client = CORBA_ORB_string_to_object(orb, argv[1], &ev);
+    if (!echo_client) {
+	printf("Cannot bind to %s\n", argv[1]);
+	return 1;
+    }
+
+    for(i = 0; i < niters; i++) {
+	    g_snprintf(buf, sizeof(buf), "Hello, world [%d]", i);
+#ifdef __KERNEL__
+	    bec = Echo_echoString(echo_client, buf, &rv, &ev);
+#else
+            gettimeofday(&start, NULL);
+            for (j = BATCH_SIZE; j > 0; j--) {
+	      bec = Echo_echoString(echo_client, buf, &rv, &ev);
+	      if (j != 1) CORBA_Object_release(bec, &ev);
+            }
+            gettimeofday(&end, NULL);
+            diff = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
+            diff /= BATCH_SIZE;
+            diffsum += diff;
+            
+            printf("duration = %d usec\t", diff);
+#endif
+            
+	    if(ev._major != CORBA_NO_EXCEPTION) {
+	      printf("\nWe got exception %d from echoString!\n", ev._major);
+	      return 1;
+	    }
+
+	    CORBA_Object_release(echo_client, &ev);
+	    if(ev._major != CORBA_NO_EXCEPTION) {
+	      printf("we got exception %d from release!\n", ev._major);
+	      return 1;
+	    } 
+
+	    printf("[client] %d\n", rv);
+
+	    echo_client = bec; bec = CORBA_OBJECT_NIL;
+    }
+
+#ifndef __KERNEL__
+    printf("duration average = %d usec\n", diffsum / niters);
+    CORBA_Object_release(echo_client, &ev);
+    CORBA_Object_release((CORBA_Object)orb, &ev);
+#endif
+
+    return 0;
+}
+
+
+#ifdef __KERNEL__
+void corba_echo_exit(void) { 
+}
+
+module_init(corba_echo_init)
+module_exit(corba_echo_exit)
+#endif
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/echo-common.c linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo-common.c
--- linux-2.4.1/net/korbit/modules/Echo/client/echo-common.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo-common.c	Thu Feb  1 16:36:36 2001
@@ -0,0 +1,27 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "echo.h"
+
+#if ( (TC_IMPL_TC_Echo_0 == 'e') \
+&& (TC_IMPL_TC_Echo_1 == 'c') \
+&& (TC_IMPL_TC_Echo_2 == 'h') \
+&& (TC_IMPL_TC_Echo_3 == 'o') \
+) && !defined(TC_DEF_TC_Echo)
+#define TC_DEF_TC_Echo 1
+const struct CORBA_TypeCode_struct TC_Echo_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_objref, "Echo", "IDL:Echo:1.0",
+   0, 0,
+   NULL,
+   NULL,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+CORBA_unsigned_long Echo__classid = 0;
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/echo-stubs.c linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo-stubs.c
--- linux-2.4.1/net/korbit/modules/Echo/client/echo-stubs.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo-stubs.c	Thu Feb  1 16:36:36 2001
@@ -0,0 +1,134 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "echo.h"
+
+Echo
+Echo_echoString(Echo _obj, const CORBA_char * astring, CORBA_long * anum,
+		CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+   Echo _ORBIT_retval;
+
+   if (_obj->servant && _obj->vepv && Echo__classid) {
+      _ORBIT_retval =
+	 ((POA_Echo__epv *) _obj->vepv[Echo__classid])->echoString(_obj->
+								   servant,
+								   astring,
+								   anum, ev);
+      return _ORBIT_retval;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[11];
+      }
+      _ORBIT_operation_name_data =
+      {
+      11, "echoString"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 15 };
+      register CORBA_unsigned_long _ORBIT_tmpvar_0;
+      CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_tmpvar_1 = strlen(astring) + 1;
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+				       (_ORBIT_send_buffer), 4);
+      {
+	 guchar *_ORBIT_t;
+
+	 _ORBIT_t = alloca(sizeof(_ORBIT_tmpvar_1));
+	 memcpy(_ORBIT_t, &(_ORBIT_tmpvar_1), sizeof(_ORBIT_tmpvar_1));
+	 giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
+					(_ORBIT_send_buffer), (_ORBIT_t),
+					sizeof(_ORBIT_tmpvar_1));
+      }
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     (astring),
+				     sizeof(astring[_ORBIT_tmpvar_0]) *
+				     _ORBIT_tmpvar_1);
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
+	 _ORBIT_retval =
+	    ORBit_demarshal_object(_ORBIT_recv_buffer,
+				   GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				   connection->orb_data);
+	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & ((*anum)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
+	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
+	 _ORBIT_retval =
+	    ORBit_demarshal_object(_ORBIT_recv_buffer,
+				   GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				   connection->orb_data);
+	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 (*anum) = *((CORBA_long *) _ORBIT_curptr);
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return _ORBIT_retval;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return _ORBIT_retval;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return _ORBIT_retval;
+      }
+   }
+}
diff -urN linux-2.4.1/net/korbit/modules/Echo/client/echo.h linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo.h
--- linux-2.4.1/net/korbit/modules/Echo/client/echo.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client/echo.h	Thu Feb  1 16:36:36 2001
@@ -0,0 +1,77 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <glib.h>
+#define ORBIT_IDL_SERIAL 9
+#include <orb/orbit.h>
+
+#ifndef echo_H
+#define echo_H 1
+#ifdef __cplusplus
+extern "C"
+{
+#endif				/* __cplusplus */
+
+/** typedefs **/
+#if !defined(ORBIT_DECL_Echo) && !defined(_Echo_defined)
+#define ORBIT_DECL_Echo 1
+#define _Echo_defined 1
+#define Echo__free CORBA_Object__free
+   typedef CORBA_Object Echo;
+   extern CORBA_unsigned_long Echo__classid;
+#if !defined(TC_IMPL_TC_Echo_0)
+#define TC_IMPL_TC_Echo_0 'e'
+#define TC_IMPL_TC_Echo_1 'c'
+#define TC_IMPL_TC_Echo_2 'h'
+#define TC_IMPL_TC_Echo_3 'o'
+   extern const struct CORBA_TypeCode_struct TC_Echo_struct;
+#define TC_Echo ((CORBA_TypeCode)&TC_Echo_struct)
+#endif
+#endif
+
+/** POA structures **/
+   typedef struct
+   {
+      void *_private;
+      
+	 Echo(*echoString) (PortableServer_Servant _servant,
+			    const CORBA_char * astring, CORBA_long * anum,
+			    CORBA_Environment * ev);
+   }
+   POA_Echo__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_Echo__epv *Echo_epv;
+   }
+   POA_Echo__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_Echo__vepv *vepv;
+   }
+   POA_Echo;
+   extern void POA_Echo__init(PortableServer_Servant servant,
+			      CORBA_Environment * ev);
+   extern void POA_Echo__fini(PortableServer_Servant servant,
+			      CORBA_Environment * ev);
+
+/** prototypes **/
+   Echo Echo_echoString(Echo _obj, const CORBA_char * astring,
+			CORBA_long * anum, CORBA_Environment * ev);
+
+   void _ORBIT_skel_Echo_echoString(POA_Echo * _ORBIT_servant,
+				    GIOPRecvBuffer * _ORBIT_recv_buffer,
+				    CORBA_Environment * ev,
+				    Echo(*_impl_echoString)
+				    (PortableServer_Servant _servant,
+				     const CORBA_char * astring,
+				     CORBA_long * anum,
+				     CORBA_Environment * ev));
+#ifdef __cplusplus
+}
+#endif				/* __cplusplus */
+
+#endif
+#undef ORBIT_IDL_SERIAL
diff -urN linux-2.4.1/net/korbit/modules/Echo/client-perl/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Echo/client-perl/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/CVS/Entries	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,3 @@
+/PerlTest/1.2/Thu Feb  1 09:47:06 2001//
+/README/1.1/Thu Feb  1 09:47:06 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Echo/client-perl/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Echo/client-perl/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/CVS/Repository	Thu Feb  1 11:47:06 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Echo/client-perl
diff -urN linux-2.4.1/net/korbit/modules/Echo/client-perl/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/CVS/Root
--- linux-2.4.1/net/korbit/modules/Echo/client-perl/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/CVS/Root	Thu Feb  1 11:47:06 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Echo/client-perl/PerlTest linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/PerlTest
--- linux-2.4.1/net/korbit/modules/Echo/client-perl/PerlTest	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/PerlTest	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,17 @@
+#!/usr/bin/perl -w
+
+use CORBA::ORBit idl => [ qw(../echo.idl) ];
+use Error qw(:try);
+use strict;
+
+my $orb = CORBA::ORB_init("orbit-local-orb");
+open IOR, "/proc/corba/echo-server" or die "no console server found!";
+my $ior = <IOR>;
+close IOR;
+chomp($ior);  # Kill fredrik's newline...
+
+my $echo = $orb->string_to_object($ior);
+# Echo echoString(in string astring, out long anum);
+my ($echo2, $num) = $echo->echoString("Echo Strange World");
+
+print "Return Echo = $echo2\nnum = $num\n";
diff -urN linux-2.4.1/net/korbit/modules/Echo/client-perl/README linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/README
--- linux-2.4.1/net/korbit/modules/Echo/client-perl/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/client-perl/README	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,4 @@
+Another test of the echo server.
+
+ORB: ORBit/Perl
+Status: Working fine
diff -urN linux-2.4.1/net/korbit/modules/Echo/echo.idl linux-2.4.1-korbit/net/korbit/modules/Echo/echo.idl
--- linux-2.4.1/net/korbit/modules/Echo/echo.idl	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/echo.idl	Thu Feb  1 11:47:05 2001
@@ -0,0 +1,3 @@
+interface Echo {
+	Echo echoString(in string astring, out long anum);
+};
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/Echo/server/CVS/Entries
--- linux-2.4.1/net/korbit/modules/Echo/server/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/CVS/Entries	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,6 @@
+/Makefile/1.2/Thu Feb  1 09:47:06 2001//
+/Makefile.user/1.3/Thu Feb  1 09:47:06 2001//
+/README/1.1/Thu Feb  1 09:47:06 2001//
+/RunServer.sh/1.1/Thu Feb  1 09:47:06 2001//
+/echo-server.c/1.8/Thu Feb  1 09:47:06 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/Echo/server/CVS/Repository
--- linux-2.4.1/net/korbit/modules/Echo/server/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/CVS/Repository	Thu Feb  1 11:47:06 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/Echo/server
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/CVS/Root linux-2.4.1-korbit/net/korbit/modules/Echo/server/CVS/Root
--- linux-2.4.1/net/korbit/modules/Echo/server/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/CVS/Root	Thu Feb  1 11:47:06 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/Makefile linux-2.4.1-korbit/net/korbit/modules/Echo/server/Makefile
--- linux-2.4.1/net/korbit/modules/Echo/server/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/Makefile	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,21 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := corba-echo-server.o
+
+obj-y := echo-server.o echo-skels.o echo-common.o
+obj-m := $(O_TARGET)
+
+include ../../Makefile.module
+
+echo-server.c: echo.h echo-skels.c
+
+
+echo.h echo-common.c echo-skels.c: ../echo.idl
+	$(ORBIT_IDL) ../echo.idl
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/Makefile.user linux-2.4.1-korbit/net/korbit/modules/Echo/server/Makefile.user
--- linux-2.4.1/net/korbit/modules/Echo/server/Makefile.user	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/Makefile.user	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,27 @@
+#
+# Makefile for user level server
+#
+
+PROJECT = echo
+
+CFLAGS = -Wall `orbit-config --cflags server` -I../../..
+LDFLAGS = `orbit-config --libs server`
+OBJS = $(PROJECT)-common.o $(PROJECT)-skels.o $(PROJECT)-server.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-server: $(OBJS)
+	gcc -o $(PROJECT)-server $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-server.c: $(PROJECT).h
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-skels.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --nostubs ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-server
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-skels.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/README linux-2.4.1-korbit/net/korbit/modules/Echo/server/README
--- linux-2.4.1/net/korbit/modules/Echo/server/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/README	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,5 @@
+This server implements the kernel side interface in terms of printk.
+
+This server also builds in user space with ORBit.  Build with 
+  make -f Makefile.user
+
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/RunServer.sh linux-2.4.1-korbit/net/korbit/modules/Echo/server/RunServer.sh
--- linux-2.4.1/net/korbit/modules/Echo/server/RunServer.sh	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/RunServer.sh	Thu Feb  1 11:47:06 2001
@@ -0,0 +1 @@
+./echo-server -ORBIIOPUSock=0 -ORBIIOPIPv4=1
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/echo-common.c linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-common.c
--- linux-2.4.1/net/korbit/modules/Echo/server/echo-common.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-common.c	Thu Feb  1 16:36:57 2001
@@ -0,0 +1,27 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "echo.h"
+
+#if ( (TC_IMPL_TC_Echo_0 == 'e') \
+&& (TC_IMPL_TC_Echo_1 == 'c') \
+&& (TC_IMPL_TC_Echo_2 == 'h') \
+&& (TC_IMPL_TC_Echo_3 == 'o') \
+) && !defined(TC_DEF_TC_Echo)
+#define TC_DEF_TC_Echo 1
+const struct CORBA_TypeCode_struct TC_Echo_struct = {
+   
+      {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
+    ORBIT_PSEUDO_TYPECODE},
+
+   CORBA_tk_objref, "Echo", "IDL:Echo:1.0",
+   0, 0,
+   NULL,
+   NULL,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+CORBA_unsigned_long Echo__classid = 0;
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/echo-server.c linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-server.c
--- linux-2.4.1/net/korbit/modules/Echo/server/echo-server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-server.c	Thu Feb  1 11:47:06 2001
@@ -0,0 +1,103 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <orb/orbit.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include "echo.h"
+#include "glib.h"
+#include "korbit.h"
+
+Echo echo_client = CORBA_OBJECT_NIL;
+
+static CORBA_Object
+do_echoString(PortableServer_Servant servant,
+	      CORBA_char *astring,
+	      CORBA_long *outnum,
+	      CORBA_Environment *ev);
+
+PortableServer_ServantBase__epv base_epv = {
+  NULL,
+  NULL,
+  NULL
+};
+POA_Echo__epv echo_epv = { NULL, do_echoString };
+POA_Echo__vepv poa_echo_vepv = { &base_epv, &echo_epv };
+POA_Echo poa_echo_servant = { NULL, &poa_echo_vepv };
+
+PortableServer_ObjectId objid = {0, sizeof("myEchoString"), "myEchoString"};
+PortableServer_POA poa;
+CORBA_Environment *ev; 
+
+#ifdef __KERNEL__
+int __init corba_echo_init(void) 
+#else
+int main(int argc, char *argv[])
+#endif
+{
+#ifdef __KERNEL__
+    int argc = 1; char *argv[] = { "server", 0 };
+#endif
+    CORBA_ORB orb;
+    ev = g_new0(CORBA_Environment, 1);
+    orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", ev);
+    if (!orb) {
+        printf("Error getting ORB!\n");
+        return 1;
+    }
+
+    poa = (PortableServer_POA)
+          CORBA_ORB_resolve_initial_references(orb, "RootPOA", ev);
+    if (!poa) {
+        printf("Error getting POA!\n");
+        return 1;
+    }
+
+    PortableServer_POAManager_activate(
+          PortableServer_POA__get_the_POAManager(poa, ev), ev);
+
+
+    POA_Echo__init(&poa_echo_servant, ev);
+    PortableServer_POA_activate_object_with_id(poa,
+					       &objid, &poa_echo_servant, ev);
+
+    echo_client = PortableServer_POA_servant_to_reference(poa,
+							  &poa_echo_servant,
+							  ev);
+    if (!echo_client) {
+	printf("Cannot get objref\n");
+	return 1;
+    }
+
+    korbit_register_ior("echo-server", echo_client, orb, ev);
+
+    CORBA_ORB_run(orb, ev);
+    return 0;
+}
+
+#ifdef __KERNEL__
+void corba_echo_exit(void) { 
+  PortableServer_POA_deactivate_object(poa, &objid, ev);
+  remove_proc_entry("corba/echo-server", 0);
+}
+
+module_init(corba_echo_init)
+module_exit(corba_echo_exit)
+#endif
+
+static CORBA_Object
+do_echoString(PortableServer_Servant servant,
+	      CORBA_char *astring,
+	      CORBA_long *outnum,
+	      CORBA_Environment *ev)
+{
+  *outnum = 12345678;
+
+#if 1
+  g_message("[server] %s -> %d", astring, *outnum);
+#endif
+
+  return CORBA_Object_duplicate(echo_client, ev);
+}
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/echo-skels.c linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-skels.c
--- linux-2.4.1/net/korbit/modules/Echo/server/echo-skels.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-skels.c	Thu Feb  1 16:36:57 2001
@@ -0,0 +1,115 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "echo.h"
+
+void
+_ORBIT_skel_Echo_echoString(POA_Echo * _ORBIT_servant,
+			    GIOPRecvBuffer * _ORBIT_recv_buffer,
+			    CORBA_Environment * ev,
+			    Echo(*_impl_echoString) (PortableServer_Servant
+						     _servant,
+						     const CORBA_char *
+						     astring,
+						     CORBA_long * anum,
+						     CORBA_Environment * ev))
+{
+   Echo _ORBIT_retval;
+   CORBA_char *astring;
+   CORBA_long anum;
+
+   {				/* demarshalling */
+      guchar *_ORBIT_curptr;
+      register CORBA_unsigned_long _ORBIT_tmpvar_2;
+      CORBA_unsigned_long _ORBIT_tmpvar_3;
+
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & (_ORBIT_tmpvar_3))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
+	 _ORBIT_curptr += 4;
+	 astring = (void *) _ORBIT_curptr;
+	 _ORBIT_curptr += sizeof(astring[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
+      } else {
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
+	 _ORBIT_curptr += 4;
+	 astring = (void *) _ORBIT_curptr;
+	 _ORBIT_curptr += sizeof(astring[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
+      }
+   }
+   _ORBIT_retval = _impl_echoString(_ORBIT_servant, astring, &(anum), ev);
+   {				/* marshalling */
+      register GIOPSendBuffer *_ORBIT_send_buffer;
+
+      _ORBIT_send_buffer =
+	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				    connection, NULL,
+				    _ORBIT_recv_buffer->message.u.request.
+				    request_id, ev->_major);
+      if (_ORBIT_send_buffer) {
+	 if (ev->_major == CORBA_NO_EXCEPTION) {
+	    ORBit_marshal_object(_ORBIT_send_buffer, _ORBIT_retval);
+	    giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+					     (_ORBIT_send_buffer), 4);
+	    giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
+					   (_ORBIT_send_buffer), &(anum),
+					   sizeof(anum));
+	 } else
+	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
+	 giop_send_buffer_write(_ORBIT_send_buffer);
+	 giop_send_buffer_unuse(_ORBIT_send_buffer);
+      }
+      if (ev->_major == CORBA_NO_EXCEPTION)
+	 CORBA_Object_release(_ORBIT_retval, ev);
+   }
+}
+static ORBitSkeleton
+get_skel_Echo(POA_Echo * servant,
+	      GIOPRecvBuffer * _ORBIT_recv_buffer, gpointer * impl)
+{
+   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;
+
+   switch (opname[0]) {
+     case 'e':
+	if (strcmp((opname + 1), "choString"))
+	   break;
+	*impl = (gpointer) servant->vepv->Echo_epv->echoString;
+	return (ORBitSkeleton) _ORBIT_skel_Echo_echoString;
+	break;
+     default:
+	break;
+   }
+   return NULL;
+}
+
+static void
+init_local_objref_Echo(CORBA_Object obj, POA_Echo * servant)
+{
+   obj->vepv[Echo__classid] = servant->vepv->Echo_epv;
+}
+
+void
+POA_Echo__init(PortableServer_Servant servant, CORBA_Environment * env)
+{
+   static const PortableServer_ClassInfo class_info =
+      { (ORBit_impl_finder) & get_skel_Echo, "IDL:Echo:1.0",
+	 (ORBit_local_objref_init) & init_local_objref_Echo };
+
+   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
+				    env);
+   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
+      class_info = (PortableServer_ClassInfo *) & class_info;
+   if (!Echo__classid)
+      Echo__classid = ORBit_register_class(&class_info);
+}
+
+void
+POA_Echo__fini(PortableServer_Servant servant, CORBA_Environment * env)
+{
+   PortableServer_ServantBase__fini(servant, env);
+}
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/echo-stubs.c linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-stubs.c
--- linux-2.4.1/net/korbit/modules/Echo/server/echo-stubs.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo-stubs.c	Thu Feb  1 16:36:57 2001
@@ -0,0 +1,134 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <string.h>
+#include "echo.h"
+
+Echo
+Echo_echoString(Echo _obj, const CORBA_char * astring, CORBA_long * anum,
+		CORBA_Environment * ev)
+{
+   register GIOP_unsigned_long _ORBIT_request_id,
+    _ORBIT_system_exception_minor;
+   register CORBA_completion_status _ORBIT_completion_status;
+   register GIOPSendBuffer *_ORBIT_send_buffer;
+   register GIOPRecvBuffer *_ORBIT_recv_buffer;
+   register GIOPConnection *_cnx;
+   Echo _ORBIT_retval;
+
+   if (_obj->servant && _obj->vepv && Echo__classid) {
+      _ORBIT_retval =
+	 ((POA_Echo__epv *) _obj->vepv[Echo__classid])->echoString(_obj->
+								   servant,
+								   astring,
+								   anum, ev);
+      return _ORBIT_retval;
+   }
+   _cnx = ORBit_object_get_connection(_obj);
+ _ORBIT_retry_request:
+   _ORBIT_send_buffer = NULL;
+   _ORBIT_recv_buffer = NULL;
+   _ORBIT_completion_status = CORBA_COMPLETED_NO;
+   _ORBIT_request_id = GPOINTER_TO_UINT(alloca(0));
+   {				/* marshalling */
+      static const struct
+      {
+	 CORBA_unsigned_long len;
+	 char opname[11];
+      }
+      _ORBIT_operation_name_data =
+      {
+      11, "echoString"};
+      static const struct iovec _ORBIT_operation_vec =
+	 { (gpointer) & _ORBIT_operation_name_data, 15 };
+      register CORBA_unsigned_long _ORBIT_tmpvar_0;
+      CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+      _ORBIT_send_buffer =
+	 giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id,
+				      CORBA_TRUE,
+				      &(_obj->active_profile->object_key_vec),
+				      &_ORBIT_operation_vec,
+				      &ORBit_default_principal_iovec);
+
+      _ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+      if (!_ORBIT_send_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_tmpvar_1 = strlen(astring) + 1;
+      giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
+				       (_ORBIT_send_buffer), 4);
+      {
+	 guchar *_ORBIT_t;
+
+	 _ORBIT_t = alloca(sizeof(_ORBIT_tmpvar_1));
+	 memcpy(_ORBIT_t, &(_ORBIT_tmpvar_1), sizeof(_ORBIT_tmpvar_1));
+	 giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
+					(_ORBIT_send_buffer), (_ORBIT_t),
+					sizeof(_ORBIT_tmpvar_1));
+      }
+      giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer),
+				     (astring),
+				     sizeof(astring[_ORBIT_tmpvar_0]) *
+				     _ORBIT_tmpvar_1);
+      giop_send_buffer_write(_ORBIT_send_buffer);
+      _ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      _ORBIT_send_buffer = NULL;
+   }
+   {				/* demarshalling */
+      register guchar *_ORBIT_curptr;
+
+      _ORBIT_recv_buffer =
+	 giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+      if (!_ORBIT_recv_buffer)
+	 goto _ORBIT_system_exception;
+      _ORBIT_completion_status = CORBA_COMPLETED_YES;
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status !=
+	  GIOP_NO_EXCEPTION) goto _ORBIT_msg_exception;
+      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
+	 _ORBIT_retval =
+	    ORBit_demarshal_object(_ORBIT_recv_buffer,
+				   GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				   connection->orb_data);
+	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 
+	    (*((guint32 *) & ((*anum)))) =
+	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
+	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
+	 _ORBIT_retval =
+	    ORBit_demarshal_object(_ORBIT_recv_buffer,
+				   GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
+				   connection->orb_data);
+	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
+	 (*anum) = *((CORBA_long *) _ORBIT_curptr);
+      }
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      return _ORBIT_retval;
+    _ORBIT_system_exception:
+      CORBA_exception_set_system(ev, _ORBIT_system_exception_minor,
+				 _ORBIT_completion_status);
+      giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+      giop_send_buffer_unuse(_ORBIT_send_buffer);
+      return _ORBIT_retval;
+    _ORBIT_msg_exception:
+      if (_ORBIT_recv_buffer->message.u.reply.reply_status ==
+	  GIOP_LOCATION_FORWARD) {
+	 if (_obj->forward_locations != NULL)
+	    ORBit_delete_profiles(_obj->forward_locations);
+	 _obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+	 _cnx = ORBit_object_get_forwarded_connection(_obj);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+	 goto _ORBIT_retry_request;
+      } else {
+	 ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, _obj->orb);
+	 giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+	 return _ORBIT_retval;
+      }
+   }
+}
diff -urN linux-2.4.1/net/korbit/modules/Echo/server/echo.h linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo.h
--- linux-2.4.1/net/korbit/modules/Echo/server/echo.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Echo/server/echo.h	Thu Feb  1 16:36:57 2001
@@ -0,0 +1,77 @@
+/*
+ * This file was generated by orbit-idl - DO NOT EDIT!
+ */
+
+#include <glib.h>
+#define ORBIT_IDL_SERIAL 9
+#include <orb/orbit.h>
+
+#ifndef echo_H
+#define echo_H 1
+#ifdef __cplusplus
+extern "C"
+{
+#endif				/* __cplusplus */
+
+/** typedefs **/
+#if !defined(ORBIT_DECL_Echo) && !defined(_Echo_defined)
+#define ORBIT_DECL_Echo 1
+#define _Echo_defined 1
+#define Echo__free CORBA_Object__free
+   typedef CORBA_Object Echo;
+   extern CORBA_unsigned_long Echo__classid;
+#if !defined(TC_IMPL_TC_Echo_0)
+#define TC_IMPL_TC_Echo_0 'e'
+#define TC_IMPL_TC_Echo_1 'c'
+#define TC_IMPL_TC_Echo_2 'h'
+#define TC_IMPL_TC_Echo_3 'o'
+   extern const struct CORBA_TypeCode_struct TC_Echo_struct;
+#define TC_Echo ((CORBA_TypeCode)&TC_Echo_struct)
+#endif
+#endif
+
+/** POA structures **/
+   typedef struct
+   {
+      void *_private;
+      
+	 Echo(*echoString) (PortableServer_Servant _servant,
+			    const CORBA_char * astring, CORBA_long * anum,
+			    CORBA_Environment * ev);
+   }
+   POA_Echo__epv;
+   typedef struct
+   {
+      PortableServer_ServantBase__epv *_base_epv;
+      POA_Echo__epv *Echo_epv;
+   }
+   POA_Echo__vepv;
+   typedef struct
+   {
+      void *_private;
+      POA_Echo__vepv *vepv;
+   }
+   POA_Echo;
+   extern void POA_Echo__init(PortableServer_Servant servant,
+			      CORBA_Environment * ev);
+   extern void POA_Echo__fini(PortableServer_Servant servant,
+			      CORBA_Environment * ev);
+
+/** prototypes **/
+   Echo Echo_echoString(Echo _obj, const CORBA_char * astring,
+			CORBA_long * anum, CORBA_Environment * ev);
+
+   void _ORBIT_skel_Echo_echoString(POA_Echo * _ORBIT_servant,
+				    GIOPRecvBuffer * _ORBIT_recv_buffer,
+				    CORBA_Environment * ev,
+				    Echo(*_impl_echoString)
+				    (PortableServer_Servant _servant,
+				     const CORBA_char * astring,
+				     CORBA_long * anum,
+				     CORBA_Environment * ev));
+#ifdef __cplusplus
+}
+#endif				/* __cplusplus */
+
+#endif
+#undef ORBIT_IDL_SERIAL
diff -urN linux-2.4.1/net/korbit/modules/FileServer/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Entries
--- linux-2.4.1/net/korbit/modules/FileServer/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Entries	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,4 @@
+/FileServer.idl/1.3/Thu Feb  1 09:47:07 2001//
+/Makefile/1.2/Thu Feb  1 09:47:07 2001//
+/README/1.1/Thu Feb  1 09:47:07 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/FileServer/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/FileServer/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Entries.Log	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,4 @@
+A D/client////
+A D/server////
+A D/server-user////
+A D/wrapper////
diff -urN linux-2.4.1/net/korbit/modules/FileServer/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Repository
--- linux-2.4.1/net/korbit/modules/FileServer/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Repository	Thu Feb  1 11:47:07 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/FileServer
diff -urN linux-2.4.1/net/korbit/modules/FileServer/CVS/Root linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Root
--- linux-2.4.1/net/korbit/modules/FileServer/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/CVS/Root	Thu Feb  1 11:47:07 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/FileServer/FileServer.idl linux-2.4.1-korbit/net/korbit/modules/FileServer/FileServer.idl
--- linux-2.4.1/net/korbit/modules/FileServer/FileServer.idl	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/FileServer.idl	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,158 @@
+// -----------------------------------------------------------------------------
+// FileServer.idl
+// -----------------------------------------------------------------------------
+//
+// This file is used to define the Kernel CORBA API for accessing the filesystem
+// on a machine.  This defines mappings both to access the files in the kernel
+// and to implement a filesystem for the kernel.  This should probably be split
+// into two files eventually.
+//
+// Currently unimplemented: KernelAccessAPI::FileSystem::ReadDirectory
+//                          KernelAccessAPI::FileSystem::Select
+//                          KernelImplementationAPI::SuperBlock::getDiskQuotaOps
+//
+// -----------------------------------------------------------------------------
+
+
+// These are the exceptions that may be thrown and what they map to in the 
+// Linux kernel.  This interface is extended by other interfaces so that the
+// names don't have to be typedef'd into each interface that wants to use these
+// errors.
+//
+interface Errors {
+    exception IsDirectory {};              // EISDIR
+    exception PermissionDenied {};         // EACCES
+    exception FileExists {};               // EEXIST
+    exception FileNotFound {};             // ENOENT
+    exception IsNotDirectory {};           // ENOTDIR
+    exception ReadOnlyFile {};             // EROFS, ETXTBSY
+    exception RecursiveSymlink {};         // ELOOP
+    exception IsBusy {};                   // EBUSY
+    exception OtherError{};                // Misc other ones...
+};
+
+
+// -----------------------------------------------------------------------------
+// KernelAccessAPI Module - Allow user level programs to call into the kernel
+// -----------------------------------------------------------------------------
+
+module FileServer {
+  struct FileStatus {           // Corba equilivant of struct stat
+    long  DeviceNum;            // st_dev
+    long  InodeNum;             // st_ino
+    short Mode;                 // st_mode
+    short NumLinks;             // st_nlink
+    long  UserID;               // st_uid
+    long  GroupID;              // st_gid
+    long  DeviceType;           // st_rdev
+    unsigned long Size;         // st_size
+    unsigned long BlockSize;    // st_blksize
+    unsigned long NumBlocks;    // st_blocks;
+    unsigned long AccessTime;   // st_blocks;
+    unsigned long ModifiedTime; // st_blocks;
+    unsigned long ChangeTime;   // st_blocks;
+  };
+
+        typedef sequence<octet> buffer;
+        
+  // ---------------------------------------------------------------------------
+  // FileSystem Interface - Access to filesystem and File object factory
+  // ---------------------------------------------------------------------------
+  
+  interface File : Errors {
+    void Read(in long count, out buffer buf) 
+      raises (IsDirectory, OtherError);
+    void Write(in buffer buf) 
+      raises (OtherError);
+    void Close();
+
+    long FileControl(in long command) raises (OtherError);
+
+    FileStatus GetStatus() raises (OtherError);
+
+    void ChangeDirectoryTo()    // This implements fchdir...
+      raises (IsNotDirectory, PermissionDenied, OtherError);
+
+    enum SeekDirection { FromStart, FromCurrent, FromEnd };
+    long Seek(in long Offset, in SeekDirection Direction) raises (OtherError);
+
+    File Duplicate() raises (OtherError);
+  };
+
+
+
+  // ---------------------------------------------------------------------------
+  // FileSystem Interface - Access to filesystem and File object factory
+  // ---------------------------------------------------------------------------
+
+  interface FileSystem : Errors {
+
+    // -------------------------------------------------------------------------
+    // File Manipulation Routines
+    // -------------------------------------------------------------------------
+
+    File Open(in string Filename, in long openFlags, in short mode) 
+      raises (FileExists, IsDirectory, PermissionDenied, FileNotFound, 
+	      IsNotDirectory, ReadOnlyFile, RecursiveSymlink, OtherError);
+	      
+    File Create(in string Filename, in short mode)
+      raises (FileExists, IsDirectory, PermissionDenied, FileNotFound, 
+	      IsNotDirectory, ReadOnlyFile, RecursiveSymlink, OtherError);
+
+    void Link(in string FromPath, in string ToPath) 
+      raises (PermissionDenied, IsNotDirectory, RecursiveSymlink, FileExists);
+
+    void Unlink(in string Filename) 
+      raises (PermissionDenied, FileNotFound, IsNotDirectory, IsDirectory);
+
+    void Rename(in string OldName, in string NewName) 
+      raises (IsDirectory, FileExists, IsBusy, IsNotDirectory, PermissionDenied,
+	      RecursiveSymlink);
+
+    void ReadLink(in string Linkname, out string LinkValue) 
+      raises (FileNotFound, PermissionDenied, RecursiveSymlink, OtherError);
+
+
+    FileStatus GetStatus(in string Filename) 
+      raises (FileNotFound, PermissionDenied, RecursiveSymlink, IsNotDirectory, 
+	      OtherError);
+
+    FileStatus GetLinkStatus(in string Filename) 
+      raises (FileNotFound, PermissionDenied, RecursiveSymlink, IsNotDirectory, 
+	      OtherError);
+
+
+    // -------------------------------------------------------------------------
+    // Directory Manipulation Routines
+    // -------------------------------------------------------------------------
+
+    void MakeDirectory(in string PathName, in short mode)
+      raises (FileExists, PermissionDenied, FileNotFound, IsNotDirectory, 
+	      ReadOnlyFile, RecursiveSymlink, OtherError);
+
+    void RemoveDirectory(in string PathName)
+      raises (PermissionDenied, FileNotFound, IsNotDirectory);
+
+    // ChangeDirectory returns CWD so that you can implement getcwd as
+    //  { return ChangeDirectory("."); }
+    string ChangeDirectory(in string PathName) 
+      raises (IsNotDirectory, PermissionDenied, FileNotFound, RecursiveSymlink);
+
+
+    // -------------------------------------------------------------------------
+    // Special Purpose Routines...
+    // -------------------------------------------------------------------------
+
+    void MakeNode(in string FileName, in short Mode, in long DeviceNum)
+      raises (PermissionDenied, FileExists, FileNotFound, IsNotDirectory, 
+	      RecursiveSymlink);
+    
+    void Mount(in string DeviceFile, in string Location, in string FSType,
+	       in long Flags)
+      raises (PermissionDenied, FileNotFound, IsBusy, IsNotDirectory);
+
+    void Unmount(in string Filename)
+      raises (PermissionDenied, FileNotFound, IsBusy);
+  };
+
+};
diff -urN linux-2.4.1/net/korbit/modules/FileServer/Makefile linux-2.4.1-korbit/net/korbit/modules/FileServer/Makefile
--- linux-2.4.1/net/korbit/modules/FileServer/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/Makefile	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,11 @@
+#
+# Makefile for KORBit/modules/CorbaFS
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+subdir-$(CONFIG_CORBA_FILESERVER) := server
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/FileServer/README linux-2.4.1-korbit/net/korbit/modules/FileServer/README
--- linux-2.4.1/net/korbit/modules/FileServer/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/README	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,8 @@
+This interface lets you export file related syscalls through CORBA.  This is
+genuinely useful, however, when you use the 'wrapper' library, that can be 
+LD_PRELOADED before you run your application.  This allows you to forward 
+filesystem calls through CORBA without having to modify your application.
+
+Being able to forward filesystem calls though CORBA, of course, means that 
+you can attach to any remote machine you want.  :)
+
diff -urN linux-2.4.1/net/korbit/modules/FileServer/client/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/FileServer/client/CVS/Entries
--- linux-2.4.1/net/korbit/modules/FileServer/client/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/client/CVS/Entries	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,4 @@
+/FileServer-client.cpp/1.1/Thu Feb  1 09:47:07 2001//
+/Makefile/1.1/Thu Feb  1 09:47:07 2001//
+/README/1.1/Thu Feb  1 09:47:07 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/FileServer/client/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/FileServer/client/CVS/Repository
--- linux-2.4.1/net/korbit/modules/FileServer/client/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/client/CVS/Repository	Thu Feb  1 11:47:07 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/FileServer/client
diff -urN linux-2.4.1/net/korbit/modules/FileServer/client/CVS/Root linux-2.4.1-korbit/net/korbit/modules/FileServer/client/CVS/Root
--- linux-2.4.1/net/korbit/modules/FileServer/client/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/client/CVS/Root	Thu Feb  1 11:47:07 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/FileServer/client/FileServer-client.cpp linux-2.4.1-korbit/net/korbit/modules/FileServer/client/FileServer-client.cpp
--- linux-2.4.1/net/korbit/modules/FileServer/client/FileServer-client.cpp	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/client/FileServer-client.cpp	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,78 @@
+#include <OB/CORBA.h>
+#include <OB/Util.h>
+#include <OB/CosNaming.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "FileServer.h"
+
+int main(int argc, char* argv[])
+{
+    if (argc < 3)
+    {
+        cout << "Usage : " << argv[0] << " ior filename" << endl;
+        exit(1);
+    }
+    
+    cout << "FileServer client initializing" << endl;
+
+    CORBA_ORB_var orb = CORBA_ORB_init(argc, argv);
+    cout << "ORB initialized" << endl;
+
+    try 
+    {
+        CORBA_Object_var obj = orb->string_to_object( argv[1] );
+        assert(!CORBA_is_nil(obj));
+        cout << "got object... " << orb->object_to_string(obj) << endl;
+        
+        FileServer_FileSystem_var fs = FileServer_FileSystem::_narrow(obj);
+        assert(!CORBA_is_nil(fs));
+        cout << "it's a FileServer!" << endl;
+        
+        obj = fs->Open(argv[2], O_RDONLY, 0);
+        assert(!CORBA_is_nil(obj));
+        cout << "got object... " << orb->object_to_string(obj) << endl;
+        
+        FileServer_File_var file = FileServer_File::_narrow(obj);
+        assert(!CORBA_is_nil(file));
+        cout << "it's a FileServer_File!" << endl;
+        
+        FileServer_buffer *buf = new FileServer_buffer;
+        cout << "reading 1000 bytes" << endl;
+        file->Read(1000, buf);
+        
+        cout << "got " << buf->length() << " bytes" << endl;
+        cout << buf->data() << endl;
+    
+        file->Close();
+        
+        delete buf;
+    }
+    catch (const CORBA_SystemException& ex) {
+        OBPrintException(ex);
+        return 1;
+    }
+    catch (const Errors::FileNotFound& ex) {
+        cout << "ERROR : File not found" << endl;
+        return 1;
+    }
+    catch (const Errors::PermissionDenied& ex) {
+        cout << "ERROR : Permission denied" << endl;
+        return 1;
+    }
+    catch (const Errors::IsDirectory& ex) {
+        cout << "ERROR : Is directory" << endl;
+        return 1;
+    }
+    catch (const Errors::OtherError& ex) {
+        cout << "ERROR : Other error" << endl;
+        return 1;
+    }
+    catch (const CORBA_UserException& ex)
+    {
+        cout << "ERROR : Uncaught exception" << endl;
+        return 1;
+    }
+}
diff -urN linux-2.4.1/net/korbit/modules/FileServer/client/Makefile linux-2.4.1-korbit/net/korbit/modules/FileServer/client/Makefile
--- linux-2.4.1/net/korbit/modules/FileServer/client/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/client/Makefile	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,32 @@
+CC = CC -mt -pta
+OBDIR = /home/class/cs423/local
+IDL = $(OBDIR)/bin/idl
+CPPFLAGS = -I. -I$(OBDIR)/include
+LDFLAGS = -L$(OBDIR)/lib 
+LIBS = -lCosNaming -lOB -lJTC -lsocket -lnsl -lposix4
+
+all: FileServer-client
+
+FileServer-client: FileServer.o FileServer-client.o
+	$(CC) $(LDFLAGS) -o FileServer-client FileServer-client.o FileServer.o $(LIBS)
+
+nameserv:
+	nameserv -i -OAport 10000
+
+FileServer.h FileServer.cpp: ../FileServer.idl
+	rm -f FileServer.cpp FileServer.h
+	rm -f FileServer_skel.h FileServer_skel.cpp
+	$(IDL) ../FileServer.idl
+
+FileServer_skel.cpp FileServer_skel.h: FileServer.cpp
+
+%.o: %.cpp
+	$(CC) $(CPPFLAGS) -c $<
+
+clean:
+	rm -f FileServer-client *.o *~
+
+realclean: clean
+	rm -f FileServer.h FileServer.cpp
+	rm -f FileServer_skel.h FileServer_skel.cpp
+	rm -rf SunWS_cache
diff -urN linux-2.4.1/net/korbit/modules/FileServer/client/README linux-2.4.1-korbit/net/korbit/modules/FileServer/client/README
--- linux-2.4.1/net/korbit/modules/FileServer/client/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/client/README	Thu Feb  1 11:47:07 2001
@@ -0,0 +1,4 @@
+Very minimal test of the FileServer capability.
+
+ORB: Orbacus
+
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/FileServer/server/CVS/Entries
--- linux-2.4.1/net/korbit/modules/FileServer/server/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/CVS/Entries	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,6 @@
+/FileServer-server.c/1.2/Thu Feb  1 09:47:08 2001//
+/FileServer-skelimpl.c/1.8/Thu Feb  1 09:47:08 2001//
+/Makefile/1.3/Thu Feb  1 09:47:08 2001//
+/Makefile.user/1.4/Thu Feb  1 09:47:08 2001//
+/README/1.1/Thu Feb  1 09:47:08 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/FileServer/server/CVS/Repository
--- linux-2.4.1/net/korbit/modules/FileServer/server/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/CVS/Repository	Thu Feb  1 11:47:08 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/FileServer/server
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/CVS/Root linux-2.4.1-korbit/net/korbit/modules/FileServer/server/CVS/Root
--- linux-2.4.1/net/korbit/modules/FileServer/server/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/CVS/Root	Thu Feb  1 11:47:08 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/FileServer-server.c linux-2.4.1-korbit/net/korbit/modules/FileServer/server/FileServer-server.c
--- linux-2.4.1/net/korbit/modules/FileServer/server/FileServer-server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/FileServer-server.c	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,57 @@
+#include <stdio.h>
+#include "FileServer-skelimpl.c"
+#include "korbit.h"
+
+CORBA_ORB               orb;
+PortableServer_POA      poa;
+CORBA_Environment       *ev;
+PortableServer_ObjectId *objid;
+
+#ifdef __KERNEL__
+int __init FileServer_init(void) {
+#else
+int main(int argc, char *argv[]) {
+#endif
+        FileServer_FileSystem        fs;
+        impl_POA_FileServer_FileSystem *fs_impl;
+        
+        PortableServer_POAManager pm;
+#ifdef __KERNEL__        
+	int argc = 1; 
+        char *argv[] = { "server", 0 };
+#endif
+        ev = g_new0(CORBA_Environment,1);
+        
+        CORBA_exception_init(ev);
+        
+        orb = CORBA_ORB_init(&argc, argv, "orbit-local-orb", ev);
+        poa = (PortableServer_POA)
+                CORBA_ORB_resolve_initial_references(orb,
+                                                     "RootPOA", 
+                                                     ev);
+        fs = impl_FileServer_FileSystem__create(poa, ev);
+
+        pm = PortableServer_POA__get_the_POAManager(poa, ev);
+        PortableServer_POAManager_activate(pm, ev);
+
+        fs_impl = PortableServer_POA_reference_to_servant( poa, fs, ev );
+        objid = PortableServer_POA_servant_to_id( poa, fs_impl, ev );
+
+        korbit_register_ior("FileServer-server", fs, orb, ev);
+
+        CORBA_ORB_run(orb, ev);
+
+        return 0;
+}
+
+#ifdef __KERNEL__
+void FileServer_exit(void) 
+{ 
+        PortableServer_POA_deactivate_object(poa, objid, ev);
+        remove_proc_entry("corba/FileServer-server", 0);
+        printf("FileServer_exit()\n"); 
+}
+
+module_init(FileServer_init)
+module_exit(FileServer_exit)
+#endif
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/FileServer-skelimpl.c linux-2.4.1-korbit/net/korbit/modules/FileServer/server/FileServer-skelimpl.c
--- linux-2.4.1/net/korbit/modules/FileServer/server/FileServer-skelimpl.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/FileServer-skelimpl.c	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,804 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include "FileServer.h"
+
+static void set_exception(int errno, CORBA_Environment *ev)
+{
+        switch (errno)
+        { 
+        case ENOENT:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_FileNotFound,
+                                    Errors_FileNotFound__alloc());
+                break;
+        case EEXIST:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_FileExists,
+                                    Errors_FileExists__alloc());
+                break;
+        case EACCES:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_PermissionDenied,
+                                    Errors_PermissionDenied__alloc());
+                break;
+        case EISDIR:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_IsDirectory,
+                                    Errors_IsDirectory__alloc());
+                break;
+        case ENOTDIR:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_IsNotDirectory,
+                                    Errors_IsNotDirectory__alloc());
+                break;
+        case EROFS:
+        case ETXTBSY:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_ReadOnlyFile,
+                                    Errors_ReadOnlyFile__alloc());
+                break;
+        case ELOOP:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_RecursiveSymlink,
+                                    Errors_RecursiveSymlink__alloc());
+                break;
+        case EBUSY:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_IsBusy,
+                                    Errors_IsBusy__alloc());
+                break;
+        default:
+                CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+                                    ex_Errors_OtherError,
+                                    Errors_OtherError__alloc());
+                break;
+        }
+}
+
+
+/*** App-specific servant structures ***/
+typedef struct
+{
+   POA_Errors servant;
+   PortableServer_POA poa;
+
+}
+impl_POA_Errors;
+
+typedef struct
+{
+   POA_FileServer_File servant;
+   PortableServer_POA poa;
+
+   int fd;
+}
+impl_POA_FileServer_File;
+
+typedef struct
+{
+   POA_FileServer_FileSystem servant;
+   PortableServer_POA poa;
+
+}
+impl_POA_FileServer_FileSystem;
+
+/*** Implementation stub prototypes ***/
+static void impl_Errors__destroy(impl_POA_Errors * servant,
+				 CORBA_Environment * ev);
+
+static void impl_FileServer_File__destroy(impl_POA_FileServer_File * servant,
+					  CORBA_Environment * ev);
+static void
+impl_FileServer_File_Read(impl_POA_FileServer_File * servant,
+			  CORBA_long count,
+			  FileServer_buffer ** buf, CORBA_Environment * ev);
+
+static void
+impl_FileServer_File_Write(impl_POA_FileServer_File * servant,
+			   FileServer_buffer * buf, CORBA_Environment * ev);
+
+static void
+impl_FileServer_File_Close(impl_POA_FileServer_File * servant,
+			   CORBA_Environment * ev);
+
+static CORBA_long
+impl_FileServer_File_FileControl(impl_POA_FileServer_File * servant,
+				 CORBA_long command, CORBA_Environment * ev);
+
+static FileServer_FileStatus
+impl_FileServer_File_GetStatus(impl_POA_FileServer_File * servant,
+			       CORBA_Environment * ev);
+
+static void
+impl_FileServer_File_ChangeDirectoryTo(impl_POA_FileServer_File * servant,
+				       CORBA_Environment * ev);
+
+static CORBA_long
+impl_FileServer_File_Seek(impl_POA_FileServer_File * servant,
+			  CORBA_long Offset,
+			  FileServer_File_SeekDirection Direction,
+			  CORBA_Environment * ev);
+
+static FileServer_File
+impl_FileServer_File_Duplicate(impl_POA_FileServer_File * servant,
+			       CORBA_Environment * ev);
+
+static void impl_FileServer_FileSystem__destroy(impl_POA_FileServer_FileSystem
+						* servant,
+
+						CORBA_Environment * ev);
+static FileServer_File
+impl_FileServer_FileSystem_Open(impl_POA_FileServer_FileSystem * servant,
+				CORBA_char * Filename, CORBA_long openFlags,
+				CORBA_short mode, CORBA_Environment * ev);
+
+static FileServer_File
+impl_FileServer_FileSystem_Create(impl_POA_FileServer_FileSystem * servant,
+				  CORBA_char * Filename,
+				  CORBA_short mode, CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_Link(impl_POA_FileServer_FileSystem * servant,
+				CORBA_char * FromPath,
+				CORBA_char * ToPath, CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_Unlink(impl_POA_FileServer_FileSystem * servant,
+				  CORBA_char * Filename,
+
+				  CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_Rename(impl_POA_FileServer_FileSystem * servant,
+				  CORBA_char * OldName,
+				  CORBA_char * NewName,
+
+				  CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_ReadLink(impl_POA_FileServer_FileSystem * servant,
+				    CORBA_char * Linkname,
+				    CORBA_char ** LinkValue,
+				    CORBA_Environment * ev);
+
+static FileServer_FileStatus
+impl_FileServer_FileSystem_GetStatus(impl_POA_FileServer_FileSystem * servant,
+				     CORBA_char * Filename,
+				     CORBA_Environment * ev);
+
+static FileServer_FileStatus
+impl_FileServer_FileSystem_GetLinkStatus(impl_POA_FileServer_FileSystem *
+					 servant, CORBA_char * Filename,
+					 CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_MakeDirectory(impl_POA_FileServer_FileSystem *
+					 servant, CORBA_char * PathName,
+                                         CORBA_short mode,
+					 CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_RemoveDirectory(impl_POA_FileServer_FileSystem *
+					   servant, CORBA_char * PathName,
+					   CORBA_Environment * ev);
+
+static CORBA_char
+   *impl_FileServer_FileSystem_ChangeDirectory(impl_POA_FileServer_FileSystem
+					       * servant,
+					       CORBA_char * PathName,
+					       CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_MakeNode(impl_POA_FileServer_FileSystem * servant,
+				    CORBA_char * FileName,
+				    CORBA_short Mode,
+				    CORBA_long DeviceNum,
+
+				    CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_Mount(impl_POA_FileServer_FileSystem * servant,
+				 CORBA_char * DeviceFile,
+				 CORBA_char * Location,
+				 CORBA_char * FSType,
+				 CORBA_long Flags, CORBA_Environment * ev);
+
+static void
+impl_FileServer_FileSystem_Unmount(impl_POA_FileServer_FileSystem * servant,
+				   CORBA_char * Filename,
+
+				   CORBA_Environment * ev);
+
+/*** epv structures ***/
+static PortableServer_ServantBase__epv impl_Errors_base_epv = {
+   NULL,			/* _private data */
+   NULL,			/* finalize routine */
+   NULL,			/* default_POA routine */
+};
+static POA_Errors__epv impl_Errors_epv = {
+   NULL,			/* _private */
+
+};
+
+static PortableServer_ServantBase__epv impl_FileServer_File_base_epv = {
+   NULL,			/* _private data */
+   NULL,			/* finalize routine */
+   NULL,			/* default_POA routine */
+};
+static POA_FileServer_File__epv impl_FileServer_File_epv = {
+   NULL,			/* _private */
+   (gpointer) & impl_FileServer_File_Read,
+
+   (gpointer) & impl_FileServer_File_Write,
+
+   (gpointer) & impl_FileServer_File_Close,
+
+   (gpointer) & impl_FileServer_File_FileControl,
+
+   (gpointer) & impl_FileServer_File_GetStatus,
+
+   (gpointer) & impl_FileServer_File_ChangeDirectoryTo,
+
+   (gpointer) & impl_FileServer_File_Seek,
+
+   (gpointer) & impl_FileServer_File_Duplicate,
+
+};
+static POA_Errors__epv impl_FileServer_File_Errors_epv = {
+   NULL,			/* _private */
+};
+static PortableServer_ServantBase__epv impl_FileServer_FileSystem_base_epv = {
+   NULL,			/* _private data */
+   NULL,			/* finalize routine */
+   NULL,			/* default_POA routine */
+};
+static POA_FileServer_FileSystem__epv impl_FileServer_FileSystem_epv = {
+   NULL,			/* _private */
+   (gpointer) & impl_FileServer_FileSystem_Open,
+
+   (gpointer) & impl_FileServer_FileSystem_Create,
+
+   (gpointer) & impl_FileServer_FileSystem_Link,
+
+   (gpointer) & impl_FileServer_FileSystem_Unlink,
+
+   (gpointer) & impl_FileServer_FileSystem_Rename,
+
+   (gpointer) & impl_FileServer_FileSystem_ReadLink,
+
+   (gpointer) & impl_FileServer_FileSystem_GetStatus,
+
+   (gpointer) & impl_FileServer_FileSystem_GetLinkStatus,
+
+   (gpointer) & impl_FileServer_FileSystem_MakeDirectory,
+
+   (gpointer) & impl_FileServer_FileSystem_RemoveDirectory,
+
+   (gpointer) & impl_FileServer_FileSystem_ChangeDirectory,
+
+   (gpointer) & impl_FileServer_FileSystem_MakeNode,
+
+   (gpointer) & impl_FileServer_FileSystem_Mount,
+
+   (gpointer) & impl_FileServer_FileSystem_Unmount,
+
+};
+static POA_Errors__epv impl_FileServer_FileSystem_Errors_epv = {
+   NULL,			/* _private */
+};
+
+/*** vepv structures ***/
+static POA_Errors__vepv impl_Errors_vepv = {
+   &impl_Errors_base_epv,
+   &impl_Errors_epv,
+};
+
+static POA_FileServer_File__vepv impl_FileServer_File_vepv = {
+   &impl_FileServer_File_base_epv,
+   &impl_FileServer_File_Errors_epv,
+   &impl_FileServer_File_epv,
+};
+static POA_FileServer_FileSystem__vepv impl_FileServer_FileSystem_vepv = {
+   &impl_FileServer_FileSystem_base_epv,
+   &impl_FileServer_FileSystem_Errors_epv,
+   &impl_FileServer_FileSystem_epv,
+};
+
+/*** Stub implementations ***/
+static Errors
+impl_Errors__create(PortableServer_POA poa, CORBA_Environment * ev)
+{
+   Errors retval;
+   impl_POA_Errors *newservant;
+   PortableServer_ObjectId *objid;
+
+   newservant = g_new0(impl_POA_Errors, 1);
+   newservant->servant.vepv = &impl_Errors_vepv;
+   newservant->poa = poa;
+   POA_Errors__init((PortableServer_Servant) newservant, ev);
+   objid = PortableServer_POA_activate_object(poa, newservant, ev);
+   CORBA_free(objid);
+   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);
+
+   return retval;
+}
+
+static void
+impl_Errors__destroy(impl_POA_Errors * servant, CORBA_Environment * ev)
+{
+   PortableServer_ObjectId *objid;
+
+   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
+   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
+   CORBA_free(objid);
+
+   POA_Errors__fini((PortableServer_Servant) servant, ev);
+   g_free(servant);
+}
+
+static FileServer_File
+impl_FileServer_File__create(PortableServer_POA poa, CORBA_Environment * ev)
+{
+   FileServer_File retval;
+   impl_POA_FileServer_File *newservant;
+   PortableServer_ObjectId *objid;
+
+   newservant = g_new0(impl_POA_FileServer_File, 1);
+   newservant->servant.vepv = &impl_FileServer_File_vepv;
+   newservant->poa = poa;
+   newservant->fd = -1;
+   
+   POA_FileServer_File__init((PortableServer_Servant) newservant, ev);
+   objid = PortableServer_POA_activate_object(poa, newservant, ev);
+   CORBA_free(objid);
+   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);
+
+   return retval;
+}
+
+static void
+impl_FileServer_File__destroy(impl_POA_FileServer_File * servant,
+			      CORBA_Environment * ev)
+{
+   PortableServer_ObjectId *objid;
+
+   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
+   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
+   CORBA_free(objid);
+
+   POA_FileServer_File__fini((PortableServer_Servant) servant, ev);
+   g_free(servant);
+}
+
+static void
+impl_FileServer_File_Read(impl_POA_FileServer_File * servant,
+			  CORBA_long count,
+			  FileServer_buffer ** buf, CORBA_Environment * ev)
+{
+        size_t num_read;
+
+        *buf = FileServer_buffer__alloc();
+        (*buf)->_maximum = count;
+        (*buf)->_buffer = CORBA_octet_allocbuf(count);
+        (*buf)->_length = 0;
+        
+        printf("File->Read(%d, char *buf)\n", count);
+
+        if (servant->fd == -1) /* Trying to read from a closed file */
+        {
+                printf("File->Read ERROR : fd == -1\n");
+                set_exception(EBADF, ev);
+                return;
+        }
+
+        num_read = read(servant->fd, (*buf)->_buffer, count);
+        if (num_read == -1)
+        {
+                printf("File->Read ERROR : %d\n", errno);
+                set_exception(errno, ev);
+                return;
+        } 
+
+        (*buf)->_length = num_read;
+}
+
+static void
+impl_FileServer_File_Write(impl_POA_FileServer_File * servant,
+			   FileServer_buffer * buf, CORBA_Environment * ev)
+{
+	printf("UNIMP: FileServer::File::Write called and unimplemented\n");
+}
+
+static void
+impl_FileServer_File_Close(impl_POA_FileServer_File * servant,
+			   CORBA_Environment * ev)
+{
+        printf("File->Close()\n");
+
+        if (servant->fd == -1) /* This should never happen !?! */
+        {
+                printf("File->Close ERROR : fd == -1\n");
+                set_exception(EBADF, ev);
+                return;
+        }
+        
+        close(servant->fd);
+        servant->fd = 0;
+        impl_FileServer_File__destroy(servant, ev);
+}
+
+static CORBA_long
+impl_FileServer_File_FileControl(impl_POA_FileServer_File * servant,
+				 CORBA_long command, CORBA_Environment * ev)
+{
+   CORBA_long retval;
+
+   if (servant->fd == -1)
+   {
+           printf("File->FileControl ERROR : fd == -1\n");
+           set_exception(EBADF, ev);
+           return -1;
+   }
+   
+   retval = fcntl(servant->fd, command, 0); /* FIXME arg? */
+   if (retval == -1)
+   {
+           printf("File->FileControl ERROR : %d\n", errno);
+           set_exception(errno, ev);
+   }
+
+   return retval;
+}
+
+
+FileServer_FileStatus
+stat2FileStatus(struct stat buf) 
+{
+        FileServer_FileStatus retval;
+        
+        retval.DeviceNum    = buf.st_dev;
+        retval.InodeNum     = buf.st_ino;
+        retval.Mode         = buf.st_mode;
+        retval.NumLinks     = buf.st_nlink;
+        retval.UserID       = buf.st_uid;
+        retval.GroupID      = buf.st_gid;
+        retval.DeviceType   = buf.st_rdev;
+        retval.Size         = buf.st_size;
+        retval.BlockSize    = buf.st_blksize;
+        retval.NumBlocks    = buf.st_blocks;
+        retval.AccessTime   = buf.st_atime;
+        retval.ModifiedTime = buf.st_mtime;
+        retval.ChangeTime   = buf.st_ctime;
+
+        return retval;
+}
+
+
+static FileServer_FileStatus
+impl_FileServer_File_GetStatus(impl_POA_FileServer_File * servant,
+			       CORBA_Environment * ev)
+{
+   FileServer_FileStatus retval;
+
+   struct stat buf;
+   int res;
+   
+   if (servant->fd == -1)
+   {
+           printf("File->GetStatus ERROR : fd == -1\n");
+           set_exception(EBADF, ev);
+           return retval;
+   }
+   
+   res = fstat(servant->fd, &buf);
+   if (res == -1)
+   {
+           printf("File->GetStatus ERROR : %d\n", errno);
+           set_exception(errno, ev);
+           return retval;
+   }
+
+   retval = stat2FileStatus(buf);
+
+   return retval;
+}
+
+static void
+impl_FileServer_File_ChangeDirectoryTo(impl_POA_FileServer_File * servant,
+				       CORBA_Environment * ev)
+{
+  printf("UNIMP: impl_FileServer_File_ChangeDirectoryTo\n");
+}
+
+static CORBA_long
+impl_FileServer_File_Seek(impl_POA_FileServer_File * servant,
+			  CORBA_long Offset,
+			  FileServer_File_SeekDirection Direction,
+			  CORBA_Environment * ev)
+{
+   CORBA_long retval = -1;
+   int whence;
+   
+   if (servant->fd == -1)
+   {
+           printf("File->Seek ERROR : fd == -1\n");
+           set_exception(EBADF, ev);
+           return retval;
+   }
+   
+   switch (Direction)
+   {
+   case FileServer_File_FromStart :
+           whence = SEEK_SET;
+           break;
+   case FileServer_File_FromCurrent :
+           whence = SEEK_CUR;
+           break;
+   case FileServer_File_FromEnd :
+           whence = SEEK_END;
+           break;
+   default :
+           set_exception(EINVAL, ev);
+           return retval;
+   }
+   
+   retval = lseek(servant->fd, Offset, whence);
+   if (retval == -1)
+   {
+           printf("File->Seek ERROR : %d\n", errno);
+           set_exception(errno, ev);
+   }
+   
+   return retval;
+}
+
+static FileServer_File
+impl_FileServer_File_Duplicate(impl_POA_FileServer_File * servant,
+			       CORBA_Environment * ev)
+{
+   FileServer_File retval;
+   printf("UNIMP: impl_FileServer_File_Duplicate\n");
+   return retval;
+}
+
+static FileServer_FileSystem
+impl_FileServer_FileSystem__create(PortableServer_POA poa,
+				   CORBA_Environment * ev)
+{
+   FileServer_FileSystem retval;
+   impl_POA_FileServer_FileSystem *newservant;
+   PortableServer_ObjectId *objid;
+
+   newservant = g_new0(impl_POA_FileServer_FileSystem, 1);
+   newservant->servant.vepv = &impl_FileServer_FileSystem_vepv;
+   newservant->poa = poa;
+   POA_FileServer_FileSystem__init((PortableServer_Servant) newservant, ev);
+   objid = PortableServer_POA_activate_object(poa, newservant, ev);
+   CORBA_free(objid);
+   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);
+
+   return retval;
+}
+
+static void
+impl_FileServer_FileSystem__destroy(impl_POA_FileServer_FileSystem * servant,
+				    CORBA_Environment * ev)
+{
+   PortableServer_ObjectId *objid;
+
+   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
+   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
+   CORBA_free(objid);
+
+   POA_FileServer_FileSystem__fini((PortableServer_Servant) servant, ev);
+   g_free(servant);
+}
+
+static FileServer_File
+impl_FileServer_FileSystem_Open(impl_POA_FileServer_FileSystem * servant,
+				CORBA_char * Filename,
+				CORBA_long openFlags,
+				CORBA_short mode, CORBA_Environment * ev)
+{
+   FileServer_File retval = CORBA_OBJECT_NIL;
+
+   impl_POA_FileServer_File *file;
+
+   printf("FileSystem->Open(%s,%x)\n", Filename, openFlags);
+   
+   retval = impl_FileServer_File__create(servant->poa, ev);
+
+   file = PortableServer_POA_reference_to_servant( servant->poa, retval, ev );
+   file->fd = open(Filename, openFlags, mode);
+
+   if (file->fd == -1) {
+           printf("FileSystem->Open ERROR : %d\n", errno);
+           set_exception(errno, ev);
+   }
+
+   return retval;
+}
+
+static FileServer_File
+impl_FileServer_FileSystem_Create(impl_POA_FileServer_FileSystem * servant,
+				  CORBA_char * Filename,
+				  CORBA_short mode, CORBA_Environment * ev)
+{
+   FileServer_File retval = CORBA_OBJECT_NIL;
+
+   impl_POA_FileServer_File *file;
+
+   printf("FileSystem->Create(%s,%x)\n", Filename, mode);
+   
+   retval = impl_FileServer_File__create(servant->poa, ev);
+
+   file = PortableServer_POA_reference_to_servant( servant->poa, retval, ev );
+   file->fd = creat(Filename, mode);
+
+   if (file->fd == -1) {
+           printf("FileSystem->Create ERROR : %d\n", errno);
+           set_exception(errno, ev);
+   }
+
+   return retval;
+}
+
+static void
+impl_FileServer_FileSystem_Link(impl_POA_FileServer_FileSystem * servant,
+				CORBA_char * FromPath,
+				CORBA_char * ToPath, CORBA_Environment * ev)
+{
+   printf("UNIMP: impl_FileServer_FileSystem_Link\n");
+}
+
+static void
+impl_FileServer_FileSystem_Unlink(impl_POA_FileServer_FileSystem * servant,
+				  CORBA_char * Filename,
+				  CORBA_Environment * ev)
+{
+   printf("UNIMP: impl_FileServer_FileSystem_Unlink\n");
+}
+
+static void
+impl_FileServer_FileSystem_Rename(impl_POA_FileServer_FileSystem * servant,
+				  CORBA_char * OldName,
+				  CORBA_char * NewName,
+				  CORBA_Environment * ev)
+{
+   printf("UNIMP: impl_FileServer_FileSystem_Rename\n");
+}
+
+static void
+impl_FileServer_FileSystem_ReadLink(impl_POA_FileServer_FileSystem * servant,
+				    CORBA_char * Linkname,
+				    CORBA_char ** LinkValue,
+				    CORBA_Environment * ev)
+{
+        char tmp[PATH_MAX + 1];
+        int res, len;
+        
+        printf("FileSystem->ReadLink(%s, value)\n", Linkname);
+        
+        res = readlink(Linkname, tmp, PATH_MAX);
+        if (res == -1)
+        {
+                set_exception(errno, ev);
+                return;
+        }
+        
+        len = strlen(tmp);
+        *LinkValue = (char *)malloc(len * sizeof(char));
+        memcpy(*LinkValue, tmp, len);
+        (*LinkValue)[len] = '\0';
+}
+
+static FileServer_FileStatus
+impl_FileServer_FileSystem_GetStatus(impl_POA_FileServer_FileSystem * servant,
+				     CORBA_char * Filename,
+				     CORBA_Environment * ev)
+{
+   FileServer_FileStatus retval;
+   struct stat buf;
+   int res;
+
+   printf("FileSystem->GetStatus(%s)\n", Filename);
+
+   res = stat(Filename, &buf);
+
+   if (res == -1)
+   {
+           printf("FileSystem->GetStatus(%s)\n", Filename);
+           set_exception(errno, ev);
+           return retval;
+   }
+
+   retval = stat2FileStatus(buf);
+
+   return retval;
+}
+
+static FileServer_FileStatus
+impl_FileServer_FileSystem_GetLinkStatus(impl_POA_FileServer_FileSystem *
+					 servant, CORBA_char * Filename,
+					 CORBA_Environment * ev)
+{
+   FileServer_FileStatus retval;
+   struct stat buf;
+   int res;
+
+   printf("FileSystem->GetLinkStatus(%s)\n", Filename);
+
+   res = lstat(Filename, &buf);
+
+   if (res == -1)
+   {
+           printf("FileSystem->GetLinkStatus(%s)\n", Filename);
+           set_exception(errno, ev);
+           return retval;
+   }
+   
+   retval = stat2FileStatus(buf);
+
+   return retval;
+}
+
+static void
+impl_FileServer_FileSystem_MakeDirectory(impl_POA_FileServer_FileSystem *
+					 servant, CORBA_char * PathName,
+                                         CORBA_short mode,
+					 CORBA_Environment * ev)
+{
+  printf("UNIMP: impl_FileServer_FileSystem_MakeDirectory\n");
+}
+
+static void
+impl_FileServer_FileSystem_RemoveDirectory(impl_POA_FileServer_FileSystem *
+					   servant, CORBA_char * PathName,
+					   CORBA_Environment * ev)
+{
+  printf("UNIMP: impl_FileServer_FileSystem_RemoveDirectory\n");
+}
+
+static CORBA_char *
+impl_FileServer_FileSystem_ChangeDirectory(impl_POA_FileServer_FileSystem *
+					   servant, CORBA_char * PathName,
+					   CORBA_Environment * ev)
+{
+   CORBA_char *retval;
+   printf("UNIMP: impl_FileServer_FileSystem_ChangeDirectory\n");
+   return retval;
+}
+
+static void
+impl_FileServer_FileSystem_MakeNode(impl_POA_FileServer_FileSystem * servant,
+				    CORBA_char * FileName,
+				    CORBA_short Mode,
+				    CORBA_long DeviceNum,
+				    CORBA_Environment * ev)
+{
+  printf("UNIMP: impl_FileServer_FileSystem_MakeNode\n");
+}
+
+static void
+impl_FileServer_FileSystem_Mount(impl_POA_FileServer_FileSystem * servant,
+				 CORBA_char * DeviceFile,
+				 CORBA_char * Location,
+				 CORBA_char * FSType,
+				 CORBA_long Flags, CORBA_Environment * ev)
+{
+  printf("UNIMP: impl_FileServer_FileSystem_Mount: ARE YOU CRAZY!?!?\n");
+}
+
+static void
+impl_FileServer_FileSystem_Unmount(impl_POA_FileServer_FileSystem * servant,
+				   CORBA_char * Filename,
+				   CORBA_Environment * ev)
+{
+  printf("UNIMP: impl_FileServer_FileSystem_Unmount: Ha ha ha funny guy!\n");
+}
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/Makefile linux-2.4.1-korbit/net/korbit/modules/FileServer/server/Makefile
--- linux-2.4.1/net/korbit/modules/FileServer/server/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/Makefile	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,20 @@
+#
+# Makefile for KORBit / FileServer
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := corba-fileserver-server.o
+
+obj-y := FileServer-common.o FileServer-skels.o FileServer-server.o
+obj-m := $(O_TARGET)
+
+include ../../Makefile.module
+
+FileServer-server.c: FileServer.h FileServer-common.c FileServer-skels.c FileServer-skelimpl.c
+
+FileServer.h FileServer-skels.c FileServer-common.c: ../FileServer.idl
+	$(ORBIT_IDL) ../FileServer.idl
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/Makefile.user linux-2.4.1-korbit/net/korbit/modules/FileServer/server/Makefile.user
--- linux-2.4.1/net/korbit/modules/FileServer/server/Makefile.user	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/Makefile.user	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,32 @@
+#
+# Makefile for KORBit
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+PROJECT = FileServer
+
+CFLAGS = -Wall `orbit-config --cflags server` -I../../..
+LDFLAGS = `orbit-config --libs server`
+OBJS = $(PROJECT)-common.o $(PROJECT)-skels.o $(PROJECT)-server.o 
+ORBIT-IDL = orbit-idl
+
+$(PROJECT)-server: $(OBJS)
+	gcc -o $(PROJECT)-server $(OBJS) $(LDFLAGS)
+
+$(PROJECT)-server.c: $(PROJECT).h $(PROJECT)-skelimpl.c
+
+$(PROJECT).h $(PROJECT)-common.c $(PROJECT)-skels.c $(PROJECT)-skelimpl.c: ../$(PROJECT).idl
+	$(ORBIT-IDL) --nostubs ../$(PROJECT).idl
+
+clean:
+	rm -f $(OBJS) $(PROJECT)-server
+
+realclean: clean
+	rm -f $(PROJECT).h
+	rm -f $(PROJECT)-common.c
+	rm -f $(PROJECT)-skels.c
+	rm -f *~
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server/README linux-2.4.1-korbit/net/korbit/modules/FileServer/server/README
--- linux-2.4.1/net/korbit/modules/FileServer/server/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server/README	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,4 @@
+Kernel side implementation of the file server functionality.
+
+ORB: kORBit
+Status: Mostly unimplemented.
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server-user/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/CVS/Entries
--- linux-2.4.1/net/korbit/modules/FileServer/server-user/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/CVS/Entries	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,4 @@
+/FileServer-server.c/1.1/Thu Feb  1 09:47:08 2001//
+/Makefile/1.1/Thu Feb  1 09:47:08 2001//
+/README/1.1/Thu Feb  1 09:47:08 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server-user/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/CVS/Repository
--- linux-2.4.1/net/korbit/modules/FileServer/server-user/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/CVS/Repository	Thu Feb  1 11:47:08 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/FileServer/server-user
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server-user/CVS/Root linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/CVS/Root
--- linux-2.4.1/net/korbit/modules/FileServer/server-user/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/CVS/Root	Thu Feb  1 11:47:08 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server-user/FileServer-server.c linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/FileServer-server.c
--- linux-2.4.1/net/korbit/modules/FileServer/server-user/FileServer-server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/FileServer-server.c	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,234 @@
+#include <OB/CORBA.h>
+#include <OB/Util.h>
+#include <OB/CosNaming.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include "FileServer_skel.h"
+
+static void ThrowErr() {
+  switch (errno) {
+  case 0: return;
+  case EISDIR:
+    throw Errors::IsDirectory();
+  case EPERM:
+    throw Errors::PermissionDenied();
+  case EEXIST:
+    throw Errors::FileExists();
+  case ENOENT:
+    throw Errors::FileNotFound();
+  case ENOTDIR:
+    throw Errors::IsNotDirectory();
+  case EROFS:
+  case ETXTBSY:
+    throw Errors::ReadOnlyFile();
+  case ELOOP:
+    throw Errors::RecursiveSymlink();
+  case EBUSY:
+    throw Errors::IsBusy();
+  default:
+    throw Errors::OtherError();
+  }
+}
+
+
+class FileServer_File_impl : public FileServer_File_skel {
+  int FD;
+ public:
+  FileServer_File_impl(int fd) { FD = fd; }
+
+  virtual void Read(CORBA_Long count, FileServer_buffer*& buf) {
+    errno = 0;
+    cout << "Read\n"; 
+    buf = new FileServer_buffer();
+    ThrowErr();
+  }
+
+  virtual void Write(const FileServer_buffer& buf) {
+    errno = 0;
+    cout << "Write\n";
+    ThrowErr();
+  }
+
+  virtual void Close() {
+    errno = 0;
+    close(FD);
+    cout << "Close()\n";
+    ThrowErr();
+  }
+
+  virtual CORBA_Long FileControl(CORBA_Long command) {
+    errno = 0;
+    cout << "filecontrol\n";
+    ThrowErr();
+    return 0;
+  }
+
+  virtual FileServer_FileStatus GetStatus() {
+    errno = 0;
+    cout << "stat\n";
+    FileServer_FileStatus Stat;
+    ThrowErr();
+    return Stat;
+  }
+
+  virtual void ChangeDirectoryTo() {
+    errno = 0;
+    cout << "ChangeDirectoryTo()\n";
+    ThrowErr();
+  }
+
+  virtual CORBA_Long Seek(CORBA_Long Offset, SeekDirection Direction) {
+    errno = 0;
+    cout << "Seek(" << Offset << ")\n";
+    ThrowErr();
+    return -1;
+  }
+
+  virtual FileServer_File_ptr Duplicate() {
+    errno = 0;
+    cout << "Duplicate!\n";
+    ThrowErr();
+    return 0;
+  }
+};
+
+
+class FileServer_impl : public FileServer_FileSystem_skel {
+  public :
+    virtual FileServer_File_ptr Open(const char* Filename,
+                                     CORBA_Long openFlags,
+                                     CORBA_Short mode) {
+    errno = 0;
+    int fd = open(Filename, openFlags, mode);
+    if (fd != -1) return new FileServer_File_impl(fd);
+    cout << "open\n";
+    ThrowErr();
+    return 0;
+  }
+
+  virtual FileServer_File_ptr Create(const char* Filename,
+				     CORBA_Short mode) {
+    errno = 0;
+    cout << "create\n";
+    ThrowErr();
+    return 0;
+  }
+
+
+  virtual void Link(const char* FromPath,
+		    const char* ToPath) {
+    errno = 0;
+    cout << "link\n";
+    ThrowErr();
+  }
+
+  virtual void Unlink(const char* Filename) {
+    errno = 0;
+    cout << "unlink\n";
+    ThrowErr();
+  }
+    
+  virtual void Rename(const char* OldName,
+		      const char* NewName) {
+    errno = 0;
+    cout << "rename\n";
+    ThrowErr();
+  }
+
+
+  virtual void ReadLink(const char* Linkname,
+			char*& LinkValue) {
+    errno = 0;
+    cout << "readlink\n";
+    ThrowErr();
+  }
+
+  virtual FileServer_FileStatus GetStatus(const char* Filename) {
+    errno = 0;
+    cout << "stat\n";
+    FileServer_FileStatus Stat;
+    ThrowErr();
+    return Stat;
+  }
+
+
+  virtual FileServer_FileStatus GetLinkStatus(const char* Filename) {
+    errno = 0;
+    cout << "lstat\n";
+    FileServer_FileStatus Stat;
+    ThrowErr();
+    return Stat;
+  }
+
+
+  virtual void MakeDirectory(const char* PathName,
+			     CORBA_Short mode) {
+    errno = 0;
+    cout << "mkdir\n";
+    ThrowErr();
+  }
+
+  virtual void RemoveDirectory(const char* PathName) {
+    errno = 0;
+    cout << "rmdir\n";
+    ThrowErr();
+  }
+
+
+  virtual char* ChangeDirectory(const char* PathName) {
+    errno = 0;
+    cout << "chdir\n";
+    ThrowErr();
+    return CORBA_string_dup("hello");
+  }
+
+  virtual void MakeNode(const char* FileName,
+			CORBA_Short Mode,
+			CORBA_Long DeviceNum) {
+    errno = 0;
+    cout << "mknod\n";
+    ThrowErr();
+  }
+
+
+  virtual void Mount(const char* DeviceFile,
+		     const char* Location,
+		     const char* FSType,
+		     CORBA_Long Flags) {
+    errno = 0;
+    cout << "Mount\n";
+    ThrowErr();
+  }
+
+  virtual void Unmount(const char* Filename) {
+    errno = 0;
+    cout << "Unmount\n";
+    ThrowErr();
+  }
+};
+
+
+int main(int argc, char* argv[]) {
+    cout << "FileServer UserSpace Server initializing" << endl;
+
+    try {
+      CORBA_ORB_var orb = CORBA_ORB_init(argc, argv);
+      CORBA_BOA_var boa = orb->BOA_init(argc, argv);
+      
+      FileServer_FileSystem_var FS = new FileServer_impl();
+
+      cout << orb->object_to_string(FS) << endl;
+
+      //
+      // Run implementation
+      //
+      boa -> impl_is_ready(CORBA_ImplementationDef::_nil());
+    } catch(CORBA_SystemException& ex) {
+        OBPrintException(ex);
+        return 1;
+    }
+}
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server-user/Makefile linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/Makefile
--- linux-2.4.1/net/korbit/modules/FileServer/server-user/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/Makefile	Thu Feb  1 11:47:08 2001
@@ -0,0 +1,29 @@
+CC = CC -mt -pta
+OBDIR = /home/class/cs423/local
+IDL = $(OBDIR)/bin/idl
+CPPFLAGS = -I. -I$(OBDIR)/include
+LDFLAGS = -L$(OBDIR)/lib 
+LIBS = -lCosNaming -lOB -lJTC -lsocket -lnsl -lposix4
+
+all: FileServer
+
+FileServer: FileServer.o FileServer-server.o FileServer_skel.o
+	$(CC) $(LDFLAGS) -o FileServer FileServer-server.o FileServer.o FileServer_skel.o $(LIBS)
+
+FileServer.h FileServer.cpp: ../FileServer.idl
+	rm -f FileServer.cpp FileServer.h
+	rm -f FileServer_skel.h FileServer_skel.cpp
+	$(IDL) ../FileServer.idl
+
+FileServer_skel.cpp FileServer_skel.h: FileServer.cpp
+
+%.o: %.cpp
+	$(CC) $(CPPFLAGS) -c $<
+
+clean:
+	rm -f FileServer *.o *~
+
+realclean: clean
+	rm -f FileServer.h FileServer.cpp
+	rm -f FileServer_skel.h FileServer_skel.cpp
+	rm -rf SunWS_cache
diff -urN linux-2.4.1/net/korbit/modules/FileServer/server-user/README linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/README
--- linux-2.4.1/net/korbit/modules/FileServer/server-user/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/server-user/README	Thu Feb  1 11:47:08 2001
@@ -0,0 +1 @@
+This is a user space implementation of the FileServer interface.
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/CVS/Entries
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/CVS/Entries	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,6 @@
+/FileServer_wrapper.cpp/1.2/Thu Feb  1 09:47:09 2001//
+/FileServer_wrapper.h/1.2/Thu Feb  1 09:47:09 2001//
+/Makefile/1.1/Thu Feb  1 09:47:09 2001//
+/README/1.1/Thu Feb  1 09:47:09 2001//
+/test.c/1.2/Thu Feb  1 09:47:09 2001//
+D
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/CVS/Repository
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/CVS/Repository	Thu Feb  1 11:47:09 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/FileServer/wrapper
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/CVS/Root linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/CVS/Root
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/CVS/Root	Thu Feb  1 11:47:09 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.cpp linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.cpp
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.cpp	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.cpp	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,135 @@
+/*
+ * FileServer_wrapper.cpp
+ *
+ * We want to intercept *all* file I/O, so that once the LD_PRELOAD
+ * variable is set, everything you see is on the remote side.
+ *
+ * Needed environment variables:
+ *	LD_PRELOAD - duh (what's the lib name?)
+ *	KORBIT_IOR - IOR of the file servin' ORB to connect to.
+ *	
+ */
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+#include <errno.h>
+
+#include "OB/CORBA.h"
+//#include "OB/Util.h" 
+//#include "OB/CosNaming.h"
+
+#include "FileServer.h"
+#include "FileServer_wrapper.h"
+
+#define DEBUG
+
+#ifdef DEBUG
+#define debugOut(X) cerr << X << flush;
+#else
+#define debugOut(X)
+#endif
+
+
+FileSystemState::FileSystemState() {
+  char *argv[] = { (char*)"/usr/bin/mkdir", 0 };
+  int argc = 1;
+
+  debugOut ("FS_wrapper: InitializeOrb(): start.\n");
+  
+  /* Set 'PerformingInitialization = true'? */
+  
+  orb = CORBA_ORB_init(argc, argv);
+  if (CORBA_is_nil(orb)) {
+    cerr << "Error initializing ORB!\n";
+    exit(1);
+  }
+  debugOut ("\tORB initialized successfully.\n");
+  
+  const char *env = getenv("KORBIT_IOR");
+  if (!env) {
+    // This should check /proc/corba/FileServer-server also!
+    cerr << "InitializeOrb Error: KORBIT_IOR not found in environment!\n";
+    exit(1);
+  }
+
+  cout << "IOR = " << env << endl;
+
+  // WHY DO I HANG IN string_to_object??
+  CORBA_Object_var obj = orb->string_to_object(env);
+  debugOut("\tORB initialized successfully.\n");
+  
+  if (CORBA_is_nil(obj)) {
+    cerr << "InitializeOrb Error: IOR is invalid: " << env << endl;
+    exit (1);
+  }
+
+  debugOut ("\tORB initialized successfully.\n");
+  try {
+    FS = FileServer_FileSystem::_narrow(obj);
+  } catch (...) {
+    cerr << "InitializeOrb Error: Got an exception from _narrow().\n";
+    exit (1);
+  }
+  
+  /* Initialize my data structure 'o file descriptors. */
+
+  // Set up mapping for stdin, stdout, stderr.  Set up a new fd, #4 for 
+  // console/debug output
+
+  // stderr can go to console for now.
+
+  debugOut ("FS_wrapper: InitializeOrb(): finished successfully.\n");
+} /* End InitializeOrb(). */
+
+
+FileSystemState::~FileSystemState() (void) {
+} /* End CleanupOrb(). */
+
+
+void HandleException(CORBA_UserException &Exception) {
+  try {
+    throw Exception;  // get the type back...
+  } catch (Errors::FileExists &) {
+    errno = EEXIST;
+  } catch (Errors::PermissionDenied &) {
+    errno = EACCES;
+  } catch (Errors::FileNotFound &) {
+    errno = ENOENT;
+  } catch (Errors::IsNotDirectory &) {
+    errno = ENOTDIR;
+  } catch (Errors::ReadOnlyFile &) {
+    errno = EROFS;
+  } catch (Errors::RecursiveSymlink &) {
+    errno = ELOOP;
+  } catch (Errors::OtherError &) {
+    errno = EIO; /* I/O error */
+  } catch (CORBA_UserException &Exception) {
+    cerr << "unknown exception occurred! \n";
+  }
+}
+
+//int open(const char *path, int oflag, mode_t mode) {
+
+
+//  return -1;
+//}
+
+int mkdir(const char *pathname, mode_t mode) {
+  debugOut("FS_wrapper: mkdir(" << pathname << "): start.\n");
+
+  try {
+    FileSystemState::get().getFS()->MakeDirectory(pathname, mode);
+  } catch (CORBA_UserException &ex) {
+    HandleException(ex);
+    return -1;
+  }
+
+  // Success! 
+  debugOut("FS wrapper: mkdir(): finish successfully.\n");
+  return 0;	
+} // End mkdir()
+
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.h linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.h
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/FileServer_wrapper.h	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,81 @@
+// The KORBit FileServer wrapper, which is a shared library that gets
+// hit with the LD_PRELOAD action, so as to redirect all FS calls
+// out the CORBA hole.
+//
+// Note that most of these functions have the side effect of modifying errno.
+//
+#ifndef FILESERVER_WRAPPER_H
+#define FILESERVER_WRAPPER_H
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+// This class contains all the global variables for this file.  It is very 
+// important that we use this mechanism so that our library is initialized as 
+// early as possible, but no earlier.  In particular this means that we cannot
+// be initialized before iostreams are, which we use for debugging.  This scheme
+// the only way to that we are constructed and descructed on demand.
+//
+class FileSystemState {
+private:
+  FileSystemState();  // private ctor/dtor.  The only way to get one of these is 
+  ~FileSystemState(); // to call FileSystemState::get()
+
+  FileSystemState(const FileSystemState &);            // do not implement
+  FileSystemState &operator=(const FileSystemState &); // do not implement
+
+
+  CORBA_ORB_var orb;	          // Global reference to the orb.
+  FileServer_FileSystem_var FS;   // Global reference to FS object...
+public:
+  static FileSystemState &get() {
+    // Static objects like this are intialized the first time they are used, and
+    // destroyed when the project shuts down.  This is exactly the semantics we 
+    // want.
+    static FileSystemState FSS;
+    return FSS;
+  }
+
+  CORBA_ORB_var getORB() { return orb; }
+  FileServer_FileSystem_var getFS() { return FS; }
+};
+
+extern "C" {
+
+  //
+  // interface File
+  //
+  // pread, readv, pwrite, writev
+  int read(int FD, void *Buffer, size_t NumBytes);
+  int write(int FD, void *Buffer, size_t NumBytes);
+  int close(int FD);
+  // fcntl
+  // fstat
+  // fchdir
+  // seek
+  int dup(int FD);
+  int dup2(int FDFrom, int FDTo);
+	
+  //
+  // interface FileSystem
+  //
+  //  int open(const char *path, int oflag, mode_t mode);
+  int creat(const char *path, mode_t mode);
+
+//	link
+//	unlink
+//	rename
+//	readlink
+//      stat
+//      lstat
+  int mkdir(const char *Path, mode_t Mode);
+//	rmdir
+  int chdir(const char *Path);
+}
+
+//
+// Local function prototypes.
+//
+
+#endif
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/Makefile linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/Makefile
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/Makefile	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,29 @@
+CC = CC -mt -pta -g
+OBDIR = /home/class/cs423/local
+IDL = $(OBDIR)/bin/idl
+CPPFLAGS = -I. -I$(OBDIR)/include
+LDFLAGS = -L$(OBDIR)/lib -G -fPIC
+LIBS = -lCosNaming -lOB -lJTC -lsocket -lnsl -lposix4  -lCstd -lCrun
+
+all: libfswrapper.so 
+
+libfswrapper.so: FileServer.o FileServer_wrapper.o
+	CC $(LDFLAGS) -o $@ FileServer_wrapper.o FileServer.o $(LIBS)
+
+FileServer.h FileServer.cpp: ../FileServer.idl
+	rm -f FileServer.cpp FileServer.h
+	rm -f FileServer_skel.h FileServer_skel.cpp
+	$(IDL) ../FileServer.idl
+
+FileServer_skel.cpp FileServer_skel.h: FileServer.cpp
+
+%.o: %.cpp
+	$(CC) $(CPPFLAGS) -c $<
+
+clean:
+	rm -f libfswrapper.so *.o *~
+
+realclean: clean
+	rm -f FileServer.h FileServer.cpp
+	rm -f FileServer_skel.h FileServer_skel.cpp
+	rm -rf SunWS_cache
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/README linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/README
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/README	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,5 @@
+This is a library that may be LD_PRELOAD'd to forward filesystem related calls
+through the FileServer interface.
+
+ORB: ORBacus
+Status: Mostly not working
diff -urN linux-2.4.1/net/korbit/modules/FileServer/wrapper/test.c linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/test.c
--- linux-2.4.1/net/korbit/modules/FileServer/wrapper/test.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/FileServer/wrapper/test.c	Thu Feb  1 11:47:09 2001
@@ -0,0 +1,15 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+int main(void)
+{
+	if (mkdir("test", 0666) == -1)
+		{
+		perror ("mkdir failed because: ");
+		return (1);
+		}
+
+	return (0);
+}
diff -urN linux-2.4.1/net/korbit/modules/Makefile linux-2.4.1-korbit/net/korbit/modules/Makefile
--- linux-2.4.1/net/korbit/modules/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Makefile	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,15 @@
+#
+# Makefile for KORBit/modules
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+subdir-$(CONFIG_CORBA_CONSOLE) += Console
+subdir-$(CONFIG_CORBA_ECHO) += Echo
+subdir-$(CONFIG_CORBA_FILESERVER) += FileServer
+subdir-$(CONFIG_CORBA_CORBAFS) += CorbaFS
+subdir-$(CONFIG_CORBA_CHARDEV) += CharDev
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/Makefile.module linux-2.4.1-korbit/net/korbit/modules/Makefile.module
--- linux-2.4.1/net/korbit/modules/Makefile.module	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/Makefile.module	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,9 @@
+M_OBJS := $(O_TARGET)
+
+EXTRA_CFLAGS = -D__KORBIT__ -DHAVE_CONFIG_H -I. -I../../.. -I../../../include -I../../../kglib -nostdinc
+
+
+ORBIT_IDL = orbit-idl
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/modules/README linux-2.4.1-korbit/net/korbit/modules/README
--- linux-2.4.1/net/korbit/modules/README	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/README	Thu Feb  1 11:46:58 2001
@@ -0,0 +1,7 @@
+Modules included so far:
+
+CharDev   : Implement Linux character device drivers
+Console   : Print strings to the Linux console
+CorbaFS   : Implement Linux filesystems through the VFS layer
+Echo      : Testcase to test orb two-way communication
+FileServer: Access a filesystem through CORBA
diff -urN linux-2.4.1/net/korbit/modules/UserFS/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Entries
--- linux-2.4.1/net/korbit/modules/UserFS/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Entries	Thu Feb  1 11:47:09 2001
@@ -0,0 +1 @@
+D
diff -urN linux-2.4.1/net/korbit/modules/UserFS/CVS/Entries.Log linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Entries.Log
--- linux-2.4.1/net/korbit/modules/UserFS/CVS/Entries.Log	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Entries.Log	Thu Feb  1 11:47:10 2001
@@ -0,0 +1 @@
+A D/client////
diff -urN linux-2.4.1/net/korbit/modules/UserFS/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Repository
--- linux-2.4.1/net/korbit/modules/UserFS/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Repository	Thu Feb  1 11:47:09 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/UserFS
diff -urN linux-2.4.1/net/korbit/modules/UserFS/CVS/Root linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Root
--- linux-2.4.1/net/korbit/modules/UserFS/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/CVS/Root	Thu Feb  1 11:47:09 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/modules/UserFS/client/CVS/Entries linux-2.4.1-korbit/net/korbit/modules/UserFS/client/CVS/Entries
--- linux-2.4.1/net/korbit/modules/UserFS/client/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/client/CVS/Entries	Thu Feb  1 11:47:10 2001
@@ -0,0 +1 @@
+D
diff -urN linux-2.4.1/net/korbit/modules/UserFS/client/CVS/Repository linux-2.4.1-korbit/net/korbit/modules/UserFS/client/CVS/Repository
--- linux-2.4.1/net/korbit/modules/UserFS/client/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/client/CVS/Repository	Thu Feb  1 11:47:10 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/modules/UserFS/client
diff -urN linux-2.4.1/net/korbit/modules/UserFS/client/CVS/Root linux-2.4.1-korbit/net/korbit/modules/UserFS/client/CVS/Root
--- linux-2.4.1/net/korbit/modules/UserFS/client/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/modules/UserFS/client/CVS/Root	Thu Feb  1 11:47:10 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/orb/CVS/Entries linux-2.4.1-korbit/net/korbit/orb/CVS/Entries
--- linux-2.4.1/net/korbit/orb/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/CVS/Entries	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,60 @@
+/Makefile/1.6/Thu Feb  1 09:47:10 2001//
+/allocator-defs.h/1.1.1.1/Thu Feb  1 09:47:10 2001//
+/allocators.c/1.2/Thu Feb  1 09:47:10 2001//
+/allocators.h/1.1.1.1/Thu Feb  1 09:47:10 2001//
+/cdr.c/1.1.1.1/Thu Feb  1 09:47:10 2001//
+/cdr.h/1.1.1.1/Thu Feb  1 09:47:10 2001//
+/corba_any.c/1.3/Thu Feb  1 09:47:10 2001//
+/corba_any.h/1.1.1.1/Thu Feb  1 09:47:10 2001//
+/corba_any_proto.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_any_type.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_basic_sequences_type.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_context.c/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_context.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_env.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_env_type.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_object.c/1.7/Thu Feb  1 09:47:11 2001//
+/corba_object.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_object_type.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_orb.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_orb_type.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_portableserver.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_portableserver_type.h/1.1.1.1/Thu Feb  1 09:47:11 2001//
+/corba_sequences.h/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/corba_sequences_type.h/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/corba_typecode.h/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/corba_typecode_type.h/1.3/Thu Feb  1 09:47:12 2001//
+/dii.c/1.2/Thu Feb  1 09:47:12 2001//
+/dii.h/1.2/Thu Feb  1 09:47:12 2001//
+/env.c/1.2/Thu Feb  1 09:47:12 2001//
+/env.h/1.2/Thu Feb  1 09:47:12 2001//
+/genrand.c/1.4/Thu Feb  1 09:47:12 2001//
+/genrand.h/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/iop.h/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/ir.c/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/ir.h/1.1.1.1/Thu Feb  1 09:47:12 2001//
+/options.c/1.2/Thu Feb  1 09:47:12 2001//
+/options.h/1.2/Thu Feb  1 09:47:13 2001//
+/orb.c/1.13/Thu Feb  1 09:47:13 2001//
+/orb.h/1.2/Thu Feb  1 09:47:13 2001//
+/orbit.c/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit.h/1.2/Thu Feb  1 09:47:13 2001//
+/orbit.h.in/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_config.h/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_object.c/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_object.h/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_object_type.h/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_poa.c/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_poa.h/1.3/Thu Feb  1 09:47:13 2001//
+/orbit_poa_type.h/1.1.1.1/Thu Feb  1 09:47:13 2001//
+/orbit_typecode.c/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/orbit_typecode.h/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/orbit_types.h/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/poa.c/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/poa.h/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/sequences.c/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/sequences.h/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/server.c/1.5/Thu Feb  1 09:47:14 2001//
+/typecode.c/1.1.1.1/Thu Feb  1 09:47:14 2001//
+/typecode.h/1.1.1.1/Thu Feb  1 09:47:14 2001//
+D
diff -urN linux-2.4.1/net/korbit/orb/CVS/Repository linux-2.4.1-korbit/net/korbit/orb/CVS/Repository
--- linux-2.4.1/net/korbit/orb/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/CVS/Repository	Thu Feb  1 11:47:10 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/orb
diff -urN linux-2.4.1/net/korbit/orb/CVS/Root linux-2.4.1-korbit/net/korbit/orb/CVS/Root
--- linux-2.4.1/net/korbit/orb/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/CVS/Root	Thu Feb  1 11:47:10 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
diff -urN linux-2.4.1/net/korbit/orb/Makefile linux-2.4.1-korbit/net/korbit/orb/Makefile
--- linux-2.4.1/net/korbit/orb/Makefile	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/Makefile	Thu Feb  1 11:47:10 2001
@@ -0,0 +1,25 @@
+#
+# Makefile for KORBit/orb
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .o file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := orblib.o
+
+#obj-m := $(O_TARGET)
+obj-y := allocators.o options.o poa.o \
+          cdr.o env.o orb.o sequences.o \
+          corba_any.o genrand.o orbit.o server.o \
+          corba_context.o orbit_object.o typecode.o \
+          corba_object.o orbit_poa.o \
+          dii.o ir.o orbit_typecode.o
+
+EXTRA_CFLAGS = -D__KORBIT__ -DHAVE_CONFIG_H -I. -I.. -I../include -I../kglib -I../ORBitutil -nostdinc \
+               -DORBit_SYSRC=\"/etc/orbitrc\" \
+               -DORBIT_MAJOR_VERSION="0" -DORBIT_MINOR_VERSION="5" -DORBIT_MICRO_VERSION="3" -DORBIT_VERSION=\"0.5.3\"
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux-2.4.1/net/korbit/orb/allocator-defs.h linux-2.4.1-korbit/net/korbit/orb/allocator-defs.h
--- linux-2.4.1/net/korbit/orb/allocator-defs.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/allocator-defs.h	Thu Feb  1 11:47:10 2001
@@ -0,0 +1,40 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* By Elliot Lee. Copyright (c) 1998 Red Hat Software */
+
+
+/********************************************************
+ * Never include this header file directly. Only allocators.[ch]
+ * should do this
+ ********************************************************/
+
+/* Macro crap */
+
+#ifdef ALLOCATOR_DEFINITION
+
+#define ORBIT_DEFINE_CHUNK(x, xsize) \
+DEFINE_LOCK(x##_allocator); \
+GMemChunk *x##_allocator = NULL
+
+#elif defined(ALLOCATOR_INITIALIZATION)
+
+#define ORBIT_DEFINE_CHUNK(x, xsize) INIT_LOCK(x##_allocator); \
+x##_allocator = g_mem_chunk_new(#x, (xsize), \
+(xsize) * ORBIT_CHUNKS_PREALLOC, G_ALLOC_AND_FREE)
+
+#else
+
+#define ORBIT_DEFINE_CHUNK(x, xsize) \
+EXTERN_LOCK(x##_allocator); \
+extern GMemChunk *x##_allocator
+
+#endif
+
+/*****************************************************
+ * Here's where we define the actual chunks that are used
+ *****************************************************/
+ORBIT_DEFINE_CHUNK(CORBA_TypeCode, sizeof(struct CORBA_TypeCode_struct));
+ORBIT_DEFINE_CHUNK(CORBA_Object, sizeof(struct CORBA_Object_struct));
+ORBIT_DEFINE_CHUNK(CORBA_NVList, sizeof(struct CORBA_NVList_type));
+
+#undef ORBIT_DEFINE_CHUNK
diff -urN linux-2.4.1/net/korbit/orb/allocators.c linux-2.4.1-korbit/net/korbit/orb/allocators.c
--- linux-2.4.1/net/korbit/orb/allocators.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/allocators.c	Thu Feb  1 11:47:10 2001
@@ -0,0 +1,241 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* By Elliot Lee. Copyright (c) 1998 Red Hat Software */
+
+#include "orbit.h"
+
+#if 0
+#define CORBA_Object_release(x, y) ({ g_message(__FILE__ ":%d Releasing object %#x from %d", __LINE__, \
+x, ORBIT_ROOT_OBJECT(x)->refs); CORBA_Object_release(x, y); })
+#define CORBA_Object_duplicate(x, y) ({ g_message(__FILE__ ":%d Duping object %#x from %d", __LINE__, \
+x, ORBIT_ROOT_OBJECT(x)->refs); CORBA_Object_duplicate(x, y); })
+#endif
+
+/* The memory chunk stuff */
+
+#define ALLOCATOR_DEFINITION
+#include "allocator-defs.h"
+#undef ALLOCATOR_DEFINITION
+
+void
+ORBit_chunks_init(void)
+{
+#define ALLOCATOR_INITIALIZATION
+#include "allocator-defs.h"
+#undef ALLOCATOR_INTIALIZATION
+}
+
+gpointer
+ORBit_chunk_alloc(GMemChunk *chunk,
+		  PARAM_LOCK(chunk))
+{
+  gpointer retval;
+
+  GET_LOCK(chunk);
+  retval = g_mem_chunk_alloc(chunk);
+  RELEASE_LOCK(chunk);
+
+  return retval;
+}
+
+void
+ORBit_chunk_free(GMemChunk *chunk,
+		 PARAM_LOCK(chunk),
+		 gpointer mem)
+{
+  GET_LOCK(chunk);
+  g_mem_chunk_free(chunk, mem);
+  RELEASE_LOCK(chunk);
+}
+
+/* end memory chunk routines */
+
+/****************************************************************/
+
+/************* begin funky memory alloc/free system */
+
+/****** functions */
+
+gpointer ORBit_alloc(size_t block_size,
+		     ORBit_free_childvals freefunc,
+		     gpointer func_data)
+{
+	return ORBit_alloc_2(block_size, freefunc, func_data, 0);
+}
+
+gpointer
+ORBit_alloc_2(size_t block_size,
+	      ORBit_free_childvals freefunc,
+	      gpointer func_data,
+	      size_t before_size)
+{
+	ORBit_mem_info *block;
+
+	if(block_size == 0) return NULL;
+
+	block = (ORBit_mem_info *)((char *)
+		g_malloc(block_size + sizeof(ORBit_mem_info) + before_size)
+		+ before_size);
+
+#ifdef ORBIT_DEBUG
+	block->magic = 0xdeadbeef;
+#endif
+	block->free = freefunc;
+	block->func_data = func_data;
+
+	return MEMINFO_TO_PTR(block);
+}
+
+/*
+  ORBit_free
+  ----------
+
+  Frees a corba primitive type.
+
+  mem = pointer to the memory block. (must have a preceeding pointer to a meminfo block)
+
+  1)obtains a pointer to the preceeding meminfo structure
+  2)Uses the meminfo structure to find the number of elements in the memory block
+  3)iterates through the memory block, calling the free function for each item.
+  
+ */
+
+void
+ORBit_free(gpointer mem, CORBA_boolean free_strings)
+{
+	ORBit_mem_info *block;
+
+	if(!mem)
+		return;
+
+	block = PTR_TO_MEMINFO(mem);
+
+#ifdef ORBIT_DEBUG
+	g_assert(block->magic == 0xdeadbeef);
+#endif
+
+	if(block->free) {
+		int i;
+		gpointer x;
+		gpointer my_data;
+
+		if((gpointer)block->free == (gpointer)ORBit_free_via_TypeCode)
+			my_data = ((guchar *)block) - sizeof(CORBA_TypeCode);
+		else
+			my_data = NULL;
+
+#ifdef ORBIT_DEBUG
+		if(block->func_data == NULL)
+			g_warning("block with freefunc %p has no items", block->free);
+#endif
+
+		for(i = 0, x = mem; i < (gulong)block->func_data; i++)
+			x = block->free(x, my_data, free_strings);
+
+		if((gpointer)block->free == (gpointer)ORBit_free_via_TypeCode)
+			/* ((guchar *)block) -= sizeof(CORBA_TypeCode); */
+			block = (ORBit_mem_info *)
+				(((guchar *)block) - sizeof(CORBA_TypeCode));
+		g_free(block);
+	} else
+		g_free(block);
+}
+
+/******************************************************************/
+/* These aren't currently used... */
+
+gpointer
+ORBit_free_via_TypeCode(gpointer mem, gpointer tcp, gboolean free_strings)
+{
+	CORBA_TypeCode tc = *(CORBA_TypeCode *)tcp, subtc;
+	int i;
+	guchar *retval = NULL;
+
+	switch(tc->kind) {
+	case CORBA_tk_any:
+		{
+			CORBA_any *anyval = mem;
+			if(anyval->_release)
+				CORBA_free(anyval->_value);
+			retval = (guchar *)(anyval + 1);
+		}
+		break;
+	case CORBA_tk_TypeCode:
+	case CORBA_tk_objref:
+		{
+			CORBA_Object_release(*(CORBA_Object *)mem, NULL);
+
+			retval = (guchar *)mem + sizeof(CORBA_Object);
+		}
+		break;
+	case CORBA_tk_Principal:
+		{
+			CORBA_Principal *pval = mem;
+			if(pval->_release)
+				CORBA_free(pval->_buffer);
+			retval = (guchar *)(pval + 1);
+		}
+		break;
+	case CORBA_tk_except:
+	case CORBA_tk_struct:
+		mem = ALIGN_ADDRESS(mem, ORBit_find_alignment(tc));
+		for(i = 0; i < tc->sub_parts; i++) {
+			subtc = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)tc->subtypes[i], NULL);
+			mem = ORBit_free_via_TypeCode(mem, &subtc,
+						      free_strings);
+		}
+		retval = mem;
+		break;
+	case CORBA_tk_union:
+		subtc = (CORBA_TypeCode)CORBA_Object_duplicate(
+		  (CORBA_Object)ORBit_get_union_tag(tc, &mem, TRUE), NULL);
+		{
+		    int sz = 0;
+		    int al = 1;
+		    for(i = 0; i < tc->sub_parts; i++) {
+		        al = MAX(al, ORBit_find_alignment(tc->subtypes[i]));
+		        sz = MAX(sz, ORBit_gather_alloc_info(tc->subtypes[i]));
+		    }
+		    mem = ALIGN_ADDRESS(mem, al);
+		    ORBit_free_via_TypeCode(mem, &subtc, free_strings);
+		    /* the end of the body (subtc) may not be the
+		     * same as the end of the union */
+		    retval = mem + sz;
+		}
+		break;
+	case CORBA_tk_wstring:
+	case CORBA_tk_string:
+		if(free_strings)
+			CORBA_free(*(char **)mem);
+		retval = (guchar *)mem + sizeof(char *);
+		break;
+	case CORBA_tk_sequence:
+		{
+			CORBA_sequence_octet *pval = mem;
+			if(pval->_release)
+				CORBA_free(pval->_buffer);
+
+			retval = (guchar *)mem + sizeof(CORBA_sequence_octet);
+		}
+		break;
+	case CORBA_tk_array:
+		for(i = 0; i < tc->length; i++) {
+			subtc = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)tc->subtypes[0], NULL);
+			mem = ORBit_free_via_TypeCode(mem, &subtc,
+						      free_strings);
+		}
+		retval = mem;
+		break;
+	case CORBA_tk_alias:
+		subtc = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)tc->subtypes[0], NULL);
+		retval = ORBit_free_via_TypeCode(mem, &subtc, free_strings);
+		break;
+	default:
+		retval = ((guchar *)mem) + ORBit_gather_alloc_info(tc);
+		break;
+	}
+
+	CORBA_Object_release((CORBA_Object)tc, NULL);
+
+	return (gpointer)retval;
+}
diff -urN linux-2.4.1/net/korbit/orb/allocators.h linux-2.4.1-korbit/net/korbit/orb/allocators.h
--- linux-2.4.1/net/korbit/orb/allocators.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/allocators.h	Thu Feb  1 11:47:10 2001
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* By Elliot Lee. Copyright (c) 1998 Red Hat Software */
+
+#ifndef ALLOCATORS_H
+#define ALLOCATORS_H 1
+
+#include <orb/orbit.h>
+
+#include <orb/allocator-defs.h>
+
+#define ORBIT_CHUNK_ALLOC(typename) \
+ORBit_chunk_alloc(typename##_allocator, LOCK_NAME(typename##_allocator))
+
+#define ORBIT_CHUNK_FREE(typename, mem) \
+ORBit_chunk_free(typename##_allocator, LOCK_NAME(typename##_allocator), (mem))
+
+void ORBit_chunks_init(void);
+
+gpointer ORBit_chunk_alloc(GMemChunk *chunk,
+			   PARAM_LOCK(chunk_lock));
+
+void ORBit_chunk_free(GMemChunk *chunk,
+		      PARAM_LOCK(chunk_lock),
+		      gpointer mem);
+
+/* General memory allocation routines */
+
+#define PTR_TO_MEMINFO(x) (((ORBit_mem_info *)(x)) - 1)
+#define MEMINFO_TO_PTR(x) ((gpointer)((x) + 1))
+
+typedef gpointer (*ORBit_free_childvals)(gpointer mem,
+					 gpointer func_data,
+					 CORBA_boolean free_strings);
+
+typedef struct {
+#ifdef ORBIT_DEBUG
+	gulong magic;
+#endif
+	/* If this routine returns FALSE, it indicates that it already free'd
+	   the memory block itself */
+	ORBit_free_childvals free; /* function pointer to free function */
+	gpointer func_data;
+} ORBit_mem_info;
+
+gpointer ORBit_alloc(size_t block_size,
+		     ORBit_free_childvals freefunc,
+		     gpointer func_data);
+gpointer ORBit_alloc_2(size_t block_size,
+		       ORBit_free_childvals freefunc,
+		       gpointer func_data,
+		       size_t before_size);
+
+void ORBit_free(gpointer mem, CORBA_boolean free_strings);
+
+/* internal stuff */
+gpointer ORBit_free_via_TypeCode(gpointer mem,
+				 gpointer tcp,
+				 gboolean free_strings);
+
+#endif /* ALLOCATORS_H */
diff -urN linux-2.4.1/net/korbit/orb/cdr.c linux-2.4.1-korbit/net/korbit/orb/cdr.c
--- linux-2.4.1/net/korbit/orb/cdr.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/cdr.c	Thu Feb  1 11:47:10 2001
@@ -0,0 +1,643 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#include "config.h"
+#include "../IIOP/iiop-endianP.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+
+#include "orbit.h"
+
+#define CDR_GROW_AMOUNT 128
+
+static CORBA_boolean CDR_buffer_grow(CDR_Codec *codec, const unsigned int growth)
+{
+	unsigned int real_growth;
+	div_t divvy;
+
+	if(codec->release_buffer) {
+		divvy=div(growth, CDR_GROW_AMOUNT);
+		real_growth=CDR_GROW_AMOUNT * (divvy.quot+1);
+		
+		codec->buffer=(CORBA_octet *)g_realloc(codec->buffer,
+						       codec->buf_len
+						       +real_growth);
+	}
+
+	return CORBA_TRUE;
+}
+
+static void CDR_buffer_puts(CDR_Codec *codec, const void *data, const unsigned int len)
+{
+	if(codec->wptr+len > codec->buf_len) {
+		CORBA_boolean res=CDR_buffer_grow(codec, len);
+
+		if(res==CORBA_FALSE) {
+			/* just bail out for now */
+			g_assert(!"Malloc error");
+		}
+	}
+
+	memcpy(&codec->buffer[codec->wptr], data, len);
+	codec->wptr+=len;
+}
+
+CORBA_boolean CDR_buffer_gets(CDR_Codec *codec, void *dest, const unsigned int len)
+{
+	if(codec->rptr+len > codec->buf_len) {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Debug, "CDR_buffer_gets: attempt to read past end of buffer\n");
+		return(CORBA_FALSE);
+	}
+
+	memcpy(dest, &codec->buffer[codec->rptr], len);
+	codec->rptr+=len;
+
+	return(CORBA_TRUE);
+}
+
+static void CDR_buffer_put(CDR_Codec *codec, void *datum)
+{
+	if(codec->wptr+1 > codec->buf_len) {
+		CORBA_boolean res=CDR_buffer_grow(codec, 1);
+
+		if(res==CORBA_FALSE) {
+			/* just bail out for now */
+			g_assert(!"Malloc error");
+		}
+	}
+
+	codec->buffer[codec->wptr++]=*(unsigned char *)datum;
+}
+
+static CORBA_boolean CDR_buffer_get(CDR_Codec *codec, void *dest)
+{
+	if(codec->rptr+1 > codec->buf_len) {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Debug, "CDR_buffer_get: attempt to read past end of buffer\n");
+		return(CORBA_FALSE);
+	}
+
+	*(CORBA_octet *)dest=codec->buffer[codec->rptr++];
+	return(CORBA_TRUE);
+}
+
+#ifdef lame_slow_code
+static void CDR_buffer_put2(CDR_Codec *codec, void *datum)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(codec->readonly!=CORBA_TRUE);
+	g_assert(codec->wptr<=codec->buf_len);
+
+	align=((codec->wptr+1)&~1L);
+
+	if(align+2 > codec->buf_len) {
+		CORBA_boolean res=CDR_buffer_grow(codec, align+2-codec->wptr);
+
+		if(res==CORBA_FALSE) {
+			/* just bail out for now */
+			g_assert(!"Malloc error");
+		}
+	}
+
+	while(codec->wptr < align) {
+		codec->buffer[codec->wptr++]='\0';
+	}
+
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[0];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[1];
+}
+
+static CORBA_boolean CDR_buffer_get2(CDR_Codec *codec, void *dest)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(dest!=NULL);
+	g_assert(codec->rptr<=codec->buf_len);
+
+	align=((codec->rptr+1)&~1L);
+
+	if(align+2 > codec->buf_len) {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Debug, "CDR_buffer_get2: attempt to read past end of buffer\n");
+		return(CORBA_FALSE);
+	}
+
+	codec->rptr=align;
+
+	((CORBA_octet *)dest)[0]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[1]=codec->buffer[codec->rptr++];
+
+	return(CORBA_TRUE);
+}
+
+static void CDR_buffer_put4(CDR_Codec *codec, void *datum)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(codec->readonly!=CORBA_TRUE);
+	g_assert(codec->wptr<=codec->buf_len);
+
+	align=((codec->wptr+3)&~3L);
+
+	if(align+4 > codec->buf_len) {
+		CORBA_boolean res=CDR_buffer_grow(codec, align+4-codec->wptr);
+
+		if(res==CORBA_FALSE) {
+			/* just bail out for now */
+			g_assert(!"Malloc error");
+		}
+	}
+
+	while(codec->wptr < align) {
+		codec->buffer[codec->wptr++]='\0';
+	}
+
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[0];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[1];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[2];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[3];
+}
+
+static CORBA_boolean CDR_buffer_get4(CDR_Codec *codec, void *dest)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(dest!=NULL);
+	g_assert(codec->rptr<=codec->buf_len);
+
+	align=((codec->rptr+3)&~3L);
+
+	if(align+4 > codec->buf_len) {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Debug, "CDR_buffer_get4: attempt to read past end of buffer\n");
+		return(CORBA_FALSE);
+	}
+
+	codec->rptr=align;
+
+	((CORBA_octet *)dest)[0]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[1]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[2]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[3]=codec->buffer[codec->rptr++];
+
+	return(CORBA_TRUE);
+}
+
+static void CDR_buffer_put8(CDR_Codec *codec, void *datum)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(codec->readonly!=CORBA_TRUE);
+	g_assert(codec->wptr<=codec->buf_len);
+
+	align=((codec->wptr+7)&~7L);
+
+	if(align+8 > codec->buf_len) {
+		CORBA_boolean res=CDR_buffer_grow(codec, align+8-codec->wptr);
+
+		if(res==CORBA_FALSE) {
+			/* just bail out for now */
+			g_assert(!"Malloc error");
+		}
+	}
+
+	while(codec->wptr < align) {
+		codec->buffer[codec->wptr++]='\0';
+	}
+
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[0];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[1];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[2];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[3];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[4];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[5];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[6];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[7];
+}
+
+#if 0
+static CORBA_boolean CDR_buffer_get8(CDR_Codec *codec, void *dest)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(dest!=NULL);
+	g_assert(codec->rptr<=codec->buf_len);
+
+	align=((codec->rptr+7)&~7L);
+
+	if(align+8 > codec->buf_len) {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Debug, "CDR_buffer_get8: attempt to read past end of buffer\n");
+		return(CORBA_FALSE);
+	}
+
+	codec->rptr=align;
+
+	((CORBA_octet *)dest)[0]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[1]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[2]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[3]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[4]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[5]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[6]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[7]=codec->buffer[codec->rptr++];
+
+	return(CORBA_TRUE);
+}
+#endif
+
+static void CDR_buffer_put16(CDR_Codec *codec, void *datum)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(codec->readonly!=CORBA_TRUE);
+	g_assert(codec->wptr<=codec->buf_len);
+
+	align=((codec->wptr+15)&~15L);
+
+	if(align+16 > codec->buf_len) {
+		CORBA_boolean res=CDR_buffer_grow(codec, align+16-codec->wptr);
+
+		if(res==CORBA_FALSE) {
+			/* just bail out for now */
+			g_assert(!"Malloc error");
+		}
+	}
+
+	while(codec->wptr < align) {
+		codec->buffer[codec->wptr++]='\0';
+	}
+
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[0];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[1];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[2];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[3];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[4];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[5];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[6];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[7];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[8];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[9];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[10];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[11];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[12];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[13];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[14];
+	codec->buffer[codec->wptr++]=((CORBA_octet *)datum)[15];
+}
+
+#if 0
+static CORBA_boolean CDR_buffer_get16(CDR_Codec *codec, void *dest)
+{
+	unsigned long align;
+
+	g_assert(codec!=NULL);
+	g_assert(dest!=NULL);
+	g_assert(codec->rptr<=codec->buf_len);
+
+	align=((codec->rptr+15)&~15L);
+
+	if(align+16 > codec->buf_len) {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Debug, "CDR_buffer_get16: attempt to read past end of buffer\n");
+		return(CORBA_FALSE);
+	}
+
+	codec->rptr=align;
+
+	((CORBA_octet *)dest)[0]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[1]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[2]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[3]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[4]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[5]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[6]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[7]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[8]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[9]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[10]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[11]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[12]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[13]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[14]=codec->buffer[codec->rptr++];
+	((CORBA_octet *)dest)[15]=codec->buffer[codec->rptr++];
+
+	return(CORBA_TRUE);
+}
+#endif
+#endif /* lame_slow_code */
+
+#define CDR_buffer_put2(codec, datum) CDR_buffer_putn(codec, datum, 2)
+#define CDR_buffer_put4(codec, datum) CDR_buffer_putn(codec, datum, 4)
+#define CDR_buffer_put8(codec, datum) CDR_buffer_putn(codec, datum, 8)
+#define CDR_buffer_put16(codec, datum) CDR_buffer_putn(codec, datum, 16)
+#define CDR_buffer_get2(codec, dest) CDR_buffer_getn(codec, dest, 2)
+#define CDR_buffer_get4(codec, dest) CDR_buffer_getn(codec, dest, 4)
+#define CDR_buffer_get8(codec, dest) CDR_buffer_getn(codec, dest, 8)
+#define CDR_buffer_get16(codec, dest) CDR_buffer_getn(codec, dest, 16)
+
+static CORBA_boolean
+CDR_buffer_getn(CDR_Codec *codec, void *dest, int bsize)
+{
+	codec->rptr = (unsigned long)ALIGN_ADDRESS(codec->rptr, bsize);
+	if(codec->host_endian==codec->data_endian)
+		memcpy(dest, codec->buffer + codec->rptr, bsize);
+	else
+		iiop_byteswap(dest, codec->buffer + codec->rptr, bsize);
+	codec->rptr += bsize;
+
+	return CORBA_TRUE;
+}
+
+static CORBA_boolean
+CDR_buffer_putn(CDR_Codec *codec, void *datum, int bsize)
+{
+	codec->wptr = (unsigned long)ALIGN_ADDRESS(codec->wptr, bsize);
+	if(codec->host_endian==codec->data_endian)
+		memcpy(codec->buffer + codec->wptr, datum, bsize);
+	else
+		iiop_byteswap(codec->buffer + codec->wptr, datum, bsize);
+	codec->wptr += bsize;
+
+	return CORBA_TRUE;
+}
+
+#define CDR_swap2(d,s) iiop_byteswap((d), (s), 2)
+#define CDR_swap4(d,s) iiop_byteswap((d), (s), 4)
+#define CDR_swap8(d,s) iiop_byteswap((d), (s), 8)
+#define CDR_swap16(d,s) iiop_byteswap((d), (s), 16)
+
+#ifdef lame_slow_code
+static void CDR_swap2(void *d, void *s)
+{
+	((CORBA_octet *)d)[0]=((CORBA_octet *)s)[1];
+	((CORBA_octet *)d)[1]=((CORBA_octet *)s)[0];
+}
+
+static void CDR_swap4(void *d, void *s)
+{
+	((CORBA_octet *)d)[0]=((CORBA_octet *)s)[3];
+	((CORBA_octet *)d)[1]=((CORBA_octet *)s)[2];
+	((CORBA_octet *)d)[2]=((CORBA_octet *)s)[1];
+	((CORBA_octet *)d)[3]=((CORBA_octet *)s)[0];
+}
+
+static void CDR_swap8(void *d, void *s)
+{
+	((CORBA_octet *)d)[0]=((CORBA_octet *)s)[7];
+	((CORBA_octet *)d)[1]=((CORBA_octet *)s)[6];
+	((CORBA_octet *)d)[2]=((CORBA_octet *)s)[5];
+	((CORBA_octet *)d)[3]=((CORBA_octet *)s)[4];
+	((CORBA_octet *)d)[4]=((CORBA_octet *)s)[3];
+	((CORBA_octet *)d)[5]=((CORBA_octet *)s)[2];
+	((CORBA_octet *)d)[6]=((CORBA_octet *)s)[1];
+	((CORBA_octet *)d)[7]=((CORBA_octet *)s)[0];
+}
+
+static void CDR_swap16(void *d, void *s)
+{
+	((CORBA_octet *)d)[0]=((CORBA_octet *)s)[15];
+	((CORBA_octet *)d)[1]=((CORBA_octet *)s)[14];
+	((CORBA_octet *)d)[2]=((CORBA_octet *)s)[13];
+	((CORBA_octet *)d)[3]=((CORBA_octet *)s)[12];
+	((CORBA_octet *)d)[4]=((CORBA_octet *)s)[11];
+	((CORBA_octet *)d)[5]=((CORBA_octet *)s)[10];
+	((CORBA_octet *)d)[6]=((CORBA_octet *)s)[9];
+	((CORBA_octet *)d)[7]=((CORBA_octet *)s)[8];
+	((CORBA_octet *)d)[8]=((CORBA_octet *)s)[7];
+	((CORBA_octet *)d)[9]=((CORBA_octet *)s)[6];
+	((CORBA_octet *)d)[10]=((CORBA_octet *)s)[5];
+	((CORBA_octet *)d)[11]=((CORBA_octet *)s)[4];
+	((CORBA_octet *)d)[12]=((CORBA_octet *)s)[3];
+	((CORBA_octet *)d)[13]=((CORBA_octet *)s)[2];
+	((CORBA_octet *)d)[14]=((CORBA_octet *)s)[1];
+	((CORBA_octet *)d)[15]=((CORBA_octet *)s)[0];
+}
+#endif
+
+
+void CDR_put_short(CDR_Codec *codec, CORBA_short s)
+{
+	CDR_buffer_put2(codec, &s);
+}
+
+CORBA_boolean CDR_get_short(CDR_Codec *codec, CORBA_short *s)
+{
+	return CDR_buffer_get2(codec, s);
+}
+
+void CDR_put_ushort(CDR_Codec *codec, CORBA_unsigned_short us)
+{
+	CDR_buffer_put2(codec, &us);
+}
+
+CORBA_boolean CDR_get_ushort(CDR_Codec *codec, CORBA_unsigned_short *us)
+{
+	return CDR_buffer_get2(codec, us);
+}
+
+void CDR_put_long(CDR_Codec *codec, CORBA_long l)
+{
+	CDR_buffer_put4(codec, &l);
+}
+
+CORBA_boolean CDR_get_long(CDR_Codec *codec, CORBA_long *l)
+{
+	return CDR_buffer_get4(codec, l);
+}
+
+void CDR_put_ulong(CDR_Codec *codec, CORBA_unsigned_long ul)
+{
+	CDR_buffer_put4(codec, &ul);
+}
+
+CORBA_boolean CDR_get_ulong(CDR_Codec *codec, CORBA_unsigned_long *ul)
+{
+	return CDR_buffer_get4(codec, ul);
+}
+
+#ifdef HAVE_CORBA_LONG_LONG
+CORBA_boolean CDR_get_long_long(CDR_Codec *codec, CORBA_long_long *ul)
+{
+	return CDR_buffer_get8(codec, ul);
+}
+
+void CDR_put_long_long(CDR_Codec *codec, CORBA_long_long ll)
+{
+	CDR_buffer_put8(codec, &ll);
+}
+
+void CDR_put_ulong_long(CDR_Codec *codec, CORBA_unsigned_long_long ll)
+{
+	CDR_buffer_put8(codec, &ll);
+}
+
+CORBA_boolean CDR_get_ulong_long(CDR_Codec *codec, CORBA_unsigned_long_long *ull)
+{
+	return CDR_buffer_get8(codec, ull);
+}
+#endif
+
+void CDR_put_float(CDR_Codec *codec, CORBA_float f)
+{
+	CDR_buffer_put4(codec, &f);
+}
+
+void CDR_put_double(CDR_Codec *codec, CORBA_double d)
+{
+	CDR_buffer_put8(codec, &d);
+}
+
+void CDR_put_long_double(CDR_Codec *codec, CORBA_long_double ld)
+{
+	CDR_buffer_put16(codec, &ld);
+}
+
+void CDR_put_octet(CDR_Codec *codec, CORBA_octet datum)
+{
+	CDR_buffer_put(codec, &datum);
+}
+
+CORBA_boolean CDR_get_octet(CDR_Codec *codec, CORBA_octet *datum)
+{
+	return(CDR_buffer_get(codec, datum));
+}
+
+void CDR_put_octets(CDR_Codec *codec, void *data, unsigned long len)
+{
+	CDR_buffer_puts(codec, data, len);
+}
+
+void CDR_put_char(CDR_Codec *codec, CORBA_char c)
+{
+	CDR_buffer_put(codec, &c);
+}
+
+CORBA_boolean CDR_get_char(CDR_Codec *codec, CORBA_char *c)
+{
+	return CDR_buffer_get(codec, c);
+}
+
+void CDR_put_boolean(CDR_Codec *codec, CORBA_boolean datum)
+{
+	datum = datum&&1;
+	CDR_buffer_put(codec, &datum);
+}
+
+CORBA_boolean CDR_get_boolean(CDR_Codec *codec, CORBA_boolean *b)
+{
+	return CDR_buffer_get(codec, b);
+}
+
+void CDR_put_string(CDR_Codec *codec, const char *str)
+{
+	unsigned int len;
+
+	len=strlen(str)+1;
+
+	CDR_put_ulong(codec, len);
+	CDR_buffer_puts(codec, str, len);
+}
+
+CORBA_boolean CDR_get_string_static(CDR_Codec *codec,
+				    CORBA_char **str)
+{
+	CORBA_unsigned_long len;
+
+	if(CDR_get_ulong(codec, &len)==CORBA_FALSE)
+		return CORBA_FALSE;
+
+	if((codec->rptr + len) > codec->buf_len)
+		return CORBA_FALSE;
+
+	*str = ((CORBA_char *)codec->buffer) + codec->rptr;
+
+	codec->rptr += len;
+
+	return CORBA_TRUE;
+}
+
+CORBA_boolean CDR_get_string(CDR_Codec *codec, CORBA_char **str)
+{
+	CORBA_unsigned_long len;
+
+	if(CDR_get_ulong(codec, &len)==CORBA_FALSE)
+		return(CORBA_FALSE);
+
+	if(len==0)
+		return(CORBA_FALSE);
+
+	*str=g_new(CORBA_char, len);
+
+	if(CDR_buffer_gets(codec, *str, len)==CORBA_FALSE) {
+		g_free(*str);
+		return(CORBA_FALSE);
+	}
+
+	if((*str)[len-1]!='\0') {
+		ORBit_Trace(TraceMod_CDR, TraceLevel_Notice, "CDR_get_string: string was not NULL-terminated, terminating it now\n");
+		(*str)[len-1]='\0';
+	}
+
+	return(CORBA_TRUE);
+}
+
+CORBA_boolean CDR_get_seq_begin(CDR_Codec *codec, CORBA_unsigned_long *ul)
+{
+	return(CDR_get_ulong(codec, ul));
+}
+
+CDR_Codec *CDR_codec_init_static(CDR_Codec *codec)
+{
+	memset(codec, 0, sizeof(CDR_Codec));
+
+	codec->host_endian = FLAG_ENDIANNESS;
+
+	return codec;
+}
+
+CDR_Codec *CDR_codec_init(void)
+{
+	CDR_Codec *new;
+
+	new=g_new0(CDR_Codec, 1);
+	CDR_codec_init_static(new);
+	new->release_buffer = CORBA_TRUE;
+
+	return(new);
+}
+
+void CDR_codec_free(CDR_Codec *codec)
+{
+	if(codec->release_buffer)
+		g_free(codec->buffer);
+
+	g_free(codec);
+}
diff -urN linux-2.4.1/net/korbit/orb/cdr.h linux-2.4.1-korbit/net/korbit/orb/cdr.h
--- linux-2.4.1/net/korbit/orb/cdr.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/cdr.h	Thu Feb  1 16:22:12 2001
@@ -0,0 +1,83 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CDR_H_
+#define _ORBIT_CDR_H_
+
+#include "orbit_types.h"
+
+typedef enum {
+	BigEndian=0,
+	LittleEndian=1
+} CDR_Endianness;
+
+typedef struct {
+	CDR_Endianness host_endian;
+	CDR_Endianness data_endian;
+	CORBA_octet *buffer;
+	unsigned int buf_len;
+	unsigned int wptr, rptr;
+	CORBA_boolean readonly;
+	CORBA_boolean release_buffer;
+} CDR_Codec;
+
+#define HEXDIGIT(c) (isdigit((guchar)(c))?(c)-'0':tolower((guchar)(c))-'a'+10)
+#define HEXOCTET(a,b) ((HEXDIGIT((a)) << 4) | HEXDIGIT((b)))
+
+extern CDR_Codec *CDR_codec_init(void);
+extern CDR_Codec *CDR_codec_init_static(CDR_Codec *codec);
+extern void CDR_codec_free(CDR_Codec *);
+
+extern void CDR_put_short(CDR_Codec *codec, CORBA_short s);
+extern void CDR_put_ushort(CDR_Codec *codec, CORBA_unsigned_short us);
+extern void CDR_put_long(CDR_Codec *codec, CORBA_long l);
+extern void CDR_put_ulong(CDR_Codec *codec, CORBA_unsigned_long ul);
+#ifdef HAVE_CORBA_LONG_LONG
+extern void CDR_put_long_long(CDR_Codec *codec, CORBA_long_long ll);
+extern void CDR_put_ulong_long(CDR_Codec *codec, CORBA_unsigned_long_long ull);
+extern CORBA_boolean CDR_get_ulong_long(CDR_Codec *codec, CORBA_unsigned_long_long *ul);
+extern CORBA_boolean CDR_get_long_long(CDR_Codec *codec, CORBA_long_long *ul);
+#endif
+extern void CDR_put_float(CDR_Codec *codec, CORBA_float f);
+extern void CDR_put_double(CDR_Codec *codec, CORBA_double d);
+extern void CDR_put_long_double(CDR_Codec *codec, CORBA_long_double ld);
+extern void CDR_put_octet(CDR_Codec *codec, CORBA_octet datum);
+extern void CDR_put_octets(CDR_Codec *codec, void *data, unsigned long len);
+extern void CDR_put_char(CDR_Codec *codec, CORBA_char c);
+extern void CDR_put_boolean(CDR_Codec *codec, CORBA_boolean datum);
+extern void CDR_put_string(CDR_Codec *codec, const char *str);
+extern CORBA_boolean CDR_buffer_gets(CDR_Codec *codec, void *dest, const unsigned int len);
+extern CORBA_boolean CDR_get_short(CDR_Codec *codec, CORBA_short *us);
+extern CORBA_boolean CDR_get_ushort(CDR_Codec *codec, CORBA_unsigned_short *us);
+extern CORBA_boolean CDR_get_long(CDR_Codec *codec, CORBA_long *l);
+extern CORBA_boolean CDR_get_ulong(CDR_Codec *codec, CORBA_unsigned_long *ul);
+extern CORBA_boolean CDR_get_octet(CDR_Codec *codec, CORBA_octet *datum);
+extern CORBA_boolean CDR_get_boolean(CDR_Codec *codec, CORBA_boolean *b);
+extern CORBA_boolean CDR_get_char(CDR_Codec *codec, CORBA_char *c);
+extern CORBA_boolean CDR_get_string(CDR_Codec *codec, CORBA_char **str);
+extern CORBA_boolean CDR_get_string_static(CDR_Codec *codec, CORBA_char **str);
+extern CORBA_boolean CDR_get_seq_begin(CDR_Codec *codec, CORBA_unsigned_long *ul);
+
+#endif /* !_ORBIT_CDR_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_any.c linux-2.4.1-korbit/net/korbit/orb/corba_any.c
--- linux-2.4.1/net/korbit/orb/corba_any.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_any.c	Thu Feb  1 11:47:10 2001
@@ -0,0 +1,914 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+#include <config.h>
+#include <IIOP/IIOP.h>
+#include "orbit.h"
+
+#if 0
+#define CORBA_Object_release(x, y) ({ g_message(__FILE__ ":%d Releasing object %#x from %d", __LINE__, \
+x, ORBIT_ROOT_OBJECT(x)->refs); CORBA_Object_release(x, y); })
+#define CORBA_Object_duplicate(x, y) ({ g_message(__FILE__ ":%d Duping object %#x from %d", __LINE__, \
+x, ORBIT_ROOT_OBJECT(x)->refs); CORBA_Object_duplicate(x, y); })
+#endif
+
+gint
+ORBit_find_alignment(CORBA_TypeCode tc)
+{
+    gint retval = 1;
+    int i;
+
+    switch(tc->kind) {
+    case CORBA_tk_union:
+	retval = MAX(retval, ORBit_find_alignment(tc->discriminator));
+    case CORBA_tk_except:
+    case CORBA_tk_struct:
+#if ALIGNOF_CORBA_STRUCT > 1
+	retval = MAX(retval, ALIGNOF_CORBA_STRUCT);
+#endif
+	for(i = 0; i < tc->sub_parts; i++)
+	    retval = MAX(retval, ORBit_find_alignment(tc->subtypes[i]));
+	return retval;
+    case CORBA_tk_ulong:
+    case CORBA_tk_long:
+    case CORBA_tk_enum:
+	return ALIGNOF_CORBA_LONG;
+    case CORBA_tk_ushort:
+    case CORBA_tk_short:
+    case CORBA_tk_wchar:
+	return ALIGNOF_CORBA_SHORT;
+    case CORBA_tk_longlong:
+    case CORBA_tk_ulonglong:
+	return ALIGNOF_CORBA_LONG_LONG;
+    case CORBA_tk_longdouble:
+	return ALIGNOF_CORBA_LONG_DOUBLE;
+    case CORBA_tk_float:
+	return ALIGNOF_CORBA_FLOAT;
+    case CORBA_tk_double:
+	return ALIGNOF_CORBA_DOUBLE;
+    case CORBA_tk_boolean:
+    case CORBA_tk_char:
+    case CORBA_tk_octet:
+	return ALIGNOF_CORBA_CHAR;
+    case CORBA_tk_string:
+    case CORBA_tk_wstring:
+    case CORBA_tk_TypeCode:
+    case CORBA_tk_objref:
+	return ALIGNOF_CORBA_POINTER;
+    case CORBA_tk_sequence:
+    case CORBA_tk_any:
+	return MAX(MAX(ALIGNOF_CORBA_LONG, ALIGNOF_CORBA_STRUCT), ALIGNOF_CORBA_POINTER);
+    case CORBA_tk_array:
+    case CORBA_tk_alias:
+	return ORBit_find_alignment(tc->subtypes[0]);
+    case CORBA_tk_fixed:
+	return MAX(ALIGNOF_CORBA_SHORT, ALIGNOF_CORBA_STRUCT);
+    default:
+	return 1;
+    }
+}
+
+static void
+ORBit_marshal_value(GIOPSendBuffer *buf,
+		    gpointer *val,
+		    CORBA_TypeCode tc,
+		    ORBit_marshal_value_info *mi)
+{
+    CORBA_unsigned_long i, ulval;
+    gpointer subval;
+    ORBit_marshal_value_info submi;
+
+#if 0
+    g_message("Marshalling a %d value from %#x to offset %d",
+	      tc->kind, (gulong)*val,
+	      GIOP_MESSAGE_BUFFER(buf)->message_header.message_size);
+#endif
+
+    switch(tc->kind) {
+    case CORBA_tk_wchar:
+    case CORBA_tk_ushort:
+    case CORBA_tk_short:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_SHORT);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_short));
+	*val = ((guchar *)*val) + sizeof(CORBA_short);
+	break;
+    case CORBA_tk_enum:
+    case CORBA_tk_long:
+    case CORBA_tk_ulong:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_long));
+	*val = ((guchar *)*val) + sizeof(CORBA_long);
+	break;
+    case CORBA_tk_float:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_FLOAT);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_float));
+	*val = ((guchar *)*val) + sizeof(CORBA_float);
+	break;
+    case CORBA_tk_double:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_DOUBLE);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_double));
+	*val = ((guchar *)*val) + sizeof(CORBA_double);
+	break;
+    case CORBA_tk_boolean:
+    case CORBA_tk_char:
+    case CORBA_tk_octet:
+	giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_octet));
+	*val = ((guchar *)*val) + sizeof(CORBA_octet);
+	break;
+    case CORBA_tk_any:
+	*val = ALIGN_ADDRESS(*val, MAX(ALIGNOF_CORBA_STRUCT, ALIGNOF_CORBA_POINTER));
+	ORBit_marshal_any(buf, *val);
+	*val = ((guchar *)*val) + sizeof(CORBA_any);
+	break;
+    case CORBA_tk_TypeCode:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	ORBit_encode_CORBA_TypeCode(*val, buf);
+	*val = ((guchar *)*val) + sizeof(CORBA_TypeCode);
+	break;
+    case CORBA_tk_Principal:
+	*val = ALIGN_ADDRESS(*val,
+			     MAX(MAX(ALIGNOF_CORBA_LONG, ALIGNOF_CORBA_STRUCT),
+				 ALIGNOF_CORBA_POINTER));
+
+	ulval = *(CORBA_unsigned_long *)(*val);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_unsigned_long));
+
+	giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(buf),
+				       *(char**)((char *)*val+sizeof(CORBA_unsigned_long)),
+				       ulval);
+	*val = ((guchar *)*val) + sizeof(CORBA_Principal);
+	break;
+    case CORBA_tk_objref:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	ORBit_marshal_object(buf, *val);
+	*val = ((guchar *)*val) + sizeof(CORBA_Object);
+	break;
+    case CORBA_tk_except:
+    case CORBA_tk_struct:
+	*val = ALIGN_ADDRESS(*val, ORBit_find_alignment(tc));
+	for(i = 0; i < tc->sub_parts; i++) {
+	    ORBit_marshal_value(buf, val, tc->subtypes[i], mi);
+	}
+	break;
+    case CORBA_tk_union:
+	/* Basic algorithm:
+	   marshal the discriminator
+	   find out which value we want to use */
+	{
+	    CORBA_TypeCode utc;
+
+	    *val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_STRUCT);
+
+	    utc = ORBit_get_union_tag(tc, val, TRUE);
+
+	    *val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_STRUCT);
+
+	    ORBit_marshal_value(buf, val, tc->discriminator, mi);
+	    *val = ALIGN_ADDRESS(*val, ORBit_find_alignment(tc));
+	    ORBit_marshal_value(buf, val, utc, mi);
+	}
+	break;
+    case CORBA_tk_wstring:
+	ulval = strlen(*(char **)*val) + 1;
+
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	giop_send_buffer_append_mem_indirect_a(buf,
+					       &ulval,
+					       sizeof(CORBA_unsigned_long));
+	giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(buf), *(char **)*val, ulval);
+	
+	*val = ((guchar *)*val) + sizeof(char *);
+	break;
+    case CORBA_tk_string:
+	ulval = strlen(*(char **)*val) + 1;
+	
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+
+	giop_send_buffer_append_mem_indirect_a(buf,
+					       &ulval,
+					       sizeof(CORBA_unsigned_long));
+	giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(buf), *(char **)*val, ulval);
+	
+	*val = ((guchar *)*val) + sizeof(char *);
+	break;
+    case CORBA_tk_sequence:
+	{
+	    CORBA_sequence_octet *sval = *val;
+
+	    *val = ALIGN_ADDRESS(*val,
+				 MAX(MAX(ALIGNOF_CORBA_LONG, ALIGNOF_CORBA_STRUCT), ALIGNOF_CORBA_POINTER));
+
+	    giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf),
+					     &sval->_length,
+					     sizeof(sval->_length));
+
+	    subval = sval->_buffer;
+
+	    for(i = 0; i < sval->_length; i++)
+		ORBit_marshal_value(buf, &subval, tc->subtypes[0], mi);
+	    
+	    *val = ((guchar *)*val) + sizeof(CORBA_sequence_octet);
+	}
+	break;
+    case CORBA_tk_array:
+	submi.alias_element_type = tc->subtypes[0];
+	for(i = 0; i < tc->length; i++) {
+	    ORBit_marshal_value(buf, val, submi.alias_element_type, &submi);
+	    *val = ALIGN_ADDRESS(*val, ORBit_find_alignment(tc->subtypes[0]));
+	}
+	break;
+    case CORBA_tk_alias:
+	submi.alias_element_type = tc->subtypes[0];
+	ORBit_marshal_value(buf, val, submi.alias_element_type, &submi);
+	break;
+    case CORBA_tk_longlong:
+    case CORBA_tk_ulonglong:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG_LONG);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_long_long));
+	return /* *val + sizeof(CORBA_long_long)*/;
+	break;
+    case CORBA_tk_longdouble:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG_DOUBLE);
+	giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), *val, sizeof(CORBA_long_double));
+	return /* *val + sizeof(CORBA_long_double)*/;
+	break;
+    case CORBA_tk_fixed:
+	/* XXX todo */
+	g_error("CORBA_fixed NYI");
+	
+	break;
+    case CORBA_tk_null:
+    case CORBA_tk_void:
+	break;
+    default:
+	g_error("Can't encode unknown type %d", tc->kind);
+    }
+}
+
+static glong ORBit_get_union_switch(CORBA_TypeCode tc, gpointer *val, gboolean update)
+{
+#ifdef __KORBIT__
+    glong retval = 0;
+#else
+    glong retval;
+#endif
+
+    switch(tc->kind) {
+    case CORBA_tk_ulong:
+    case CORBA_tk_long:
+    case CORBA_tk_enum:
+	retval = *(CORBA_long *)*val;
+	if(update) *val += sizeof(CORBA_long);
+	break;
+    case CORBA_tk_ushort:
+    case CORBA_tk_short:
+	retval = *(CORBA_short *)*val;
+	if(update) *val += sizeof(CORBA_short);
+	break;
+    case CORBA_tk_char:
+    case CORBA_tk_boolean:
+    case CORBA_tk_octet:
+	retval = *(CORBA_octet *)*val;
+	if(update) *val += sizeof(CORBA_char);
+	break;
+    case CORBA_tk_alias:
+	return ORBit_get_union_switch(tc->subtypes[0], val, update);
+	break;
+    default:
+	g_error("Wow, some nut has passed us a weird type[%d] as a union discriminator!", tc->kind);
+    }
+
+    return retval;
+}
+
+/* This function (and the one above it) exist for the
+   sole purpose of finding out which CORBA_TypeCode a union discriminator value
+   indicates.
+
+   If {update} is TRUE, {*val} will be advanced by the native size
+   of the descriminator type.
+
+   Hairy stuff.
+*/
+CORBA_TypeCode
+ORBit_get_union_tag(CORBA_TypeCode union_tc, gpointer *val, gboolean update)
+{
+    glong discrim_val, case_val;
+    int i;
+    CORBA_TypeCode retval = CORBA_OBJECT_NIL;
+
+    discrim_val = ORBit_get_union_switch(union_tc->discriminator, val, update);
+
+    for(i = 0; i < union_tc->sub_parts; i++) {
+	if(i == union_tc->default_index)
+	    continue;
+
+	case_val = ORBit_get_union_switch(union_tc->sublabels[i]._type,
+					  &union_tc->sublabels[i]._value, FALSE);
+	if(case_val == discrim_val) {
+	    retval = union_tc->subtypes[i];
+	    break;
+	}
+    }
+
+    if(retval)
+	return retval;
+    else if(union_tc->default_index >= 0)
+	return union_tc->subtypes[union_tc->default_index];
+    else {
+	return TC_null;
+    }
+}
+
+void
+ORBit_marshal_arg(GIOPSendBuffer *buf,
+		  gpointer val,
+		  CORBA_TypeCode tc)
+{
+    ORBit_marshal_value_info mi;
+
+    ORBit_marshal_value(buf, &val, tc, &mi);
+}
+
+
+void
+ORBit_marshal_any(GIOPSendBuffer *buf, const CORBA_any *val)
+{
+    ORBit_marshal_value_info mi;
+
+    gpointer mval = val->_value;
+
+    ORBit_encode_CORBA_TypeCode(val->_type, buf);
+
+    ORBit_marshal_value(buf, &mval, val->_type, &mi);
+}
+
+size_t
+ORBit_gather_alloc_info(CORBA_TypeCode tc)
+{
+    int i, n, align=1, prevalign, sum, prev;
+    size_t block_size;
+
+    switch(tc->kind) {
+    case CORBA_tk_long:
+    case CORBA_tk_ulong:
+    case CORBA_tk_enum:
+	return sizeof(CORBA_long);
+	break;
+    case CORBA_tk_short:
+    case CORBA_tk_ushort:
+	return sizeof(CORBA_short);
+	break;
+    case CORBA_tk_float:
+	return sizeof(CORBA_float);
+	break;
+    case CORBA_tk_double:
+	return sizeof(CORBA_double);
+	break;
+    case CORBA_tk_boolean:
+    case CORBA_tk_char:
+    case CORBA_tk_octet:
+	return sizeof(CORBA_octet);
+	break;
+    case CORBA_tk_any:
+	return sizeof(CORBA_any);
+	break;
+    case CORBA_tk_TypeCode:
+	return sizeof(CORBA_TypeCode);
+	break;
+    case CORBA_tk_Principal:
+	return sizeof(CORBA_Principal);
+	break;
+    case CORBA_tk_objref:
+	return sizeof(CORBA_Object);
+	break;
+    case CORBA_tk_except:
+    case CORBA_tk_struct:
+	sum = 0;
+	for(i = 0; i < tc->sub_parts; i++) {
+	    sum = GPOINTER_TO_INT(ALIGN_ADDRESS(sum, ORBit_find_alignment(tc->subtypes[i])));
+	    sum += ORBit_gather_alloc_info(tc->subtypes[i]);
+	}
+	sum = GPOINTER_TO_INT(ALIGN_ADDRESS(sum, ORBit_find_alignment(tc)));
+	return sum;
+	break;
+    case CORBA_tk_union:
+	sum = ORBit_gather_alloc_info(tc->discriminator);
+	n = -1;
+	align = 1;
+	for(prev = prevalign = i = 0; i < tc->sub_parts; i++) {
+	    prevalign = align;
+	    align = ORBit_find_alignment(tc->subtypes[i]);
+	    if(align > prevalign)
+		n = i;
+
+	    prev = MAX(prev, ORBit_gather_alloc_info(tc->subtypes[i]));
+	}
+	if(n >= 0)
+	    sum = GPOINTER_TO_INT(ALIGN_ADDRESS(sum, ORBit_find_alignment(tc->subtypes[n])));
+	sum += prev;
+	sum = GPOINTER_TO_INT(ALIGN_ADDRESS(sum, ORBit_find_alignment(tc)));
+	return sum;
+ 	break;
+    case CORBA_tk_wstring:
+    case CORBA_tk_string:
+	return sizeof(char *);
+	break;
+    case CORBA_tk_sequence:
+	return sizeof(CORBA_sequence_octet);
+	break;
+    case CORBA_tk_array:
+	block_size = ORBit_gather_alloc_info(tc->subtypes[0]);
+	return block_size * tc->length;
+	break;
+    case CORBA_tk_alias:
+	return ORBit_gather_alloc_info(tc->subtypes[0]);
+    case CORBA_tk_longlong:
+    case CORBA_tk_ulonglong:
+	return sizeof(CORBA_long_long);
+    case CORBA_tk_longdouble:
+	return sizeof(CORBA_long_double);
+    case CORBA_tk_wchar:
+	return sizeof(CORBA_wchar);
+    case CORBA_tk_fixed:
+	return sizeof(CORBA_fixed_d_s);
+    default:
+	return 0;
+    }
+}
+
+/* to allocate a block, we need to know of any important data
+   contained in it.
+*/
+static gpointer
+ORBit_demarshal_allocate_mem(CORBA_TypeCode tc, gint nelements)
+{
+    size_t block_size;
+    gpointer retval = NULL;
+
+    if(!nelements) return retval;
+
+    block_size = ORBit_gather_alloc_info(tc);
+
+    if(block_size) {
+	retval = ORBit_alloc_2(block_size * nelements,
+			       (ORBit_free_childvals)ORBit_free_via_TypeCode,
+			       GINT_TO_POINTER(nelements),
+			       sizeof(CORBA_TypeCode));
+
+	*(CORBA_TypeCode *)((char *)retval-sizeof(ORBit_mem_info)-sizeof(CORBA_TypeCode)) = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)tc, NULL);
+    }
+
+    return retval;
+}
+
+#define DM_GET_ATOM(x, n) G_STMT_START{ GIOP_RECV_BUFFER(buf)->decoder(x, (GIOP_RECV_BUFFER(buf)->cur), n); GIOP_RECV_BUFFER(buf)->cur = ((guchar *)GIOP_RECV_BUFFER(buf)->cur) + n; }G_STMT_END
+
+static void
+ORBit_demarshal_value(GIOPRecvBuffer *buf,
+		      gpointer *val,
+		      CORBA_TypeCode tc,
+		      gboolean dup_strings,
+		      CORBA_ORB orb)
+{
+    CORBA_long i, n;
+
+#if 0
+    g_message("Demarshalling a %d value from offset %d into %#x",
+	      tc->kind, buf->cur - buf->message_body, (gulong)*val);
+#endif
+
+    switch(tc->kind) {
+    case CORBA_tk_short:
+    case CORBA_tk_ushort:
+    case CORBA_tk_wchar:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_SHORT);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_short));
+	DM_GET_ATOM(*val, sizeof(CORBA_short));
+	*val = ((guchar *)*val) + sizeof(CORBA_short);
+	break;
+    case CORBA_tk_long:
+    case CORBA_tk_ulong:
+    case CORBA_tk_enum:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_long));
+	DM_GET_ATOM(*val, sizeof(CORBA_long));
+	*val = ((guchar *)*val) + sizeof(CORBA_long);
+	break;
+    case CORBA_tk_longlong:
+    case CORBA_tk_ulonglong:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG_LONG);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_long_long));
+	DM_GET_ATOM(*val, sizeof(CORBA_long_long));
+	*val = ((guchar *)*val) + sizeof(CORBA_long_long);
+	break;
+    case CORBA_tk_longdouble:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG_DOUBLE);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_long_double));
+	DM_GET_ATOM(*val, sizeof(CORBA_long_double));
+	*val = ((guchar *)*val) + sizeof(CORBA_long_double);
+	break;
+    case CORBA_tk_float:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_FLOAT);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_float));
+	DM_GET_ATOM(*val, sizeof(CORBA_float));
+	*val = ((guchar *)*val) + sizeof(CORBA_float);
+	break;
+    case CORBA_tk_double:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_DOUBLE);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_double));
+	DM_GET_ATOM(*val, sizeof(CORBA_double));
+	*val = ((guchar *)*val) + sizeof(CORBA_double);
+	break;
+    case CORBA_tk_boolean:
+    case CORBA_tk_char:
+    case CORBA_tk_octet:
+	DM_GET_ATOM(*val, sizeof(CORBA_octet));
+	*val = ((guchar *)*val) + sizeof(CORBA_octet);
+	break;
+    case CORBA_tk_any:
+	{
+	    CORBA_any *decoded;
+
+	    *val = ALIGN_ADDRESS(*val,
+				 MAX(ALIGNOF_CORBA_LONG,
+				     MAX(ALIGNOF_CORBA_POINTER, ALIGNOF_CORBA_STRUCT)));
+	    decoded = *val;
+	    decoded->_release = CORBA_FALSE;
+	    ORBit_demarshal_any(buf, decoded, dup_strings, orb);
+	    *val = ((guchar *)*val) + sizeof(CORBA_any);
+	}
+	break;
+    case CORBA_tk_TypeCode:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	ORBit_decode_CORBA_TypeCode(*val, buf);
+	CORBA_Object_duplicate(*(CORBA_Object *)*val, NULL);
+	*val = ((guchar *)*val) + sizeof(CORBA_TypeCode);
+	break;
+    case CORBA_tk_Principal:
+	{
+	    CORBA_Principal *p;
+
+	    *val = ALIGN_ADDRESS(*val, MAX(ALIGNOF_CORBA_STRUCT,
+					   MAX(ALIGNOF_CORBA_LONG, ALIGNOF_CORBA_POINTER)));
+
+	    p = *val;
+	    buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_long));
+	    CORBA_sequence_set_release(p, dup_strings);
+	    DM_GET_ATOM(&p->_length, sizeof(CORBA_long));
+	    p->_buffer = ORBit_alloc(p->_length, NULL, GINT_TO_POINTER(1));
+	    memcpy(p->_buffer, buf->cur, p->_length);
+	    buf->cur = ((guchar *)buf->cur) + p->_length;
+	    *val = ((guchar *)*val) + sizeof(CORBA_sequence_octet);
+	}
+	break;
+    case CORBA_tk_objref:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	*(CORBA_Object *)*val = ORBit_demarshal_object(buf, orb);
+	*val = ((guchar *)*val) + sizeof(CORBA_Object);
+	break;
+    case CORBA_tk_except:
+    case CORBA_tk_struct:
+	*val = ALIGN_ADDRESS(*val, ORBit_find_alignment(tc));
+	for(i = 0; i < tc->sub_parts; i++) {
+	    ORBit_demarshal_value(buf, val, tc->subtypes[i], dup_strings, orb);
+	}
+	break;
+    case CORBA_tk_union:
+	{
+	    gpointer discrimptr;
+
+	    discrimptr = *val = ALIGN_ADDRESS(*val, ORBit_find_alignment(tc));
+	    ORBit_demarshal_value(buf, val, tc->discriminator, dup_strings, orb);
+	    n = 1;
+	    for(i = 0; i < tc->sub_parts; i++) {
+		n = MAX(n, ORBit_find_alignment(tc->subtypes[i]));
+	    }
+	    *val = ALIGN_ADDRESS(*val, n);
+	    ORBit_demarshal_value(buf, val,
+				  ORBit_get_union_tag(tc, &discrimptr, FALSE),
+				  dup_strings, orb);
+	}
+	break;
+    case CORBA_tk_string:
+    case CORBA_tk_wstring:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_long));
+	DM_GET_ATOM(&i, sizeof(CORBA_long));
+	if(dup_strings)
+	    *(char **)*val = CORBA_string_dup(buf->cur);
+	else
+	    *(char **)*val = buf->cur;
+	*val = ((guchar *)*val) + sizeof(CORBA_char *);
+	buf->cur = (gpointer)((char *)buf->cur + i);
+	break;
+    case CORBA_tk_sequence:
+	{
+	    CORBA_sequence_octet *p;
+	    gpointer subval;
+
+	    *val = ALIGN_ADDRESS(*val, MAX(ALIGNOF_CORBA_STRUCT,
+					   MAX(ALIGNOF_CORBA_LONG, ALIGNOF_CORBA_POINTER)));
+	    p = *val;
+	    buf->cur = ALIGN_ADDRESS(buf->cur, sizeof(CORBA_long));
+	    DM_GET_ATOM(&p->_length, sizeof(CORBA_long));
+	    if(tc->subtypes[0]->kind == CORBA_tk_octet
+	       || tc->subtypes[0]->kind == CORBA_tk_boolean
+	       || tc->subtypes[0]->kind == CORBA_tk_char) {
+		/* This special-casing could be taken further to apply to
+		   all atoms... */
+		p->_buffer = ORBit_alloc(p->_length, NULL, GINT_TO_POINTER(1));
+		memcpy(p->_buffer, buf->cur, p->_length);
+		buf->cur = ((guchar *)buf->cur) + p->_length;
+	    } else {
+		p->_buffer = ORBit_demarshal_allocate_mem(tc->subtypes[0],
+							  p->_length);
+		subval = p->_buffer;
+
+		for(i = 0; i < p->_length; i++)
+		    ORBit_demarshal_value(buf, &subval,
+					  tc->subtypes[0],
+					  dup_strings,
+					  orb);
+	    }
+
+	    *val = ((guchar *)*val) + sizeof(CORBA_sequence_octet);
+	}
+	break;
+    case CORBA_tk_array:
+	for(i = 0; i < tc->length; i++)
+	    ORBit_demarshal_value(buf, val, tc->subtypes[0], dup_strings, orb);
+	break;
+    case CORBA_tk_alias:
+	ORBit_demarshal_value(buf, val, tc->subtypes[0], dup_strings, orb);
+	break;
+    case CORBA_tk_fixed:
+	g_error("CORBA_fixed NYI");
+	break;
+    default:
+        break;
+    }
+}
+
+gpointer
+ORBit_demarshal_arg(GIOPRecvBuffer *buf,
+		    CORBA_TypeCode tc,
+		    gboolean dup_strings,
+		    CORBA_ORB orb)
+{
+    gpointer retval, val;
+
+    retval = val = ORBit_demarshal_allocate_mem(tc, 1);
+
+    ORBit_demarshal_value(buf, &val, tc, dup_strings, orb);
+
+    return retval;
+}
+
+void
+ORBit_demarshal_any(GIOPRecvBuffer *buf, CORBA_any *retval,
+		    gboolean dup_strings,
+		    CORBA_ORB orb)
+{
+    gpointer val;
+
+#if 0
+    /* I wish I knew whether this was correct or not. It breaks things like 'any anop();' for sure,
+       since we can't always initialize every single possible 'any' underneath _ORBIT_retval */
+    if(retval->_release)
+	CORBA_free(retval->_value);
+#endif
+
+    CORBA_any_set_release(retval, CORBA_TRUE);
+
+    ORBit_decode_CORBA_TypeCode(&retval->_type, buf);
+    CORBA_Object_duplicate((CORBA_Object)retval->_type, NULL);
+
+    val = retval->_value = ORBit_demarshal_allocate_mem(retval->_type, 1);
+    ORBit_demarshal_value(buf, &val, retval->_type, dup_strings, orb);
+}
+
+void
+_ORBit_copy_value(gpointer *val, gpointer *newval, CORBA_TypeCode tc)
+{
+    CORBA_long i;
+    gpointer pval1, pval2;
+
+    switch(tc->kind) {
+    case CORBA_tk_wchar:
+    case CORBA_tk_short:
+    case CORBA_tk_ushort:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_SHORT);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_SHORT);
+	*(CORBA_short *)*newval = *(CORBA_short *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_short);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_short);
+	break;
+    case CORBA_tk_enum:
+    case CORBA_tk_long:
+    case CORBA_tk_ulong:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_LONG);
+	*(CORBA_long *)*newval = *(CORBA_long *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_long);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_long);
+	break;
+    case CORBA_tk_longlong:
+    case CORBA_tk_ulonglong:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG_LONG);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_LONG_LONG);
+	*(CORBA_long_long *)*newval = *(CORBA_long_long *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_long_long);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_long_long);
+	break;
+    case CORBA_tk_longdouble:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_LONG_DOUBLE);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_LONG_DOUBLE);
+	*(CORBA_long_double *)*newval = *(CORBA_long_double *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_long_double);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_long_double);
+	break;
+    case CORBA_tk_float:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_FLOAT);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_FLOAT);
+	*(CORBA_long *)*newval = *(CORBA_long *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_float);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_float);
+	break;
+    case CORBA_tk_double:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_DOUBLE);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_DOUBLE);
+	*(CORBA_double *)*newval = *(CORBA_double *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_double);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_double);
+	break;
+    case CORBA_tk_boolean:
+    case CORBA_tk_char:
+    case CORBA_tk_octet:
+	*(CORBA_octet *)*newval = *(CORBA_octet *)*val;
+	*val = ((guchar *)*val) + sizeof(CORBA_octet);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_octet);
+	break;
+    case CORBA_tk_any:
+	{
+	    CORBA_any *oldany, *newany;
+	    *val = ALIGN_ADDRESS(*val, MAX(ALIGNOF_CORBA_STRUCT, ALIGNOF_CORBA_POINTER));
+	    *newval = ALIGN_ADDRESS(*newval, MAX(ALIGNOF_CORBA_STRUCT, ALIGNOF_CORBA_POINTER));
+	    oldany = *val;
+	    newany = *newval;
+	    newany->_type = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)oldany->_type, NULL);
+	    /* XXX are we supposed to do this even if oldany->_release
+               == FALSE? */
+	    newany->_value = ORBit_copy_value(oldany->_value, oldany->_type);
+	    newany->_release = CORBA_TRUE;
+	    *val = ((guchar *)*val) + sizeof(CORBA_any);
+	    *newval = ((guchar *)*newval) + sizeof(CORBA_any);
+	}
+	break;
+    case CORBA_tk_Principal:
+	*val = ALIGN_ADDRESS(*val,
+			     MAX(MAX(ALIGNOF_CORBA_LONG,
+				     ALIGNOF_CORBA_STRUCT),
+				 ALIGNOF_CORBA_POINTER));
+	*newval = ALIGN_ADDRESS(*newval,
+				MAX(MAX(ALIGNOF_CORBA_LONG,
+					ALIGNOF_CORBA_STRUCT),
+				    ALIGNOF_CORBA_POINTER));
+	*(CORBA_Principal *)*newval = *(CORBA_Principal *)*val;
+	((CORBA_Principal *)*newval)->_buffer =
+	    CORBA_octet_allocbuf(((CORBA_Principal *)*newval)->_length);
+	memcpy(((CORBA_Principal *)*newval)->_buffer,
+	       ((CORBA_Principal *)*val)->_buffer,
+	       ((CORBA_Principal *)*val)->_length);
+	*val = ((guchar *)*val) + sizeof(CORBA_Principal);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_Principal);
+	break;
+    case CORBA_tk_TypeCode:
+    case CORBA_tk_objref:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_POINTER);
+	*(CORBA_Object *)*newval = CORBA_Object_duplicate(*(CORBA_Object *)*val,
+							  NULL);
+	*val = ((guchar *)*val) + sizeof(CORBA_Object);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_Object);
+	break;
+    case CORBA_tk_struct:
+    case CORBA_tk_except:
+	*val = ALIGN_ADDRESS(*val, ORBit_find_alignment(tc));
+	*newval = ALIGN_ADDRESS(*newval, ORBit_find_alignment(tc));
+	for(i = 0; i < tc->sub_parts; i++) {
+	    _ORBit_copy_value(val, newval, tc->subtypes[i]);
+	}
+	break;
+    case CORBA_tk_union:
+	{
+	    CORBA_TypeCode utc = ORBit_get_union_tag(tc, val, FALSE);
+	    gint	union_align = ORBit_find_alignment(tc);
+	    size_t	union_size = ORBit_gather_alloc_info(tc);
+
+	    /* need to advance val,newval by size of union, not just
+	     * current tagged field within it */
+	    pval1 = *val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_STRUCT);
+	    pval2 = *newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_STRUCT);
+	    _ORBit_copy_value(&pval1, &pval2, tc->discriminator);
+	    pval1 = ALIGN_ADDRESS(pval1, union_align);
+	    pval2 = ALIGN_ADDRESS(pval2, union_align);
+	    _ORBit_copy_value(&pval1, &pval2, utc);
+	    *val = ((guchar *)*val) + union_size;
+	    *newval = ((guchar *)*newval) + union_size;
+	}
+	break;
+    case CORBA_tk_wstring:
+    case CORBA_tk_string:
+	*val = ALIGN_ADDRESS(*val, ALIGNOF_CORBA_POINTER);
+	*newval = ALIGN_ADDRESS(*newval, ALIGNOF_CORBA_POINTER);
+	
+	*(CORBA_char **)*newval = CORBA_string_dup(*(CORBA_char **)*val);
+	*val = ((guchar *)*val) + sizeof(CORBA_char *);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_char *);
+	break;
+    case CORBA_tk_sequence:
+	*val = ALIGN_ADDRESS(*val,
+			     MAX(MAX(ALIGNOF_CORBA_LONG,
+				     ALIGNOF_CORBA_STRUCT),
+				 ALIGNOF_CORBA_POINTER));
+	*newval = ALIGN_ADDRESS(*newval,
+				MAX(MAX(ALIGNOF_CORBA_LONG,
+					ALIGNOF_CORBA_STRUCT),
+				    ALIGNOF_CORBA_POINTER));
+	((CORBA_Principal *)*newval)->_release = CORBA_TRUE;
+	((CORBA_Principal *)*newval)->_length =
+	     ((CORBA_Principal *)*newval)->_maximum =
+					 ((CORBA_Principal *)*val)->_length;
+	((CORBA_Principal *)*newval)->_buffer = pval2 =
+	    ORBit_demarshal_allocate_mem(tc->subtypes[0],
+					 ((CORBA_Principal *)*val)->_length);
+	pval1 = ((CORBA_Principal *)*val)->_buffer;
+	
+	for(i = 0; i < ((CORBA_Principal *)*newval)->_length; i++) {
+	    _ORBit_copy_value(&pval1, &pval2, tc->subtypes[0]);
+	}
+	*val = ((guchar *)*val) + sizeof(CORBA_sequence_octet);
+	*newval = ((guchar *)*newval) + sizeof(CORBA_sequence_octet);
+	break;
+    case CORBA_tk_array:
+	for(i = 0; i < tc->length; i++) {
+	    _ORBit_copy_value(val, newval, tc->subtypes[0]);
+	}
+	break;
+    case CORBA_tk_alias:
+	_ORBit_copy_value(val, newval, tc->subtypes[0]);
+	break;
+    case CORBA_tk_fixed:
+	g_error("CORBA_fixed NYI!");
+	break;
+    case CORBA_tk_void:
+    case CORBA_tk_null:
+	*val = NULL;
+	break;
+    default:
+	g_error("Can't handle copy of value kind %d", tc->kind);
+    }
+}
+
+gpointer
+ORBit_copy_value(gpointer value, CORBA_TypeCode tc)
+{
+    gpointer retval, newval;
+
+    retval = newval = ORBit_demarshal_allocate_mem(tc, 1);
+    _ORBit_copy_value(&value, &newval, tc);
+
+    return retval;
+}
+
+void
+CORBA_any__copy(CORBA_any *out, CORBA_any *in)
+{
+    out->_type = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)in->_type,
+							NULL);
+    out->_value = ORBit_copy_value(in->_value, in->_type);
+    out->_release = CORBA_TRUE;
+}
diff -urN linux-2.4.1/net/korbit/orb/corba_any.h linux-2.4.1-korbit/net/korbit/orb/corba_any.h
--- linux-2.4.1/net/korbit/orb/corba_any.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_any.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,45 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_ANY_H_
+#define _ORBIT_CORBA_ANY_H_
+
+#include "orbit_types.h"
+#include "corba_typecode.h"
+
+#include <unistd.h>
+
+typedef struct CORBA_any_type CORBA_any;
+
+size_t ORBit_gather_alloc_info(CORBA_TypeCode tc);
+gint ORBit_find_alignment(CORBA_TypeCode tc);
+CORBA_TypeCode ORBit_get_union_tag(CORBA_TypeCode union_tc,
+				   gpointer *val, gboolean update);
+gpointer ORBit_copy_value(gpointer value, CORBA_TypeCode tc);
+void _ORBit_copy_value(gpointer *val, gpointer *newval, CORBA_TypeCode tc);
+
+void CORBA_any__copy(CORBA_any *out, CORBA_any *in);
+
+#endif /* !_ORBIT_CORBA_ANY_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_any_proto.h linux-2.4.1-korbit/net/korbit/orb/corba_any_proto.h
--- linux-2.4.1/net/korbit/orb/corba_any_proto.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_any_proto.h	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,16 @@
+#ifndef _ORBIT_CORBA_ANY_PROTO_H_
+#define _ORBIT_CORBA_ANY_PROTO_H_
+
+void ORBit_marshal_arg(GIOPSendBuffer *buf,
+		       gpointer val,
+		       CORBA_TypeCode tc);
+void ORBit_marshal_any(GIOPSendBuffer *buf, const CORBA_any *val);
+gpointer ORBit_demarshal_arg(GIOPRecvBuffer *buf,
+			     CORBA_TypeCode tc,
+			     gboolean dup_strings,
+			     CORBA_ORB orb);
+void ORBit_demarshal_any(GIOPRecvBuffer *buf, CORBA_any *retval,
+			 gboolean dup_strings,
+			 CORBA_ORB orb);
+
+#endif /* !_ORBIT_CORBA_ANY_PROTO_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_any_type.h linux-2.4.1-korbit/net/korbit/orb/corba_any_type.h
--- linux-2.4.1/net/korbit/orb/corba_any_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_any_type.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,48 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@acm.org>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_ANY_TYPE_H_
+#define _ORBIT_CORBA_ANY_TYPE_H_
+
+#include "corba_any.h"
+#include "corba_typecode.h"
+
+struct CORBA_any_type {
+	CORBA_TypeCode _type;
+	gpointer _value;
+	CORBA_boolean _release;
+};
+
+typedef struct ORBit_marshal_value_info_struct {
+	CORBA_TypeCode alias_element_type;
+} ORBit_marshal_value_info;
+
+#define CORBA_ANYFLAGS_RELEASE 1
+
+
+#endif /* !_ORBIT_CORBA_ANY_TYPE_H_ */
+
+
+
diff -urN linux-2.4.1/net/korbit/orb/corba_basic_sequences_type.h linux-2.4.1-korbit/net/korbit/orb/corba_basic_sequences_type.h
--- linux-2.4.1/net/korbit/orb/corba_basic_sequences_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_basic_sequences_type.h	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,43 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_BASIC_SEQUENCES_TYPE_H_
+#define _ORBIT_CORBA_BASIC_SEQUENCES_TYPE_H_
+
+#include <ORBitutil/basic_types.h>
+
+#ifndef _CORBA_sequence_octet_defined
+#define _CORBA_sequence_octet_defined 1
+
+typedef struct CORBA_sequence_octet_struct {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_octet *_buffer;
+	CORBA_boolean _release;
+} CORBA_sequence_octet;
+#endif /* !_CORBA_sequence_octet_defined */
+
+#include <orb/corba_sequences.h>
+#endif /* !_ORBIT_CORBA_BASIC_SEQUENCES_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_context.c linux-2.4.1-korbit/net/korbit/orb/corba_context.c
--- linux-2.4.1/net/korbit/orb/corba_context.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_context.c	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,390 @@
+#include "orb/orbit.h"
+
+#define o_return_val_if_fail(expr, val) if(!(expr)) { CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM, CORBA_COMPLETED_NO); return (val); }
+#define o_return_if_fail(expr) if(!(expr)) { CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM, CORBA_COMPLETED_NO); return; }
+
+static gboolean
+free_entry(gpointer key, gpointer value, gpointer user_data)
+{
+  g_free(key);
+  g_free(value);
+
+  return TRUE;
+}
+
+static void
+ORBit_Context_release(CORBA_Context ctx, CORBA_Environment *ev);
+
+static gboolean
+free_child(gpointer value, gpointer user_data)
+{
+  CORBA_Context ctx = value;
+
+  ORBIT_ROOT_OBJECT(ctx)->refs = 1;
+  ctx->parent_ctx = CORBA_OBJECT_NIL;
+  ORBit_Context_release(ctx, NULL);
+
+  return TRUE;
+}
+
+static void
+ORBit_Context_release(CORBA_Context ctx,
+		      CORBA_Environment *ev)
+{
+  ORBIT_ROOT_OBJECT_UNREF(ctx);
+
+  if(ORBIT_ROOT_OBJECT(ctx)->refs <= 0) {
+    if(ctx->children) {
+      g_slist_foreach(ctx->children, (GFunc)free_child, ctx);
+      g_slist_free(ctx->children);
+    }
+
+    if(ctx->mappings) {
+      g_hash_table_foreach_remove(ctx->mappings, free_entry, ctx);
+      g_hash_table_destroy(ctx->mappings);
+    }
+
+    if(ctx->parent_ctx != CORBA_OBJECT_NIL)
+      ctx->parent_ctx->children = g_slist_remove(ctx->parent_ctx->children, ctx->the_name);
+	  
+    g_free(ctx->the_name);
+	  
+    g_free(ctx);
+  }
+}
+
+static const ORBit_RootObject_Interface CORBA_Context_epv =
+{
+  (void (*)(gpointer, CORBA_Environment *))ORBit_Context_release,
+};
+
+static CORBA_Context
+CORBA_Context_new(CORBA_Context parent, const char *name, CORBA_Environment *ev)
+{
+  CORBA_Context retval;
+
+  retval = g_new0(struct CORBA_Context_type, 1);
+
+  ORBit_pseudo_object_init(ORBIT_PSEUDO_OBJECT(retval), ORBIT_PSEUDO_CONTEXT, ev);
+
+  ORBIT_ROOT_OBJECT(retval)->refs = 0;
+  ORBit_RootObject_set_interface(ORBIT_ROOT_OBJECT(retval), (gpointer)&CORBA_Context_epv, ev);
+
+  if(name)
+    retval->the_name = g_strdup(name);
+
+  retval->parent_ctx = parent;
+  if(parent)
+    parent->children = g_slist_prepend(parent->children, retval);
+
+  return retval;
+}
+
+/* Section 5.6.1 */
+CORBA_Status CORBA_ORB_get_default_context(CORBA_ORB orb, CORBA_Context *ctx, CORBA_Environment *ev)
+{
+  g_return_if_fail(ev != NULL);
+  o_return_if_fail(orb && ctx);
+
+  if(!orb->default_ctx)
+    orb->default_ctx = CORBA_Context_new(CORBA_OBJECT_NIL, NULL, ev);
+
+  *ctx = (CORBA_Context)CORBA_Object_duplicate((CORBA_Object)orb->default_ctx, ev);
+}
+
+/********* XXX todo - CORBA_Context support */
+CORBA_Status CORBA_Context_set_one_value(CORBA_Context ctx, CORBA_Identifier prop_name, char *value, CORBA_Environment *ev)
+{
+  gpointer old_nom, old_value;
+  g_return_if_fail(ev != NULL);
+  o_return_if_fail(ctx && prop_name && value);
+
+  if(!ctx->mappings)
+    ctx->mappings = g_hash_table_new(g_str_hash, g_str_equal);
+
+  if(g_hash_table_lookup_extended(ctx->mappings, prop_name, &old_nom, &old_value)) {
+    g_free(old_nom);
+    g_free(old_value);
+  }
+
+  g_hash_table_insert(ctx->mappings, g_strdup(prop_name), g_strdup(value));
+}
+
+/* Section 5.6.3 */
+CORBA_Status CORBA_Context_set_values(CORBA_Context ctx, CORBA_NVList *values, CORBA_Environment *ev)
+{
+  int i;
+
+  for(i = 0; i < values->list->len; i++) {
+    CORBA_NamedValue *nvp;
+
+    nvp = ((CORBA_NamedValue *)values->list->data) + i;
+
+    g_assert(nvp->argument._type == TC_string);
+
+    CORBA_Context_set_one_value(ctx, nvp->name, nvp->argument._value, ev);
+  }
+}
+
+/* Section 5.6.4 */
+
+typedef struct {
+  CORBA_Context ctx;
+  CORBA_Identifier prop_name;
+  CORBA_NVList *values;
+  CORBA_Environment *ev;
+  int len;
+} CTXSearchInfo;
+
+static gboolean
+list_has_key(CORBA_NVList *list, const char *key)
+{
+  int i;
+
+  for(i = 0; i < list->list->len; i++) {
+    CORBA_NamedValue *nvp;
+
+    nvp = ((CORBA_NamedValue *)list->list->data) + i;
+
+    if(!strcmp(nvp->name, key))
+      return TRUE;
+  }
+
+  return FALSE;
+}
+
+static void
+search_props(gpointer key, gpointer value, CTXSearchInfo *csi)
+{
+  if(strncmp(key, csi->prop_name, csi->len))
+    return;
+
+  if(list_has_key(csi->values, key))
+    return;
+
+  CORBA_NVList_add_item(csi->values, key, TC_string, &value, strlen(value) + 1, CORBA_IN_COPY_VALUE, NULL);
+}
+
+static void
+ctx_get_values(CORBA_Context ctx, CORBA_Flags op_flags,
+	       CORBA_Identifier prop_name, CORBA_NVList **values,
+	       gint is_wc,
+	       CORBA_Environment *ev)
+{
+  gboolean go_up = FALSE;
+
+  if(is_wc >= 0) {
+    CTXSearchInfo csi;
+  
+    csi.ctx = ctx;
+    csi.prop_name = prop_name;
+    csi.values = *values;
+    csi.ev = ev;
+    csi.len = is_wc;
+
+    if(ctx->mappings)
+      g_hash_table_foreach(ctx->mappings, (GHFunc)search_props, &csi);
+
+    go_up = TRUE;
+
+  } else {
+    char *val = NULL;
+
+    if(ctx->mappings)
+      val = g_hash_table_lookup(ctx->mappings, prop_name);
+
+    if(val)
+      CORBA_NVList_add_item(*values, prop_name, TC_string, &val, strlen(val) + 1, CORBA_IN_COPY_VALUE, ev);
+    else
+      go_up = TRUE;
+  }
+
+  if(go_up
+     && ctx->parent_ctx
+     && !(op_flags & CORBA_CTX_RESTRICT_SCOPE))
+    ctx_get_values(ctx->parent_ctx, op_flags, prop_name, values, is_wc, ev);
+}
+
+CORBA_Status CORBA_Context_get_values(CORBA_Context ctx,
+				      CORBA_Identifier start_scope,
+				      CORBA_Flags op_flags,
+				      CORBA_Identifier prop_name,
+				      CORBA_NVList **values,
+				      CORBA_Environment *ev)
+{
+  char *ctmp;
+  int wc_pos;
+
+  CORBA_ORB_create_list(CORBA_OBJECT_NIL, 0, values, ev);
+
+  if(start_scope && *start_scope) {
+    while(ctx && (!ctx->the_name || strcmp(ctx->the_name, start_scope)))
+      ctx = ctx->parent_ctx;
+
+    if(!ctx) {
+      CORBA_exception_set_system(ev, ex_CORBA_INV_IDENT, CORBA_COMPLETED_NO);
+      return;
+    }
+  }
+
+  ctmp = strchr(prop_name, '*');
+  if(ctmp)
+    wc_pos = ctmp - prop_name;
+  else
+    wc_pos = -1;
+
+  CORBA_ORB_create_list(CORBA_OBJECT_NIL, 0, values, ev);
+
+  ctx_get_values(ctx, op_flags, prop_name, values, (prop_name[strlen(prop_name) - 1] == '*'), ev);
+
+  if((*values)->list->len == 0)
+    {
+      CORBA_NVList_free(*values, ev);
+      *values = NULL;
+      CORBA_exception_set_system(ev, ex_CORBA_UNKNOWN, CORBA_COMPLETED_NO);
+    }
+}
+
+/* Section 5.6.5 */
+static void
+delete_props(gpointer key, gpointer value, CTXSearchInfo *csi)
+{
+  if(strncmp(key, csi->prop_name, csi->len))
+    return;
+
+  g_hash_table_remove(csi->ctx->mappings, key);
+  g_free(key);
+  g_free(value);
+}
+
+CORBA_Status CORBA_Context_delete_values(CORBA_Context ctx, CORBA_Identifier prop_name, CORBA_Environment *ev)
+{
+  char *ctmp;
+  int wc_pos;
+
+  if(!ctx->mappings)
+    return;
+
+  ctmp = strchr(prop_name, '*');
+  if(ctmp)
+    wc_pos = ctmp - prop_name;
+  else
+    wc_pos = -1;
+
+  if(wc_pos >= 0) {
+    CTXSearchInfo csi;
+
+    memset(&csi, 0, sizeof(csi));
+    csi.ctx = ctx;
+    csi.prop_name = prop_name;
+    csi.ev = ev;
+    csi.len = wc_pos;
+
+    g_hash_table_foreach(ctx->mappings, (GHFunc)delete_props, &csi);
+  } else {
+    gpointer old_nom, old_value;
+
+    if(g_hash_table_lookup_extended(ctx->mappings, prop_name, &old_nom, &old_value)) {
+      g_free(old_nom);
+      g_free(old_value);
+    }
+  }
+}
+
+/* Section 5.6.6 */
+CORBA_Status CORBA_Context_create_child(CORBA_Context ctx, CORBA_Identifier ctx_name, CORBA_Context *child_ctx, CORBA_Environment *ev)
+{
+  *child_ctx = CORBA_Context_new(ctx, ctx_name, ev);
+}
+
+/* Section 5.6.7 */
+CORBA_Status CORBA_Context_delete(CORBA_Context ctx, CORBA_Flags del_flags, CORBA_Environment *ev)
+{
+  if((del_flags & CORBA_CTX_DELETE_DESCENDENTS)
+     || !ctx->children)
+    free_child(ctx, NULL);
+}
+
+void
+ORBit_Context_marshal(CORBA_Context ctx, const ORBit_ContextMarshalItem *mlist, CORBA_unsigned_long nitems, GIOPSendBuffer *buf)
+{
+  int i;
+  CORBA_unsigned_long *real_nitems, ltmp;
+
+  real_nitems = giop_send_buffer_append_mem_indirect_a(buf, &nitems, sizeof(nitems));
+  if(!ctx->mappings) {
+    *real_nitems = 0;
+    return;
+  }
+
+  for(*real_nitems = i = 0; i < nitems; i++) {
+    char *value;
+
+    value = g_hash_table_lookup(ctx->mappings, mlist[i].str);
+    if(!value)
+      continue;
+
+    /* Key */
+    giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(buf), &(mlist[i].len), sizeof(mlist[i].len));
+    giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(buf), mlist[i].str, mlist[i].len);
+    (*real_nitems)++;
+
+    /* Value */
+    ltmp = strlen(value) + 1;
+    giop_send_buffer_append_mem_indirect_a(buf, &ltmp, sizeof(ltmp));
+    giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(buf), value, ltmp);
+    (*real_nitems)++;
+  }
+}
+
+#define GET_ATOM(x) G_STMT_START{ GIOP_RECV_BUFFER(recv_buffer)->decoder(&x, (GIOP_RECV_BUFFER(recv_buffer)->cur), sizeof(x)); \
+GIOP_RECV_BUFFER(recv_buffer)->cur = ((guchar *)GIOP_RECV_BUFFER(recv_buffer)->cur) + sizeof(x); \
+}G_STMT_END
+#define ALIGNFOR(x) recv_buffer->cur = ALIGN_ADDRESS(recv_buffer->cur, sizeof(x))
+
+void
+ORBit_Context_demarshal(CORBA_Context parent, CORBA_Context initme, GIOPRecvBuffer *recv_buffer)
+{
+  CORBA_unsigned_long nstrings, keylen, vallen, i;
+  char *key, *value;
+
+  memset(initme, 0, sizeof(struct CORBA_Context_type));
+  ORBIT_ROOT_OBJECT(initme)->refs = -1;
+
+  initme->parent_ctx = parent;
+
+  ALIGNFOR(nstrings);
+  GET_ATOM(nstrings);
+
+  if(nstrings)
+    initme->mappings = g_hash_table_new(g_str_hash, g_str_equal);
+  else
+    return;
+
+  g_hash_table_freeze(initme->mappings);
+  for(i = 0; i < nstrings; ) {
+    ALIGNFOR(keylen);
+    GET_ATOM(keylen);
+    key = recv_buffer->cur;
+    recv_buffer->cur = ((char *)recv_buffer->cur) + keylen;
+    i++;
+
+    if(i >= nstrings)
+      break;
+
+    ALIGNFOR(vallen);
+    GET_ATOM(vallen);
+    value = recv_buffer->cur;
+    recv_buffer->cur = ((char *)recv_buffer->cur) + vallen;
+    i++;
+
+    g_hash_table_insert(initme->mappings, key, value);
+  }
+  g_hash_table_thaw(initme->mappings);
+}
+
+void
+ORBit_Context_server_free(CORBA_Context ctx)
+{
+  g_hash_table_destroy(ctx->mappings);
+}
diff -urN linux-2.4.1/net/korbit/orb/corba_context.h linux-2.4.1-korbit/net/korbit/orb/corba_context.h
--- linux-2.4.1/net/korbit/orb/corba_context.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_context.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,65 @@
+#ifndef CORBA_CONTEXT_H
+#define CORBA_CONTEXT_H 1
+
+#include "orbit_object_type.h"
+#include "orbit_object.h"
+
+typedef struct {
+  CORBA_unsigned_long len;
+  const CORBA_char *str;
+} ORBit_ContextMarshalItem;
+
+typedef struct CORBA_Context_type *CORBA_Context;
+
+struct CORBA_Context_type {
+  struct ORBit_PseudoObject_struct parent;
+  GHashTable *mappings;
+  GSList *children;
+
+  char *the_name;
+
+  CORBA_Context parent_ctx;
+};
+
+
+extern CORBA_Status CORBA_Context_set_one_value(
+	CORBA_Context ctx,
+	CORBA_Identifier prop_name,
+	char *value,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Context_set_values(
+	CORBA_Context ctx,
+	CORBA_NVList *values,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Context_get_values(
+	CORBA_Context ctx,
+	CORBA_Identifier start_scope,
+	CORBA_Flags op_flags,
+	CORBA_Identifier prop_name,
+	CORBA_NVList **values,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Context_delete_values(
+	CORBA_Context ctx,
+	CORBA_Identifier prop_name,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Context_create_child(
+	CORBA_Context ctx,
+	CORBA_Identifier ctx_name,
+	CORBA_Context *child_ctx,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Context_delete(
+	CORBA_Context ctx,
+	CORBA_Flags del_flags,
+	CORBA_Environment *ev);
+
+void ORBit_Context_marshal(CORBA_Context ctx, const ORBit_ContextMarshalItem *mlist,
+			   CORBA_unsigned_long nitems, GIOPSendBuffer *buf);
+void ORBit_Context_demarshal(CORBA_Context parent, CORBA_Context initme, GIOPRecvBuffer *recv_buffer);
+void ORBit_Context_server_free(CORBA_Context ctx);
+
+#endif
diff -urN linux-2.4.1/net/korbit/orb/corba_env.h linux-2.4.1-korbit/net/korbit/orb/corba_env.h
--- linux-2.4.1/net/korbit/orb/corba_env.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_env.h	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,79 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_ENV_H_
+#define _ORBIT_CORBA_ENV_H_
+
+typedef struct CORBA_Environment_type CORBA_Environment;
+
+/* 3.15 */
+typedef enum {
+	CORBA_COMPLETED_YES=0,
+	CORBA_COMPLETED_NO,
+	CORBA_COMPLETED_MAYBE
+} CORBA_completion_status;
+
+typedef enum {
+	CORBA_NO_EXCEPTION=0,
+	CORBA_USER_EXCEPTION,
+	CORBA_SYSTEM_EXCEPTION
+} CORBA_exception_type;
+
+
+#define ex_CORBA_UNKNOWN 1
+#define ex_CORBA_BAD_PARAM 2
+#define ex_CORBA_NO_MEMORY 3
+#define ex_CORBA_IMP_LIMIT 4
+#define ex_CORBA_COMM_FAILURE 5
+#define ex_CORBA_INV_OBJREF 6
+#define ex_CORBA_NO_PERMISSION 7
+#define ex_CORBA_INTERNAL 8
+#define ex_CORBA_MARSHAL 9
+#define ex_CORBA_INITIALIZE 10
+#define ex_CORBA_NO_IMPLEMENT 11
+#define ex_CORBA_BAD_TYPECODE 12
+#define ex_CORBA_BAD_OPERATION 13
+#define ex_CORBA_NO_RESOURCES 14
+#define ex_CORBA_NO_RESPONSE 15
+#define ex_CORBA_PERSIST_STORE 16
+#define ex_CORBA_BAD_INV_ORDER 17
+#define ex_CORBA_TRANSIENT 18
+#define ex_CORBA_FREE_MEM 19
+#define ex_CORBA_INV_IDENT 20
+#define ex_CORBA_INV_FLAG 21
+#define ex_CORBA_INTF_REPOS 22
+#define ex_CORBA_BAD_CONTEXT 23
+#define ex_CORBA_OBJ_ADAPTER 24
+#define ex_CORBA_DATA_CONVERSION 25
+#define ex_CORBA_OBJECT_NOT_EXIST 26
+#define ex_CORBA_TRANSACTION_REQUIRED 27
+#define ex_CORBA_TRANSACTION_ROLLEDBACK 28
+#define ex_CORBA_INVALID_TRANSACTION 29
+
+
+#endif /* !_ORBIT_CORBA_ENV_H_ */
+
+
+
diff -urN linux-2.4.1/net/korbit/orb/corba_env_type.h linux-2.4.1-korbit/net/korbit/orb/corba_env_type.h
--- linux-2.4.1/net/korbit/orb/corba_env_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_env_type.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,79 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_ENV_TYPE_H_
+#define _ORBIT_CORBA_ENV_TYPE_H_
+
+#include "corba_env.h"
+#include "corba_any.h"
+
+typedef struct CORBA_system_exception {
+	CORBA_unsigned_long minor;
+	CORBA_completion_status completed;
+} CORBA_SystemException;
+
+#define SYSEXC(name)	typedef CORBA_SystemException name;
+
+SYSEXC(CORBA_UNKNOWN)
+SYSEXC(CORBA_BAD_PARAM)
+SYSEXC(CORBA_NO_MEMORY)
+SYSEXC(CORBA_IMP_LIMIT)
+SYSEXC(CORBA_COMM_FAILURE)
+SYSEXC(CORBA_INV_OBJREF)
+SYSEXC(CORBA_NO_PERMISSION)
+SYSEXC(CORBA_INTERNAL)
+SYSEXC(CORBA_MARSHAL)
+SYSEXC(CORBA_INITIALIZE)
+SYSEXC(CORBA_NO_IMPLEMENT)
+SYSEXC(CORBA_BAD_TYPECODE)
+SYSEXC(CORBA_BAD_OPERATION)
+SYSEXC(CORBA_NO_RESOURCES)
+SYSEXC(CORBA_NO_RESPONSE)
+SYSEXC(CORBA_PERSIST_STORE)
+SYSEXC(CORBA_BAD_INV_ORDER)
+SYSEXC(CORBA_TRANSIENT)
+SYSEXC(CORBA_FREE_MEM)
+SYSEXC(CORBA_INV_IDENT)
+SYSEXC(CORBA_INV_FLAG)
+SYSEXC(CORBA_INTF_REPOS)
+SYSEXC(CORBA_BAD_CONTEXT)
+SYSEXC(CORBA_OBJ_ADAPTER)
+SYSEXC(CORBA_DATA_CONVERSION)
+SYSEXC(CORBA_OBJECT_NOT_EXIST)
+SYSEXC(CORBA_TRANSACTION_REQUIRED)
+SYSEXC(CORBA_TRANSACTION_ROLLEDBACK)
+SYSEXC(CORBA_INVALID_TRANSACTION)
+
+
+/* 19.22 */
+struct CORBA_Environment_type {
+	CORBA_exception_type _major;
+	CORBA_char *_repo_id;
+	void *_params;
+	CORBA_any *_any;
+};
+
+
+#endif /* !_ORBIT_CORBA_ENV_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_object.c linux-2.4.1-korbit/net/korbit/orb/corba_object.c
--- linux-2.4.1/net/korbit/orb/corba_object.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_object.c	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,467 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *          Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+#include "config.h"
+#include <IIOP/IIOP.h>
+#include "orbit_types.h"
+#include "corba_object.h"
+#include "corba_object_type.h"
+#include "env.h"
+#include "orb.h"
+#ifdef __KORBIT__
+#include "orbit.h"
+#else /* !__KORBIT__ */
+#include "interface_repository.h"
+#endif /* !__KORBIT__ */
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <alloca.h>
+
+#ifndef __KERNEL__
+#define freeca(ptr)
+#endif
+
+#ifndef __KORBIT__
+/* Section 4.2.1 */
+CORBA_InterfaceDef CORBA_Object_get_interface(CORBA_Object obj, CORBA_Environment *ev)
+{
+	CORBA_Repository repo;
+	CORBA_InterfaceDef interface;
+
+	if(obj==CORBA_OBJECT_NIL)
+		return(CORBA_OBJECT_NIL); /* no exception defined in spec */
+
+	repo=CORBA_ORB_resolve_initial_references(obj->orb, "InterfaceRepository", ev);
+	if(repo==CORBA_OBJECT_NIL)
+		return(CORBA_OBJECT_NIL);
+
+	interface=CORBA_Repository_lookup_id(repo, obj->object_id, ev);
+	CORBA_Object_release(repo, ev);
+
+	return(interface);
+}
+#endif /* !__KORBIT__ */
+
+/* Section 4.2.3 */
+CORBA_boolean CORBA_Object_is_nil(CORBA_Object obj, CORBA_Environment *ev)
+{
+	if(obj==CORBA_OBJECT_NIL) {
+		return(CORBA_TRUE);
+	} else {
+		return(CORBA_FALSE);
+	}
+}
+
+/* Section 4.2.2 */
+/* XXXX Big warning: lots of places inside ORBit expect this to
+                     always return 'obj'. Do not change this, upon pain
+		     of death... */
+CORBA_Object CORBA_Object_duplicate(CORBA_Object obj, CORBA_Environment *ev)
+{
+	if(obj == CORBA_OBJECT_NIL)
+		return CORBA_OBJECT_NIL;
+
+	if(ORBIT_ROOT_OBJECT(obj)->refs >= 0)
+		ORBIT_ROOT_OBJECT_REF(obj);
+
+	return(obj);
+}
+
+
+/* Section 4.2.2 */
+void CORBA_Object_release(CORBA_Object obj, CORBA_Environment *ev)
+{
+	if(obj != CORBA_OBJECT_NIL)
+		ORBIT_ROOT_OBJECT_release(obj,ev);
+}
+
+extern GHashTable *ORBit_class_assignments;
+
+void ORBit_impl_CORBA_Object_is_a(gpointer servant,
+				  GIOPRecvBuffer * _ORBIT_recv_buffer,
+				  CORBA_Environment *ev,
+				  gpointer dummy)
+{
+	GIOPSendBuffer *_ORBIT_send_buffer;
+	struct CORBA_Object_struct objdummy; /* XXX badhack to save backwards compat */
+	CORBA_boolean retval;
+	char *repo_id;
+	CORBA_unsigned_long slen;
+	guchar *curptr;
+	ORBit_ObjectKey *objkey;
+	gpointer *tmp_vepv;
+	guint sz;
+	CORBA_unsigned_long clsid;
+	PortableServer_ServantBase *_ORBIT_servant;
+
+	_ORBIT_servant = servant;
+
+	/* XXX security implications */
+	curptr = _ORBIT_recv_buffer->cur;
+	curptr = ALIGN_ADDRESS(curptr, 4);
+	if(giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)))
+		iiop_byteswap((guchar *)&slen, curptr, sizeof(CORBA_unsigned_long));
+	else
+		slen = *((CORBA_unsigned_long *)curptr);
+	curptr += 4;
+	repo_id = curptr;
+
+	repo_id[slen] = '\0';
+
+	objkey = ORBIT_OBJECT_KEY(_ORBIT_servant->_private);
+
+	sz = sizeof(gpointer) * (ORBit_class_assignment_counter + 1);
+	tmp_vepv = alloca(sz);
+	memset(tmp_vepv, '\0', sz);
+
+	objdummy.vepv = tmp_vepv;
+	objkey->class_info->init_local_objref(&objdummy, servant);
+
+	clsid = GPOINTER_TO_UINT(g_hash_table_lookup(ORBit_class_assignments, repo_id));
+	retval = (clsid && tmp_vepv[clsid]);
+
+	_ORBIT_send_buffer = giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->connection, NULL,
+							_ORBIT_recv_buffer->message.u.request.request_id, ev->_major);
+	giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer), &retval, sizeof(retval));
+	giop_send_buffer_write(_ORBIT_send_buffer);
+	giop_send_buffer_unuse(_ORBIT_send_buffer);
+	freeca(tmp_vepv);
+}
+
+/* Section 4.2.4 */
+CORBA_boolean CORBA_Object_is_a(CORBA_Object obj, CORBA_char *logical_type_id, CORBA_Environment *ev)
+{
+	if(obj == CORBA_OBJECT_NIL)
+		return CORBA_FALSE;
+
+	if (obj->servant && obj->vepv) {
+		CORBA_unsigned_long clsid;
+
+		clsid = GPOINTER_TO_UINT(g_hash_table_lookup(ORBit_class_assignments, logical_type_id));
+
+		return (clsid && (clsid < obj->vepv_size) && obj->vepv[clsid]);
+	} else if(!strcmp(obj->object_id, logical_type_id)
+		  || !strcmp("IDL:CORBA/Object:1.0", logical_type_id)) {
+		return CORBA_TRUE;
+	} else {
+		/* Cut and paste from orbit-idl output */
+		/* XXX security implications */
+		GIOP_unsigned_long _ORBIT_request_id;
+		register GIOP_unsigned_long _ORBIT_system_exception_minor;
+		register CORBA_completion_status _ORBIT_completion_status;
+		register GIOPSendBuffer *_ORBIT_send_buffer;
+		register GIOPRecvBuffer *_ORBIT_recv_buffer;
+		register GIOPConnection *_cnx;
+
+		_cnx = ORBit_object_get_connection(obj);
+
+	_ORBIT_retry_request:
+		_ORBIT_send_buffer = NULL;
+		_ORBIT_recv_buffer = NULL;
+		_ORBIT_completion_status = CORBA_COMPLETED_NO;
+		/* A unique uint pointer is anything on the stack,
+		   so set this variable to point to its own address on the
+		   stack. :) */
+		_ORBIT_request_id = GPOINTER_TO_UINT(&_ORBIT_request_id);
+		{				/* marshalling */
+			static const struct {
+				CORBA_unsigned_long len;
+				char opname[6];
+			} _ORBIT_operation_name_data = {
+				6, "_is_a"
+			};
+			static const struct iovec _ORBIT_operation_vec =
+			{(gpointer) & _ORBIT_operation_name_data, 10};
+			register CORBA_unsigned_long _ORBIT_tmpvar_0;
+			CORBA_unsigned_long _ORBIT_tmpvar_1;
+
+			_ORBIT_send_buffer =
+				giop_send_request_buffer_use(_cnx, NULL, _ORBIT_request_id, CORBA_TRUE,
+							     &(obj->active_profile->object_key_vec), &_ORBIT_operation_vec, &ORBit_default_principal_iovec);
+
+			_ORBIT_system_exception_minor = ex_CORBA_COMM_FAILURE;
+			if (!_ORBIT_send_buffer)
+				goto _ORBIT_system_exception;
+			_ORBIT_tmpvar_1 = strlen(logical_type_id) + 1;
+			giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer), 4);
+			giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer), &(_ORBIT_tmpvar_1), sizeof(_ORBIT_tmpvar_1));
+			giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(_ORBIT_send_buffer), (logical_type_id), sizeof(logical_type_id[_ORBIT_tmpvar_0]) * _ORBIT_tmpvar_1);
+			giop_send_buffer_write(_ORBIT_send_buffer);
+			_ORBIT_completion_status = CORBA_COMPLETED_MAYBE;
+			giop_send_buffer_unuse(_ORBIT_send_buffer);
+			_ORBIT_send_buffer = NULL;
+		}
+		{				/* demarshalling */
+			register guchar *_ORBIT_curptr;
+			CORBA_boolean _ORBIT_retval;
+
+			_ORBIT_recv_buffer = giop_recv_reply_buffer_use_2(_cnx, _ORBIT_request_id, TRUE);
+			if (!_ORBIT_recv_buffer)
+				goto _ORBIT_system_exception;
+			_ORBIT_completion_status = CORBA_COMPLETED_YES;
+			if (_ORBIT_recv_buffer->message.u.reply.reply_status != GIOP_NO_EXCEPTION)
+				goto _ORBIT_msg_exception;
+			if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
+				_ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+				_ORBIT_retval = *((CORBA_boolean *) _ORBIT_curptr);
+			} else {
+				_ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
+				_ORBIT_retval = *((CORBA_boolean *) _ORBIT_curptr);
+			}
+			giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+			return _ORBIT_retval;
+		_ORBIT_system_exception:
+			CORBA_exception_set_system(ev, _ORBIT_system_exception_minor, _ORBIT_completion_status);
+			giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+			giop_send_buffer_unuse(_ORBIT_send_buffer);
+			return _ORBIT_retval;
+		_ORBIT_msg_exception:
+			if (_ORBIT_recv_buffer->message.u.reply.reply_status == GIOP_LOCATION_FORWARD) {
+				if (obj->forward_locations != NULL)
+					ORBit_delete_profiles(obj->forward_locations);
+				obj->forward_locations = ORBit_demarshal_IOR(_ORBIT_recv_buffer);
+				_cnx = ORBit_object_get_forwarded_connection(obj);
+				giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+
+				goto _ORBIT_retry_request;
+			} else {
+				ORBit_handle_exception(_ORBIT_recv_buffer, ev, NULL, obj->orb);
+				giop_recv_buffer_unuse(_ORBIT_recv_buffer);
+				return _ORBIT_retval;
+			}
+		}
+
+	}
+}
+
+/* Section 4.2.5 */
+#ifndef __KORBIT__
+static void do_exit(int signum) {
+  _exit(5);
+#warning "This should be removed... use BUG instead..."
+}
+#endif
+
+/* Lovely hack to try and figure out without hanging whether an object exists or not. */
+CORBA_boolean CORBA_Object_non_existent(CORBA_Object obj, CORBA_Environment *ev)
+{
+#ifndef __KORBIT__
+  int childpid, exitstatus, itmp;
+#endif
+
+  ev->_major = CORBA_NO_EXCEPTION;
+
+  if(obj == CORBA_OBJECT_NIL)
+	  return TRUE;
+
+  if(obj->servant)
+	  return FALSE;
+
+  if(obj->connection && obj->connection->is_valid)
+	  return FALSE;
+
+#ifndef __KORBIT__
+  childpid = fork();
+
+  if(!childpid) {
+	  GIOPConnection* cnx = NULL;
+	  struct sigaction sa;
+
+	  memset(&sa, 0, sizeof(sa));
+	  sa.sa_handler = do_exit;
+	  sigaction(SIGALRM, &sa, NULL);
+	  alarm(2);
+	  cnx = _ORBit_object_get_connection(obj);
+
+	  /* XXX todo - try invoking a strange operation on the object, and see what type of exception we get. */ 
+
+	  _exit((cnx == NULL)?1:0);
+  }
+
+  itmp = waitpid(childpid, &exitstatus, 0);
+
+  if(itmp < 0) return TRUE;
+  return WEXITSTATUS(exitstatus) && TRUE;
+#else /* __KORBIT__ */
+  return FALSE;
+#endif /* __KORBIT__ */
+}
+
+gboolean
+g_CORBA_Object_equal(CORBA_Object obj1, CORBA_Object obj2)
+{
+	gboolean retval;
+	CORBA_Environment ev;
+
+	CORBA_exception_init(&ev);
+
+	retval = (gboolean)CORBA_Object_is_equivalent(obj1, obj2, &ev);
+
+	CORBA_exception_free(&ev);
+
+	return retval;
+}
+
+/* Section 4.2.6 */
+CORBA_boolean CORBA_Object_is_equivalent(CORBA_Object obj, CORBA_Object other_object, CORBA_Environment *ev)
+{
+	ORBit_Object_info *obj_profile, *other_object_profile;
+	int i,j, obj_profile_count, other_object_profile_count;
+
+	if(obj == CORBA_OBJECT_NIL
+	   && other_object == CORBA_OBJECT_NIL)
+		return CORBA_TRUE;
+
+	if(obj == CORBA_OBJECT_NIL
+	   || other_object == CORBA_OBJECT_NIL)
+		goto ret_false;
+
+	/*
+	 * If one profile in "obj" matches one in "other_object", then these
+	 * objects are equivalent.
+	 *
+	 * This is O(n*m) at worst case :-( Hopefully though most objects will
+	 * only have 1 or 2 profiles.
+	 *
+	 * The profile list could be indexed as a hash table (the linked list
+	 * is still needed, as the profile order is significant)
+	 */
+
+	obj_profile_count = g_slist_length(obj->profile_list);
+	other_object_profile_count = g_slist_length(other_object->profile_list);
+
+	for(i=0;i<obj_profile_count;i++) {
+		obj_profile=(ORBit_Object_info *)g_slist_nth_data(obj->profile_list, i);
+
+		for(j=0;j<other_object_profile_count;j++) {
+			other_object_profile=(ORBit_Object_info *)g_slist_nth_data(other_object->profile_list, j);
+
+			if(obj_profile->profile_type != other_object_profile->profile_type)
+				continue;
+			
+			if(obj_profile->object_key._length != other_object_profile->object_key._length)
+				continue;
+
+			if(memcmp(obj_profile->object_key._buffer, other_object_profile->object_key._buffer, obj_profile->object_key._length))
+				continue;
+
+			if(obj_profile->profile_type == IOP_TAG_INTERNET_IOP) {
+				TAG_INTERNET_IOP_info *ii1, *ii2;
+
+				ii1 = &obj_profile->tag.iopinfo;
+				ii2 = &other_object_profile->tag.iopinfo;
+
+				if(ii1->port != ii2->port)
+					continue;
+				if(strcmp(ii1->host, ii2->host))
+					continue;
+
+				return(CORBA_TRUE);
+			} else if(obj_profile->profile_type == IOP_TAG_ORBIT_SPECIFIC) {
+				TAG_ORBIT_SPECIFIC_info *oi1, *oi2;
+
+				oi1 = &obj_profile->tag.orbitinfo;
+				oi2 = &other_object_profile->tag.orbitinfo;
+
+				if(strcmp(oi1->unix_sock_path, oi2->unix_sock_path))
+					continue;
+				if(oi1->ipv6_port != oi2->ipv6_port)
+					continue;
+
+				return(CORBA_TRUE);
+			}
+		}
+	}
+
+ ret_false:
+	return CORBA_FALSE;
+}
+
+guint
+g_CORBA_Object_hash(CORBA_Object obj)
+{
+	guint retval;
+	CORBA_Environment ev;
+
+	CORBA_exception_init(&ev);
+
+	retval = (guint)CORBA_Object_hash(obj, UINT_MAX, &ev);
+
+	CORBA_exception_free(&ev);
+
+	return retval;
+}
+
+static void profile_hash(gpointer item, gpointer data)
+{
+	ORBit_Object_info *info = (ORBit_Object_info *)item;
+	CORBA_unsigned_long *retval = (CORBA_unsigned_long *)data;
+
+	g_assert(info);
+	g_assert(retval);
+
+	*retval ^= info->object_key._length;
+
+	if(info->profile_type == IOP_TAG_INTERNET_IOP) {
+		*retval ^= !info->tag.iopinfo.port;
+	} else if(info->profile_type == IOP_TAG_ORBIT_SPECIFIC) {
+		*retval ^= g_str_hash(info->tag.orbitinfo.unix_sock_path);
+		*retval ^= !info->tag.orbitinfo.ipv6_port;
+	}
+}
+
+/* Section 4.2.6 */
+CORBA_unsigned_long CORBA_Object_hash(CORBA_Object obj,
+				      CORBA_unsigned_long maximum,
+				      CORBA_Environment *ev)
+{
+	CORBA_unsigned_long retval = 0;
+	char *tptr;
+
+	g_assert(obj);
+
+	tptr = obj->object_id;
+	while(*tptr) {
+		retval = (retval << 8) ^ *tptr;
+		tptr++;
+	}
+
+	if(g_slist_length(obj->profile_list)>0) {
+		g_slist_foreach(obj->profile_list, profile_hash, &retval);
+	} else {
+		g_warning("Object of type %s doesn't seem to have any connection info!", obj->object_id);
+	}
+
+	return (retval % maximum);
+}
+
+/* Section 4.2.7 */
+CORBA_Policy CORBA_Object_get_policy(CORBA_Object obj, CORBA_PolicyType policy_type, CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
diff -urN linux-2.4.1/net/korbit/orb/corba_object.h linux-2.4.1-korbit/net/korbit/orb/corba_object.h
--- linux-2.4.1/net/korbit/orb/corba_object.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_object.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,59 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_OBJECT_H_
+#define _ORBIT_CORBA_OBJECT_H_
+
+#include <ORBitutil/basic_types.h>
+
+#include "corba_env.h"
+#include "corba_orb.h"
+#include "corba_sequences.h"
+
+#define CORBA_OBJECT_NIL NULL
+
+typedef struct CORBA_Object_struct *CORBA_Object;
+
+#define CORBA_OBJECT(x) ((CORBA_Object)(x))
+
+/* Used for internal stuff mostly, but also good if you want to store
+   a hash of objects */
+gboolean g_CORBA_Object_equal(CORBA_Object obj1, CORBA_Object obj2);
+guint g_CORBA_Object_hash(CORBA_Object obj);
+
+void ORBit_impl_CORBA_Object_is_a(gpointer servant,
+				  GIOPRecvBuffer * _ORBIT_recv_buffer,
+				  CORBA_Environment *ev, gpointer dummy);
+#define ORBIT_IMPLEMENTS_IS_A
+
+extern CORBA_boolean CORBA_Object_is_a(
+	CORBA_Object obj,
+	CORBA_char *logical_type_id,
+	CORBA_Environment *ev);
+
+#endif /* !_ORBIT_CORBA_OBJECT_H_ */
+
+
+
diff -urN linux-2.4.1/net/korbit/orb/corba_object_type.h linux-2.4.1-korbit/net/korbit/orb/corba_object_type.h
--- linux-2.4.1/net/korbit/orb/corba_object_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_object_type.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_OBJECT_TYPE_H_
+#define _ORBIT_CORBA_OBJECT_TYPE_H_
+
+#include <sys/uio.h> /* for struct iovec */
+
+#include <IIOP/IIOP.h>	  /* for giop_connection */
+
+#include "corba_object.h"
+#include "corba_basic_sequences_type.h"
+
+#include "orbit_object_type.h"
+
+struct CORBA_Object_struct {
+	struct ORBit_RootObject_struct parent;
+	CORBA_ORB orb;
+	GIOPConnection *connection;
+	CORBA_char *object_id;
+	GSList *profile_list;
+	GSList *forward_locations;
+	ORBit_Object_info *active_profile;	/* points at a member of profile_list or forward_locations */
+
+	/* Used for direct calls */
+	gpointer *vepv;
+	/* PortableServer_Servant - looping includes :( */ gpointer servant;
+	guint vepv_size;
+};
+
+
+#endif /* !_ORBIT_CORBA_OBJECT_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_orb.h linux-2.4.1-korbit/net/korbit/orb/corba_orb.h
--- linux-2.4.1/net/korbit/orb/corba_orb.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_orb.h	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,48 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_ORB_H_
+#define _ORBIT_CORBA_ORB_H_
+
+typedef char *CORBA_ORB_ObjectId;
+
+#ifndef CORBA_POLICY_TYPE
+#define CORBA_POLICY_TYPE 1
+/* We need to define this in corba_orb_type.h as well, sometimes... */
+typedef struct CORBA_Policy_type *CORBA_Policy;
+#endif
+
+typedef CORBA_unsigned_long CORBA_PolicyType;
+
+typedef struct CORBA_ORB_type *CORBA_ORB;
+
+typedef struct CORBA_DomainManager_type *CORBA_DomainManager;
+
+typedef struct CORBA_ConstructionPolicy_type *CORBA_ConstructionPolicy;
+
+#define ex_CORBA_ORB_InvalidName "IDL:CORBA/ORB/InvalidName:1.0"
+
+#endif /* !_ORBIT_CORBA_ORB_H_ */
+
diff -urN linux-2.4.1/net/korbit/orb/corba_orb_type.h linux-2.4.1-korbit/net/korbit/orb/corba_orb_type.h
--- linux-2.4.1/net/korbit/orb/corba_orb_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_orb_type.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,77 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_ORB_TYPE_H_
+#define _ORBIT_CORBA_ORB_TYPE_H_
+
+#include "corba_object.h"
+
+struct CORBA_ORB_type {
+	struct ORBit_PseudoObject_struct parent;
+	CORBA_ORBid orb_identifier;
+	CORBA_RepositoryId repoid;
+	CORBA_boolean use_poa;
+
+	CORBA_Object imr, ir, naming, root_poa;
+	struct {
+		GIOPConnection *ipv4;
+		GIOPConnection *ipv6;
+		GIOPConnection *usock;
+	} cnx;
+
+	GHashTable *objrefs;
+
+	GPtrArray *poas;
+
+	CORBA_Context default_ctx;
+};
+
+#define CORBA_ORB_CAST(orb) ((CORBA_ORB)orb)
+
+typedef struct CORBA_ORB_InvalidName {
+	int dummy;
+} CORBA_ORB_InvalidName;
+
+struct CORBA_Policy_type {
+	struct ORBit_PseudoObject_struct parent;
+	CORBA_PolicyType policy_type;
+};
+#ifndef CORBA_POLICY_TYPE
+#define CORBA_POLICY_TYPE 1
+typedef struct CORBA_Policy_type *CORBA_Policy;
+#endif
+
+struct CORBA_DomainManager_type {
+	struct ORBit_PseudoObject_struct parent;
+};
+
+#define CORBA_SecConstruction (11)
+
+struct CORBA_ConstructionPolicy_type {
+	int fill_me_in;
+};
+
+
+#endif /* !_ORBIT_CORBA_ORB_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_portableserver.h linux-2.4.1-korbit/net/korbit/orb/corba_portableserver.h
--- linux-2.4.1/net/korbit/orb/corba_portableserver.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_portableserver.h	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,80 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_PORTABLESERVER_H_
+#define _ORBIT_CORBA_PORTABLESERVER_H_
+
+typedef struct PortableServer_ThreadPolicy_type *PortableServer_ThreadPolicy;
+typedef struct PortableServer_LifespanPolicy_type *PortableServer_LifespanPolicy;
+typedef struct PortableServer_IdUniquenessPolicy_type *PortableServer_IdUniquenessPolicy;
+typedef struct PortableServer_IdAssignmentPolicy_type *PortableServer_IdAssignmentPolicy;
+typedef struct PortableServer_ImplicitActivationPolicy_type *PortableServer_ImplicitActivationPolicy;
+typedef struct PortableServer_ServantRetentionPolicy_type *PortableServer_ServantRetentionPolicy;
+typedef struct PortableServer_RequestProcessingPolicy_type *PortableServer_RequestProcessingPolicy;
+typedef struct PortableServer_POAManager_type* PortableServer_POAManager;
+typedef struct PortableServer_AdapterActivator_type *PortableServer_AdapterActivator;
+typedef struct PortableServer_ServantManager_type *PortableServer_ServantManager;
+typedef struct PortableServer_ServantActivator_type *PortableServer_ServantActivator;
+typedef struct PortableServer_ServantLocator_type *PortableServer_ServantLocator;
+typedef struct PortableServer_POA_type *PortableServer_POA;
+typedef struct PortableServer_Current_type *PortableServer_Current;
+
+typedef enum {
+	PortableServer_ORB_CTRL_MODEL=0,
+	PortableServer_SINGLE_THREAD_MODEL
+} PortableServer_ThreadPolicyValue;
+
+typedef enum {
+	PortableServer_TRANSIENT=0,
+	PortableServer_PERSISTENT
+} PortableServer_LifespanPolicyValue;
+
+typedef enum {
+	PortableServer_UNIQUE_ID=0,
+	PortableServer_MULTIPLE_ID
+} PortableServer_IdUniquenessPolicyValue;
+
+typedef enum {
+	PortableServer_USER_ID=0,
+	PortableServer_SYSTEM_ID
+} PortableServer_IdAssignmentPolicyValue;
+
+typedef enum {
+	PortableServer_IMPLICIT_ACTIVATION=0,
+	PortableServer_NO_IMPLICIT_ACTIVATION
+} PortableServer_ImplicitActivationPolicyValue;
+
+typedef enum {
+	PortableServer_RETAIN=0,
+	PortableServer_NON_RETAIN
+} PortableServer_ServantRetentionPolicyValue;
+
+typedef enum {
+	PortableServer_USE_ACTIVE_OBJECT_MAP_ONLY=0,
+	PortableServer_USE_DEFAULT_SERVANT,
+	PortableServer_USE_SERVANT_MANAGER
+} PortableServer_RequestProcessingPolicyValue;
+
+#endif /* !_ORBIT_CORBA_PORTABLESERVER_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_portableserver_type.h linux-2.4.1-korbit/net/korbit/orb/corba_portableserver_type.h
--- linux-2.4.1/net/korbit/orb/corba_portableserver_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_portableserver_type.h	Thu Feb  1 11:47:11 2001
@@ -0,0 +1,361 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_PORTABLESERVER_TYPE_H_
+#define _ORBIT_CORBA_PORTABLESERVER_TYPE_H_
+
+/* 19.26 */
+
+typedef void *PortableServer_ServantLocator_Cookie;
+typedef void *PortableServer_Servant;
+
+#ifndef _PortableServer_ForwardRequest_defined
+#define _PortableServer_ForwardRequest_defined
+
+typedef struct PortableServer_ForwardRequest {
+   CORBA_Object forward_reference;
+} PortableServer_ForwardRequest;
+
+#define ex_PortableServer_ForwardRequest "IDL:PortableServer/ForwardRequest:1.0"
+#endif /* !_PortableServer_ForwardRequest_defined */
+
+#define PortableServer_THREAD_POLICY_ID 16
+struct PortableServer_ThreadPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_ThreadPolicyValue value;
+};
+
+#define PortableServer_LIFESPAN_POLICY_ID 17
+extern const CORBA_PolicyType PortableServer_LifespanPolicy_PolicyType;
+struct PortableServer_LifespanPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_LifespanPolicyValue value;
+};
+
+#define PortableServer_ID_UNIQUENESS_POLICY_ID 18
+struct PortableServer_IdUniquenessPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_IdUniquenessPolicyValue value;
+};
+
+#define PortableServer_ID_ASSIGNMENT_POLICY_ID 19
+struct PortableServer_IdAssignmentPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_IdAssignmentPolicyValue value;
+};
+
+#define PortableServer_IMPLICIT_ACTIVATION_POLICY_ID 20
+struct PortableServer_ImplicitActivationPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_ImplicitActivationPolicyValue value;
+};
+
+#define PortableServer_SERVANT_RETENTION_POLICY_ID 21
+struct PortableServer_ServantRetentionPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_ServantRetentionPolicyValue value;
+};
+
+#define PortableServer_REQUEST_PROCESSING_POLICY_ID 22
+struct PortableServer_RequestProcessingPolicy_type {
+	struct CORBA_Policy_type corba_policy;
+	PortableServer_RequestProcessingPolicyValue value;
+};
+
+#ifndef _PortableServer_POAManager_AdapterInactive_defined
+#define _PortableServer_POAManager_AdapterInactive_defined
+
+typedef struct PortableServer_POAManager_AdapterInactive {
+	int fill_me_in;
+} PortableServer_POAManager_AdapterInactive;
+
+#define ex_PortableServer_POAManager_AdapterInactive "IDL:PortableServer/POAManager/AdapterInactive:1.0"
+#endif /* !_PortableServer_POAManager_AdapterInactive_defined */
+
+typedef enum { PortableServer_POAManager_HOLDING,
+	       PortableServer_POAManager_ACTIVE,
+	       PortableServer_POAManager_DISCARDING,
+	       PortableServer_POAManager_INACTIVE
+} PortableServer_POAManager_State;
+
+struct PortableServer_POAManager_type {
+	struct ORBit_PseudoObject_struct parent;
+	GSList* poa_collection;
+	CORBA_ORB orb;
+	PortableServer_POAManager_State state;
+};
+
+struct PortableServer_AdapterActivator_type {
+	int fill_me_in;
+};
+
+struct PortableServer_ServantManager_type {
+	int fill_me_in;
+};
+
+#ifndef _PortableServer_POA_AdapterAlreadyExists_defined
+#define _PortableServer_POA_AdapterAlreadyExists_defined
+
+typedef struct PortableServer_POA_AdapterAlreadyExists {
+	int fill_me_in;
+} PortableServer_POA_AdapterAlreadyExists;
+
+#define ex_PortableServer_POA_AdapterAlreadyExists "IDL:PortableServer/POA/AdapterAlreadyExists:1.0"
+#endif /* !_PortableServer_POA_AdapterAlreadyExists_defined */
+
+#ifndef _PortableServer_POAManager_AdapterInactive_defined
+#define _PortableServer_POAManager_AdapterInactive_defined
+
+typedef struct PortableServer_POAManager_AdapterInactive {
+	int fill_me_in;
+} PortableServer_POAManager_AdapterInactive;
+
+#define ex_PortableServer_POAManager_AdapterInactive "IDL:PortableServer/POAManager/AdapterInactive:1.0"
+#endif /* !_PortableServer_POAManager_AdapterInactive_defined */
+
+#ifndef _PortableServer_POA_AdapterNonExistent_defined
+#define _PortableServer_POA_AdapterNonExistent_defined
+
+typedef struct PortableServer_POA_AdapterNonExistent {
+	int fill_me_in;
+} PortableServer_POA_AdapterNonExistent;
+
+#define ex_PortableServer_POA_AdapterNonExistent "IDL:PortableServer/POA/AdapterNonExistent:1.0"
+#endif /* !_PortableServer_POA_AdapterNonExistent_defined */
+
+#ifndef _PortableServer_POA_InvalidPolicy_defined
+#define _PortableServer_POA_InvalidPolicy_defined
+
+typedef struct PortableServer_POA_InvalidPolicy {
+   CORBA_unsigned_short index;
+} PortableServer_POA_InvalidPolicy;
+
+#define ex_PortableServer_POA_InvalidPolicy "IDL:PortableServer/POA/InvalidPolicy:1.0"
+#endif /* !_PortableServer_POA_InvalidPolicy_defined */
+
+#ifndef _PortableServer_POA_NoServant_defined
+#define _PortableServer_POA_NoServant_defined
+
+typedef struct PortableServer_POA_NoServant {
+	int fill_me_in;
+} PortableServer_POA_NoServant;
+
+#define ex_PortableServer_POA_NoServant "IDL:PortableServer/POA/NoServant:1.0"
+#endif /* !_PortableServer_POA_NoServant_defined */
+
+#ifndef _PortableServer_POA_ObjectAlreadyActive_defined
+#define _PortableServer_POA_ObjectAlreadyActive_defined
+
+typedef struct PortableServer_POA_ObjectAlreadyActive {
+	int fill_me_in;
+} PortableServer_POA_ObjectAlreadyActive;
+
+#define ex_PortableServer_POA_ObjectAlreadyActive "IDL:PortableServer/POA/ObjectAlreadyActive:1.0"
+#endif /* !_PortableServer_POA_ObjectAlreadyActive_defined */
+
+#ifndef _PortableServer_POA_ObjectNotActive_defined
+#define _PortableServer_POA_ObjectNotActive_defined
+
+typedef struct PortableServer_POA_ObjectNotActive {
+	int fill_me_in;
+} PortableServer_POA_ObjectNotActive;
+
+#define ex_PortableServer_POA_ObjectNotActive "IDL:PortableServer/POA/ObjectNotActive:1.0"
+#endif /* !_PortableServer_POA_ObjectNotActive_defined */
+
+#ifndef _PortableServer_POA_ServantAlreadyActive_defined
+#define _PortableServer_POA_ServantAlreadyActive_defined
+
+typedef struct PortableServer_POA_ServantAlreadyActive {
+	int fill_me_in;
+} PortableServer_POA_ServantAlreadyActive;
+
+#define ex_PortableServer_POA_ServantAlreadyActive "IDL:PortableServer/POA/ServantAlreadyActive:1.0"
+#endif /* !_PortableServer_POA_ServantAlreadyActive_defined */
+
+#ifndef _PortableServer_POA_ServantNotActive_defined
+#define _PortableServer_POA_ServantNotActive_defined
+
+typedef struct PortableServer_POA_ServantNotActive {
+	int fill_me_in;
+} PortableServer_POA_ServantNotActive;
+
+#define ex_PortableServer_POA_ServantNotActive "IDL:PortableServer/POA/ServantNotActive:1.0"
+#endif /* !_PortableServer_POA_ServantNotActive_defined */
+
+#ifndef _PortableServer_POA_WrongAdapter_defined
+#define _PortableServer_POA_WrongAdapter_defined
+
+typedef struct PortableServer_POA_WrongAdapter {
+	int fill_me_in;
+} PortableServer_POA_WrongAdapter;
+
+#define ex_PortableServer_POA_WrongAdapter "IDL:PortableServer/POA/WrongAdapter:1.0"
+#endif /* !_PortableServer_POA_WrongAdapter_defined */
+
+#ifndef _PortableServer_POA_WrongPolicy_defined
+#define _PortableServer_POA_WrongPolicy_defined
+
+typedef struct PortableServer_POA_WrongPolicy {
+	int fill_me_in;
+} PortableServer_POA_WrongPolicy;
+
+#define ex_PortableServer_POA_WrongPolicy "IDL:PortableServer/POA/WrongPolicy:1.0"
+#endif /* !_PortableServer_POA_WrongPolicy_defined */
+
+#ifndef _PortableServer_Current_NoContext_defined
+#define _PortableServer_Current_NoContext_defined
+
+typedef struct PortableServer_Current_NoContext {
+	int fill_me_in;
+} PortableServer_Current_NoContext;
+
+#define ex_PortableServer_Current_NoContext "IDL:PortableServer/Current/NoContext:1.0"
+#endif /* !_PortableServer_Current_NoContext_defined */
+
+struct PortableServer_Current_type {
+	int fill_me_in;
+};
+
+typedef struct PortableServer_ServantBase__epv {
+	void *_private;
+	void (*finalize)(PortableServer_Servant, CORBA_Environment *);
+	PortableServer_POA (*default_POA)(PortableServer_Servant, CORBA_Environment *);
+} PortableServer_ServantBase__epv;
+
+typedef PortableServer_ServantBase__epv *PortableServer_ServantBase__vepv;
+
+typedef struct PortableServer_ServantBase {
+	void *_private;
+	PortableServer_ServantBase__vepv *vepv;
+} PortableServer_ServantBase;
+
+/* 19.27 */
+
+typedef void (*PortableServer_DynamicImplRoutine) (PortableServer_Servant servant, CORBA_ServerRequest request);
+
+typedef struct PortableServer_DynamicImpl__epv {
+	void *_private;
+	PortableServer_DynamicImplRoutine invoke;
+	CORBA_RepositoryId (*primary_interface) (PortableServer_Servant svt, PortableServer_ObjectId id, PortableServer_POA poa, CORBA_Environment *env);
+} PortableServer_DynamicImpl__epv;
+
+typedef struct PortableServer_DynamicImpl__vepv {
+	PortableServer_ServantBase__epv *_base_epv;
+	PortableServer_DynamicImpl__epv *PortableServer_DynamicImpl_epv;
+} PortableServer_DynamicImpl__vepv;
+
+typedef struct PortableServer_DynamicImpl {
+	void *_private;
+	PortableServer_DynamicImpl__vepv *vepv;
+} PortableServer_DynamicImpl;
+
+typedef struct {
+   void *_private;
+} POA_PortableServer_ServantManager__epv;
+
+typedef struct {
+	void *_private;
+
+	PortableServer_Servant (*incarnate) (PortableServer_Servant servant,
+					     PortableServer_ObjectId * oid,
+					     PortableServer_POA adapter,
+					     CORBA_Environment * ev);
+
+	void (*etherealize) (PortableServer_Servant servant,
+			     PortableServer_ObjectId* oid,
+			     PortableServer_POA adapter,
+			     PortableServer_Servant serv,
+			     CORBA_boolean cleanup_in_progress,
+			     CORBA_boolean remaining_activations,
+			     CORBA_Environment * ev);
+
+} POA_PortableServer_ServantActivator__epv;
+
+typedef struct {
+   PortableServer_ServantBase__epv *_base_epv;
+   POA_PortableServer_ServantManager__epv *PortableServer_ServantManager_epv;
+   POA_PortableServer_ServantActivator__epv *PortableServer_ServantActivator_epv;
+} POA_PortableServer_ServantActivator__vepv;
+
+typedef struct {
+   void *_private;
+   POA_PortableServer_ServantActivator__vepv *vepv;
+} POA_PortableServer_ServantActivator;
+
+extern void
+POA_PortableServer_ServantActivator__init(PortableServer_Servant servant,
+					  CORBA_Environment * ev);
+extern void
+POA_PortableServer_ServantActivator__fini(PortableServer_Servant servant,
+					  CORBA_Environment * ev);
+
+typedef struct {
+	void *_private;
+
+	PortableServer_Servant (*preinvoke) (PortableServer_Servant servant,
+					     PortableServer_ObjectId * oid,
+					     PortableServer_POA adapter,
+					     CORBA_Identifier operation,
+					     PortableServer_ServantLocator_Cookie *the_cookie,
+					     CORBA_Environment * ev);
+
+	void (*postinvoke) (PortableServer_Servant servant,
+			    PortableServer_ObjectId * oid,
+			    PortableServer_POA adapter,
+			    CORBA_Identifier operation,
+			    PortableServer_ServantLocator_Cookie the_cookie,
+			    PortableServer_Servant the_servant,
+			    CORBA_Environment * ev);
+} POA_PortableServer_ServantLocator__epv;
+
+typedef struct {
+   PortableServer_ServantBase__epv *_base_epv;
+   POA_PortableServer_ServantManager__epv *PortableServer_ServantManager_epv;
+   POA_PortableServer_ServantLocator__epv *PortableServer_ServantLocator_epv;
+} POA_PortableServer_ServantLocator__vepv;
+
+typedef struct {
+   void *_private;
+   POA_PortableServer_ServantLocator__vepv *vepv;
+} POA_PortableServer_ServantLocator;
+
+extern void
+POA_PortableServer_ServantLocator__init(PortableServer_Servant servant,
+					CORBA_Environment * ev);
+extern void
+POA_PortableServer_ServantLocator__fini(PortableServer_Servant servant,
+					CORBA_Environment * ev);
+
+struct CORBA_ServerRequest_type {
+	struct ORBit_PseudoObject_struct parent;
+	GIOPRecvBuffer *rbuf;
+	GIOPSendBuffer *sbuf;
+	CORBA_NVList *params;
+	CORBA_ORB orb;
+	guchar did_ctx, did_exc;
+};
+
+#endif /* !_ORBIT_CORBA_PORTABLESERVER_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_sequences.h linux-2.4.1-korbit/net/korbit/orb/corba_sequences.h
--- linux-2.4.1/net/korbit/orb/corba_sequences.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_sequences.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,74 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_SEQUENCES_H_
+#define _ORBIT_CORBA_SEQUENCES_H_
+
+
+/* moved from sequences.h */
+#include "corba_basic_sequences_type.h"
+
+typedef CORBA_sequence_octet CORBA_ReferenceData;
+
+#define _CORBA_sequence_ServiceOption_defined
+typedef struct CORBA_sequence_ServiceOption CORBA_sequence_ServiceOption;
+
+#define _CORBA_sequence_ServiceDetail_defined
+typedef struct CORBA_sequence_ServiceDetail CORBA_sequence_ServiceDetail;
+
+#define _CORBA_sequence_ORB_ObjectId_defined
+typedef struct CORBA_sequence_ORB_ObjectId CORBA_ORB_ObjectIdList;
+
+#define _CORBA_sequence_NameValuePair_defined
+typedef struct CORBA_sequence_NameValuePair CORBA_NameValuePairSeq;
+
+#define _CORBA_sequence_CORBA_any_defined
+typedef struct CORBA_sequence_CORBA_any_struct CORBA_AnySeq;
+typedef struct CORBA_sequence_CORBA_any_struct CORBA_sequence_CORBA_any;
+
+#define _CORBA_sequence_Policy_defined
+typedef struct CORBA_sequence_Policy CORBA_PolicyList;
+
+#define _CORBA_sequence_DomainManager_defined
+typedef struct CORBA_sequence_DomainManager CORBA_DomainManagerList;
+
+#define _PortableServer_sequence_octet_defined
+typedef struct PortableServer_sequence_octet PortableServer_ObjectId;
+
+
+/* Moved from orbit_types.h */
+#ifndef HAVE_CORBA_PRINCIPAL
+#define HAVE_CORBA_PRINCIPAL 1
+typedef CORBA_sequence_octet CORBA_Principal;
+#endif
+typedef CORBA_sequence_octet CORBA_DynAny_OctetSeq;
+typedef CORBA_sequence_octet CORBA_DynFixed_OctetSeq;
+typedef CORBA_sequence_octet CORBA_DynEnum_OctetSeq;
+typedef CORBA_sequence_octet CORBA_DynStruct_OctetSeq;
+typedef CORBA_sequence_octet CORBA_DynUnion_OctetSeq;
+typedef CORBA_sequence_octet CORBA_DynSequence_OctetSeq;
+typedef CORBA_sequence_octet CORBA_DynArray_OctetSeq;
+
+#endif /* !_ORBIT_CORBA_SEQUENCES_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_sequences_type.h linux-2.4.1-korbit/net/korbit/orb/corba_sequences_type.h
--- linux-2.4.1/net/korbit/orb/corba_sequences_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_sequences_type.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,98 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_SEQUENCES_TYPE_H_
+#define _ORBIT_CORBA_SEQUENCES_TYPE_H_
+
+#include "corba_sequences.h"
+
+struct CORBA_sequence_ServiceOption {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_ServiceOption *_buffer;
+	CORBA_boolean _release;
+};
+
+struct CORBA_sequence_ServiceDetail {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_ServiceDetail *_buffer;
+	CORBA_boolean _release;
+};
+
+struct CORBA_sequence_ORB_ObjectId {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_ORB_ObjectId *_buffer;  
+	CORBA_boolean _release;
+};
+
+struct CORBA_sequence_NameValuePair {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	struct CORBA_NameValuePair *_buffer;
+	CORBA_boolean _release;
+};
+
+struct CORBA_sequence_CORBA_any_struct {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_any *_buffer;
+	CORBA_boolean _release;
+};
+
+struct CORBA_sequence_Policy {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_Policy *_buffer;
+	CORBA_boolean _release;
+};
+
+struct CORBA_sequence_DomainManager {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_DomainManager *_buffer;
+	CORBA_boolean _release;
+};
+
+struct PortableServer_sequence_octet {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CORBA_octet *_buffer;
+	CORBA_boolean _release;
+};
+
+/* Generic sequence */
+struct CORBA_Sequence_type {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	void *_buffer;
+	CORBA_boolean _release;
+};
+
+#define CORBA_SEQFLAGS_RELEASE 1
+
+
+#endif /* !_ORBIT_CORBA_SEQUENCES_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/corba_typecode.h linux-2.4.1-korbit/net/korbit/orb/corba_typecode.h
--- linux-2.4.1/net/korbit/orb/corba_typecode.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_typecode.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,167 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_TYPECODE_H_
+#define _ORBIT_CORBA_TYPECODE_H_
+
+/* moved from orbit_types.h */
+typedef struct CORBA_TypeCode_struct *CORBA_TypeCode;
+
+typedef enum {
+	CORBA_tk_null=0,
+	CORBA_tk_void=1,
+	CORBA_tk_short=2,
+	CORBA_tk_long=3,
+	CORBA_tk_ushort=4,
+	CORBA_tk_ulong=5,
+	CORBA_tk_float=6,
+	CORBA_tk_double=7,
+	CORBA_tk_boolean=8,
+	CORBA_tk_char=9,
+	CORBA_tk_octet=10,
+	CORBA_tk_any=11,
+	CORBA_tk_TypeCode=12,
+	CORBA_tk_Principal=13,
+	CORBA_tk_objref=14,
+ 	CORBA_tk_struct=15,
+	CORBA_tk_union=16,
+	CORBA_tk_enum=17,
+	CORBA_tk_string=18,
+	CORBA_tk_sequence=19,
+	CORBA_tk_array=20,
+	CORBA_tk_alias=21,
+	CORBA_tk_except=22,
+	CORBA_tk_longlong=23,
+	CORBA_tk_ulonglong=24,
+	CORBA_tk_longdouble=25,
+	CORBA_tk_wchar=26,
+	CORBA_tk_wstring=27,
+	CORBA_tk_fixed=28,
+	CORBA_tk_recursive=0xffffffff,
+	CORBA_tk_last=29	/* hack for GIOP */
+} CORBA_TCKind;
+
+#define TC_CORBA_short TC_short
+#define TC_CORBA_long TC_long
+#define TC_CORBA_longlong TC_longlong
+#define TC_CORBA_long_long TC_longlong
+#define TC_CORBA_ushort TC_ushort
+#define TC_CORBA_unsigned_short TC_ushort
+#define TC_CORBA_ulong TC_ulong
+#define TC_CORBA_unsigned_long TC_ulong
+#define TC_CORBA_ulonglong TC_ulonglong
+#define TC_CORBA_unsigned_long_long TC_ulonglong
+#define TC_CORBA_float TC_float
+#define TC_CORBA_double TC_double
+#define TC_CORBA_longdouble TC_longdouble
+#define TC_CORBA_long_double TC_longdouble
+#define TC_CORBA_boolean TC_boolean
+#define TC_CORBA_char TC_char
+#define TC_CORBA_wchar TC_wchar
+#define TC_CORBA_octet TC_octet
+#define TC_CORBA_any TC_any
+#define TC_CORBA_TypeCode TC_TypeCode
+#define TC_CORBA_Principal TC_Principal
+#define TC_CORBA_Object TC_Object
+#define TC_CORBA_string TC_string
+#define TC_CORBA_wstring TC_wstring
+
+#define TC_null ((CORBA_TypeCode)&TC_null_struct)
+#define TC_void ((CORBA_TypeCode)&TC_void_struct)
+#define TC_short ((CORBA_TypeCode)&TC_short_struct)
+#define TC_long ((CORBA_TypeCode)&TC_long_struct)
+#define TC_longlong ((CORBA_TypeCode)&TC_longlong_struct)
+#define TC_ushort ((CORBA_TypeCode)&TC_ushort_struct)
+#define TC_ulong ((CORBA_TypeCode)&TC_ulong_struct)
+#define TC_ulonglong ((CORBA_TypeCode)&TC_ulonglong_struct)
+#define TC_float ((CORBA_TypeCode)&TC_float_struct)
+#define TC_double ((CORBA_TypeCode)&TC_double_struct)
+#define TC_longdouble ((CORBA_TypeCode)&TC_longdouble_struct)
+#define TC_boolean ((CORBA_TypeCode)&TC_boolean_struct)
+#define TC_char ((CORBA_TypeCode)&TC_char_struct)
+#define TC_wchar ((CORBA_TypeCode)&TC_wchar_struct)
+#define TC_octet ((CORBA_TypeCode)&TC_octet_struct)
+#define TC_any ((CORBA_TypeCode)&TC_any_struct)
+#define TC_TypeCode ((CORBA_TypeCode)&TC_TypeCode_struct)
+#define TC_Principal ((CORBA_TypeCode)&TC_Principal_struct)
+#define TC_Object ((CORBA_TypeCode)&TC_Object_struct)
+#define TC_string ((CORBA_TypeCode)&TC_string_struct)
+#define TC_wstring ((CORBA_TypeCode)&TC_wstring_struct)
+#define TC_CORBA_NamedValue ((CORBA_TypeCode)&TC_CORBA_NamedValue_struct)
+
+#define TC_CORBA_short_struct TC_short_struct
+#define TC_CORBA_long_struct TC_long_struct
+#define TC_CORBA_longlong_struct TC_longlong_struct
+#define TC_CORBA_long_long_struct TC_longlong_struct
+#define TC_CORBA_ushort_struct TC_ushort_struct
+#define TC_CORBA_unsigned_short_struct TC_ushort_struct
+#define TC_CORBA_ulong_struct TC_ulong_struct
+#define TC_CORBA_unsigned_long_struct TC_ulong_struct
+#define TC_CORBA_ulonglong_struct TC_ulonglong_struct
+#define TC_CORBA_unsigned_long_long_struct TC_ulonglong_struct
+#define TC_CORBA_float_struct TC_float_struct
+#define TC_CORBA_double_struct TC_double_struct
+#define TC_CORBA_longdouble_struct TC_longdouble_struct
+#define TC_CORBA_long_double_struct TC_longdouble_struct
+#define TC_CORBA_boolean_struct TC_boolean_struct
+#define TC_CORBA_char_struct TC_char_struct
+#define TC_CORBA_wchar_struct TC_wchar_struct
+#define TC_CORBA_octet_struct TC_octet_struct
+#define TC_CORBA_any_struct TC_any_struct
+#define TC_CORBA_TypeCode_struct TC_TypeCode_struct
+#define TC_CORBA_Principal_struct TC_Principal_struct
+#define TC_CORBA_Object_struct TC_Object_struct
+#define TC_CORBA_string_struct TC_string_struct
+#define TC_CORBA_wstring_struct TC_wstring_struct
+
+extern const struct CORBA_TypeCode_struct TC_null_struct;
+extern const struct CORBA_TypeCode_struct TC_void_struct;
+extern const struct CORBA_TypeCode_struct TC_short_struct;
+extern const struct CORBA_TypeCode_struct TC_long_struct;
+extern const struct CORBA_TypeCode_struct TC_longlong_struct;
+extern const struct CORBA_TypeCode_struct TC_ushort_struct;
+extern const struct CORBA_TypeCode_struct TC_ulong_struct;
+extern const struct CORBA_TypeCode_struct TC_ulonglong_struct;
+extern const struct CORBA_TypeCode_struct TC_float_struct;
+extern const struct CORBA_TypeCode_struct TC_double_struct;
+extern const struct CORBA_TypeCode_struct TC_longdouble_struct;
+extern const struct CORBA_TypeCode_struct TC_boolean_struct;
+extern const struct CORBA_TypeCode_struct TC_char_struct;
+extern const struct CORBA_TypeCode_struct TC_wchar_struct;
+extern const struct CORBA_TypeCode_struct TC_octet_struct;
+extern const struct CORBA_TypeCode_struct TC_any_struct;
+extern const struct CORBA_TypeCode_struct TC_TypeCode_struct;
+extern const struct CORBA_TypeCode_struct TC_Principal_struct;
+extern const struct CORBA_TypeCode_struct TC_Object_struct;
+extern const struct CORBA_TypeCode_struct TC_string_struct;
+extern const struct CORBA_TypeCode_struct TC_wstring_struct;
+extern const struct CORBA_TypeCode_struct TC_CORBA_NamedValue_struct;
+
+
+#endif /* !_ORBIT_CORBA_TYPECODE_H_ */
+
+
+
+
diff -urN linux-2.4.1/net/korbit/orb/corba_typecode_type.h linux-2.4.1-korbit/net/korbit/orb/corba_typecode_type.h
--- linux-2.4.1/net/korbit/orb/corba_typecode_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/corba_typecode_type.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,66 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_CORBA_TYPECODE_TYPE_H_
+#define _ORBIT_CORBA_TYPECODE_TYPE_H_
+
+#include <ORBitutil/basic_types.h>
+#include "corba_typecode.h"
+#include "corba_any.h"
+
+typedef struct CORBA_TypeCode_Bounds {
+	int dummy;
+} CORBA_TypeCode_Bounds;
+
+typedef struct CORBA_TypeCode_BadKind {
+	int dummy;
+} CORBA_TypeCode_BadKind;
+
+struct CORBA_TypeCode_struct {
+	struct ORBit_PseudoObject_struct parent;
+	CORBA_TCKind kind;
+#ifndef __KORBIT__
+	const
+#endif
+	char *name;
+#ifndef __KORBIT__
+	const 
+#endif
+	char *repo_id;
+	CORBA_unsigned_long length;
+	CORBA_unsigned_long sub_parts;
+	const char **subnames;		/* for struct, exception, union, enum */
+	CORBA_TypeCode *subtypes;	/* for struct, exception, union, alias, array, sequence */
+	CORBA_any *sublabels;		/* for union */
+	CORBA_TypeCode discriminator;	/* for union */
+	CORBA_unsigned_long recurse_depth; /* for recursive sequence */
+	CORBA_long default_index;	/* for union */
+	CORBA_unsigned_short digits; /* for fixed */
+	CORBA_short scale;	     /* for fixed */
+};
+
+
+#endif /* !_ORBIT_CORBA_TYPECODE_TYPE_H_ */
+
diff -urN linux-2.4.1/net/korbit/orb/dii.c linux-2.4.1-korbit/net/korbit/orb/dii.c
--- linux-2.4.1/net/korbit/orb/dii.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/dii.c	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,454 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Red Hat Software, Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Elliot Lee <sopwith@redhat.com>
+ *          Dick Porter <dick@cymru.net>
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "orbit.h"
+#ifndef __KORBIT__
+#include "interface_repository.h"
+#endif /* !__KORBIT__ */
+
+struct CORBA_Request_type {
+	struct ORBit_PseudoObject_struct parent;
+
+	CORBA_Object obj;
+	CORBA_Context ctx;
+
+	CORBA_Flags req_flags;
+	CORBA_Identifier operation;
+
+	CORBA_NamedValue *result;
+	CORBA_NVList *arg_list;
+
+	CORBA_unsigned_long request_id;
+	GIOPSendBuffer *request_buffer;
+	GIOPRecvBuffer *reply_buffer;
+};
+
+static const ORBit_RootObject_Interface interface_CORBA_Request = {
+	(void (*)(gpointer,CORBA_Environment *))CORBA_Request_delete
+};
+
+/* Section 5.2.1 */
+CORBA_Status
+CORBA_Object_create_request(CORBA_Object obj,
+							CORBA_Context ctx,
+							CORBA_Identifier operation,
+							CORBA_NVList *arg_list,
+							CORBA_NamedValue *result,
+							CORBA_Request *request,
+							CORBA_Flags req_flags,
+							CORBA_Environment *ev)
+{
+	CORBA_Request new;
+
+	new=g_new0(struct CORBA_Request_type, 1);
+	ORBit_pseudo_object_init((ORBit_PseudoObject)new, ORBIT_PSEUDO_REQUEST, ev);
+	ORBit_RootObject_set_interface((ORBit_RootObject)new,
+								   (ORBit_RootObject_Interface *)&interface_CORBA_Request, ev);
+
+	if(new==NULL) {
+		CORBA_exception_set_system(ev,
+								   ex_CORBA_NO_MEMORY,
+								   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	new->obj=CORBA_Object_duplicate(obj, ev);
+	new->ctx=(CORBA_Context)CORBA_Object_duplicate((CORBA_Object)ctx, ev);
+	new->operation=CORBA_string_dup(operation);
+
+	new->result=result;
+
+	new->req_flags=req_flags;
+	new->request_id = giop_get_request_id();
+	new->arg_list = arg_list;
+
+	*request=(CORBA_Request)CORBA_Object_duplicate((CORBA_Object)new, ev);
+}
+
+/* Section 5.2, 5.2.2 */
+CORBA_Status
+CORBA_Request_add_arg(CORBA_Request req,
+					  CORBA_Identifier name,
+					  CORBA_TypeCode arg_type,
+					  void *value,
+					  CORBA_long len,
+					  CORBA_Flags arg_flags,
+					  CORBA_Environment *ev)
+{
+	gpointer new_value;
+
+	g_assert(req!=NULL);
+
+	if((arg_flags & CORBA_IN_COPY_VALUE) && (arg_flags & CORBA_ARG_IN)) {
+		new_value = ORBit_copy_value(value, arg_type);
+		if(new_value==NULL) {
+			CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY,
+									   CORBA_COMPLETED_NO);
+			return;
+		}
+	} else
+		new_value=value;
+
+	CORBA_NVList_add_item(req->arg_list, name, arg_type,
+						  new_value, len, arg_flags | req->req_flags, ev);
+}
+
+/* Section 5.2, 5.2.3 */
+CORBA_Status
+CORBA_Request_invoke(CORBA_Request req,
+					 CORBA_Flags invoke_flags,
+					 CORBA_Environment *ev)
+{
+	CORBA_Request_send(req, invoke_flags, ev);
+	if(ev->_major == CORBA_NO_EXCEPTION)
+		CORBA_Request_get_response(req, invoke_flags, ev);
+}
+
+/* Section 5.2, 5.2.4 */
+CORBA_Status CORBA_Request_delete(CORBA_Request req, CORBA_Environment *ev)
+{
+	CORBA_Object_release(req->obj, ev);
+	CORBA_Object_release((CORBA_Object)req->ctx, ev);
+
+	if(req->operation != NULL)
+		CORBA_free(req->operation);
+
+	if(req->arg_list != NULL) {
+		if(req->req_flags & CORBA_OUT_LIST_MEMORY)
+			CORBA_NVList_free(req->arg_list, ev);
+		else {
+			int i;
+			for(i = 0; i < req->arg_list->list->len; i++)
+				ORBit_NamedValue_free(&g_array_index(req->arg_list->list,
+													 CORBA_NamedValue, i));
+			g_array_free(req->arg_list->list, TRUE);
+			
+			g_free(req->arg_list);
+		}
+	}
+
+	if(req->result!=NULL)
+		ORBit_NamedValue_free(req->result);
+
+	if(req->request_buffer)
+		giop_send_buffer_unuse(req->request_buffer);
+
+	if(req->reply_buffer)
+		giop_recv_buffer_unuse(req->reply_buffer);
+
+	g_free(req);
+}
+
+/* Section 5.2, 5.3.1 */
+CORBA_Status
+CORBA_Request_send(CORBA_Request req,
+				   CORBA_Flags invoke_flags,
+				   CORBA_Environment *ev)
+{
+	int i;
+	GIOPConnection *cnx;
+
+	struct { CORBA_unsigned_long opstrlen; char opname[1]; } *opnameinfo;
+	struct iovec opvec = { NULL, 0 };
+
+	opvec.iov_len = strlen(req->operation)+1+sizeof(CORBA_unsigned_long);
+
+	opnameinfo = g_malloc(strlen(req->operation)+1+sizeof(CORBA_unsigned_long));
+	opvec.iov_base = (gpointer)opnameinfo;
+	opnameinfo->opstrlen = strlen(req->operation) + 1;
+	strcpy(opnameinfo->opname, req->operation);
+
+	cnx = ORBit_object_get_connection(req->obj);
+
+	g_assert(req->obj->active_profile);
+	req->request_buffer =
+		giop_send_request_buffer_use(req->obj->connection,
+									 NULL,
+									 req->request_id,
+									 req->result?TRUE:FALSE,
+									 &(req->obj->active_profile->object_key_vec),
+									 &opvec,
+									 &ORBit_default_principal_iovec
+									 );
+
+	if(!req->request_buffer) {
+		CORBA_exception_set_system(ev,
+								   ex_CORBA_COMM_FAILURE,
+								   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	for(i = 0; i < req->arg_list->list->len; i++) {
+		CORBA_NamedValue *nv;
+
+		nv = &g_array_index(req->arg_list->list, CORBA_NamedValue, i); 
+
+		if((nv->arg_modes & CORBA_ARG_IN)
+		   || (nv->arg_modes & CORBA_ARG_INOUT))
+			ORBit_marshal_arg(req->request_buffer, 
+							  nv->argument._value,
+							  nv->argument._type);
+	}
+				      
+	giop_send_buffer_write(req->request_buffer);
+
+	giop_send_buffer_unuse(req->request_buffer);
+	req->request_buffer = 0;
+
+	g_free(opnameinfo);
+}
+
+/* Section 5.3.2 */
+CORBA_Status
+CORBA_send_multiple_requests(CORBA_Request *reqs,
+							 CORBA_Environment *env,
+							 CORBA_long count,
+							 CORBA_Flags invoke_flags)
+{
+	int i;
+
+	for(i = 0; i < count; i++)
+		CORBA_Request_send(reqs[i], invoke_flags, env);	
+}
+
+void
+ORBit_handle_dii_reply(CORBA_Request req, CORBA_Environment *ev)
+{
+	int i;
+
+	/* XXX TODO - handle exceptions, location forwards(?), all that */
+	req->result->argument._value =
+		ORBit_demarshal_arg(req->reply_buffer, req->result->argument._type,
+							TRUE, req->obj->orb);
+	req->result->argument._release = CORBA_TRUE;
+	
+	for(i = 0; i < req->arg_list->list->len; i++) {
+		CORBA_NamedValue *nv;
+
+		nv = &g_array_index(req->arg_list->list, CORBA_NamedValue, i); 
+
+		if(nv->arg_modes & CORBA_ARG_INOUT) {
+			CORBA_Object_duplicate((CORBA_Object)nv->argument._type, NULL);
+			CORBA_any__free(&nv->argument, NULL, TRUE);
+		}
+
+		if((nv->arg_modes & CORBA_ARG_OUT)
+		   || (nv->arg_modes & CORBA_ARG_INOUT))
+			nv->argument._value = ORBit_demarshal_arg(req->reply_buffer,
+													  nv->argument._type,
+													  TRUE, req->obj->orb);
+	}
+
+	giop_recv_buffer_unuse(req->reply_buffer);
+	req->reply_buffer = 0;
+}
+
+/* Section 5.2, 5.3.3
+ *
+ * Raises: WrongTransaction
+ */
+CORBA_Status
+CORBA_Request_get_response(CORBA_Request req,
+						   CORBA_Flags response_flags,
+						   CORBA_Environment *ev)
+{
+	req->reply_buffer = giop_recv_reply_buffer_use(req->request_id,
+												   !(response_flags & CORBA_RESP_NO_WAIT));
+
+	if(!req->reply_buffer) {
+		CORBA_exception_set_system(ev,
+								   ex_CORBA_COMM_FAILURE,
+								   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	ORBit_handle_dii_reply(req, ev);
+}
+
+/* Section 5.3.4
+ *
+ * Raises: WrongTransaction
+ */
+CORBA_Status
+CORBA_Request_get_next_response(CORBA_Environment *env,
+								CORBA_Flags response_flags,
+								CORBA_Request *req)
+{
+	int i;
+	GIOPRecvBuffer *rb;
+	GArray *reqids = g_array_new(FALSE, FALSE,
+								 sizeof(CORBA_unsigned_long));
+
+	for(i = 0; req[i]; i++) {
+		g_array_append_val(reqids, req[i]->request_id);
+	}
+
+	rb = giop_recv_reply_buffer_use_multiple(reqids,
+											 !(response_flags & CORBA_RESP_NO_WAIT));
+
+	if(rb) {
+		for(i = 0; i < reqids->len; i++) {
+			if(g_array_index(reqids, CORBA_unsigned_long, i)
+			   == rb->message.u.reply.request_id) {
+				req[i]->reply_buffer = rb;
+				break;
+			}
+		}
+
+		if(i < reqids->len)
+			ORBit_handle_dii_reply(req[i], env);
+	}
+
+	g_array_free(reqids, TRUE);
+}
+
+
+/* Section 5.4.1 */
+CORBA_Status
+CORBA_ORB_create_list(CORBA_ORB orb,
+					  CORBA_long count,
+					  CORBA_NVList **new_list,
+					  CORBA_Environment *ev)
+{
+	CORBA_NVList *new;
+
+	new = g_new0(CORBA_NVList, 1);
+	if(new==NULL) goto new_alloc_failed;
+
+	new->list = g_array_new(FALSE, TRUE, sizeof(CORBA_NamedValue));
+
+	*new_list = new;
+
+	return;
+
+ new_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+}
+
+#ifndef __KORBIT__
+/* Section 5.4.6 */
+CORBA_Status
+CORBA_ORB_create_operation_list(CORBA_ORB orb,
+								CORBA_OperationDef oper,
+								CORBA_NVList **new_list,
+								CORBA_Environment *ev)
+{
+	if(!new_list) {
+		CORBA_exception_set_system(ev,
+								   ex_CORBA_BAD_PARAM,
+								   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	g_warning("CORBA_ORB_create_operation_list NYI");
+
+	CORBA_exception_set_system(ev,
+							   ex_CORBA_IMP_LIMIT,
+							   CORBA_COMPLETED_NO);
+}
+#endif /* !__KORBIT__ */
+
+/* Section 5.4.2 */
+CORBA_Status
+CORBA_NVList_add_item(CORBA_NVList *list,
+					  CORBA_Identifier item_name,
+					  CORBA_TypeCode item_type,
+					  void *value,
+					  CORBA_long value_len,
+					  CORBA_Flags item_flags,
+					  CORBA_Environment *ev)
+{
+	CORBA_NamedValue newval;
+
+	g_assert(list!=NULL);
+
+	newval.name = CORBA_string_dup(item_name);
+	newval.argument._type = (CORBA_TypeCode)CORBA_Object_duplicate((CORBA_Object)item_type, ev);
+	if(item_flags & CORBA_IN_COPY_VALUE) {
+		newval.argument._value = ORBit_copy_value(value, item_type);
+		newval.argument._release = CORBA_TRUE;
+	} else {
+		newval.argument._value = value;
+		newval.argument._release = CORBA_FALSE;
+	}
+
+	newval.len = value_len; /* Is this even useful? *sigh* */
+	newval.arg_modes = item_flags;
+
+	g_array_append_val(list->list, newval);
+}
+
+void ORBit_NamedValue_free(CORBA_NamedValue *nv)
+{
+	CORBA_free(nv->name);
+}
+
+/* Section 5.4.3 */
+CORBA_Status
+CORBA_NVList_free(CORBA_NVList *list,
+				  CORBA_Environment *ev)
+{
+	int i;
+
+	CORBA_NVList_free_memory(list, ev);
+
+	for(i = 0; i < list->list->len; i++)
+		ORBit_NamedValue_free(&g_array_index(list->list, CORBA_NamedValue, i));
+
+	g_array_free(list->list, TRUE);
+
+	g_free(list);
+}
+
+/* Section 5.4.4 */
+CORBA_Status
+CORBA_NVList_free_memory(CORBA_NVList *list,
+						 CORBA_Environment *ev)
+{
+	int i;
+
+	for(i = 0; i < list->list->len; i++) {
+		CORBA_free(g_array_index(list->list, CORBA_NamedValue, i).argument._value);
+		g_array_index(list->list, CORBA_NamedValue, i).argument._value = NULL;
+		CORBA_Object_release((CORBA_Object)g_array_index(list->list, CORBA_NamedValue, i).argument._type, ev);
+		g_array_index(list->list, CORBA_NamedValue, i).argument._release = CORBA_FALSE;
+	}
+}
+
+
+/* Section 5.4.5 */
+CORBA_Status
+CORBA_NVList_get_count(CORBA_NVList *list,
+					   CORBA_long *count,
+					   CORBA_Environment *ev)
+{
+	*count = list->list->len;
+}
+
diff -urN linux-2.4.1/net/korbit/orb/dii.h linux-2.4.1-korbit/net/korbit/orb/dii.h
--- linux-2.4.1/net/korbit/orb/dii.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/dii.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,124 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_DII_H_
+#define _ORBIT_DII_H_
+
+#include "orb/orbit_types.h"
+#ifndef __KORBIT__
+#include "orb/interface_repository.h"
+#endif /* !__KORBIT__ */
+
+extern CORBA_Status CORBA_Object_create_request(
+	CORBA_Object obj,
+	CORBA_Context ctx,
+	CORBA_Identifier operation,
+	CORBA_NVList *arg_list,
+	CORBA_NamedValue *result,
+	CORBA_Request *request,
+	CORBA_Flags req_flags,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Request_add_arg(
+	CORBA_Request req,
+	CORBA_Identifier name,
+	CORBA_TypeCode arg_type,
+	void *value,
+	CORBA_long len,
+	CORBA_Flags arg_flags,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Request_invoke(
+	CORBA_Request req,
+	CORBA_Flags invoke_flags,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Request_delete(
+	CORBA_Request req,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_Request_send(
+	CORBA_Request req,
+	CORBA_Flags invoke_flags,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_send_multiple_requests(
+	CORBA_Request reqs[],
+	CORBA_Environment *env,
+	CORBA_long count,
+	CORBA_Flags invoke_flags);
+
+extern CORBA_Status CORBA_Request_get_response(
+	CORBA_Request req,
+	CORBA_Flags response_flags,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_get_next_response(
+	CORBA_Environment *env,
+	CORBA_Flags response_flags,
+	CORBA_Request *req);
+
+extern CORBA_Status CORBA_NVList_add_item(
+	CORBA_NVList *list,
+	CORBA_Identifier item_name,
+	CORBA_TypeCode item_type,
+	void *value,
+	CORBA_long value_len,
+	CORBA_Flags item_flags,
+	CORBA_Environment *ev);
+
+extern void ORBit_NamedValue_free(
+	CORBA_NamedValue *nv);
+
+
+extern CORBA_Status CORBA_ORB_create_list(
+	CORBA_ORB orb,
+	CORBA_long count,
+	CORBA_NVList **new_list,
+	CORBA_Environment *ev);
+
+#ifndef __KORBIT__
+extern CORBA_Status CORBA_ORB_create_operation_list(
+	CORBA_ORB orb,
+	CORBA_OperationDef oper,
+	CORBA_NVList **new_list,
+	CORBA_Environment *ev);
+#endif /* !__KORBIT__ */
+
+extern CORBA_Status CORBA_NVList_free(CORBA_NVList *list,
+				      CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_NVList_free_memory(
+	CORBA_NVList *list,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_NVList_get_count(
+	CORBA_NVList *list,
+	CORBA_long *count,
+	CORBA_Environment *ev);
+
+extern const int sizeofs[], container_sizeofs[];
+
+#endif /* _ORBIT_DII_H_ */
diff -urN linux-2.4.1/net/korbit/orb/env.c linux-2.4.1-korbit/net/korbit/orb/env.c
--- linux-2.4.1/net/korbit/orb/env.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/env.c	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,345 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+/*
+ * CORBA_Environment handling functions
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "orbit.h"
+#ifndef __KORBIT__
+#include "interface_repository.h"
+#endif /* !__KORBIT__ */
+
+struct SysExInfo {
+	const char *repo_id;
+	const int exnum;
+};
+
+static const struct SysExInfo exception_table[] = {
+	{NULL, 0},
+	{"IDL:CORBA/UNKNOWN:1.0", 1},
+	{"IDL:CORBA/BAD_PARAM:1.0", 2},
+	{"IDL:CORBA/NO_MEMORY:1.0", 3},
+	{"IDL:CORBA/IMP_LIMIT:1.0", 4},
+	{"IDL:CORBA/COMM_FAILURE:1.0", 5},
+	{"IDL:CORBA/INV_OBJREF:1.0", 6},
+	{"IDL:CORBA/NO_PERMISSION:1.0", 7},
+	{"IDL:CORBA/INTERNAL:1.0", 8},
+	{"IDL:CORBA/MARSHAL:1.0", 9},
+	{"IDL:CORBA/INITIALIZE:1.0", 10},
+	{"IDL:CORBA/NO_IMPLEMENT:1.0", 11},
+	{"IDL:CORBA/BAD_TYPECODE:1.0", 12},
+	{"IDL:CORBA/BAD_OPERATION:1.0", 13},
+	{"IDL:CORBA/NO_RESOURCES:1.0", 14},
+	{"IDL:CORBA/NO_RESPONSE:1.0", 15},
+	{"IDL:CORBA/PERSIST_STORE:1.0", 16},
+	{"IDL:CORBA/BAD_INV_ORDER:1.0", 17},
+	{"IDL:CORBA/TRANSIENT:1.0", 18},
+	{"IDL:CORBA/FREE_MEM:1.0", 19},
+	{"IDL:CORBA/INV_IDENT:1.0", 20},
+	{"IDL:CORBA/INV_FLAG:1.0", 21},
+	{"IDL:CORBA/INTF_REPOS:1.0", 22},
+	{"IDL:CORBA/BAD_CONTEXT:1.0", 23},
+	{"IDL:CORBA/OBJ_ADAPTER:1.0", 24},
+	{"IDL:CORBA/DATA_CONVERSION:1.0", 25},
+	{"IDL:CORBA/OBJECT_NOT_EXIST:1.0", 26},
+	{"IDL:CORBA/TRANSACTION_REQUIRED:1.0", 27},
+	{"IDL:CORBA/TRANSACTION_ROLLEDBACK:1.0", 28},
+	{"IDL:CORBA/INVALID_TRANSACTION:1.0", 29},
+	{NULL,0}
+};
+
+void CORBA_exception_free(CORBA_Environment *ev)
+{
+	g_assert(ev!=NULL);
+
+	ev->_major=CORBA_NO_EXCEPTION;
+
+	if(ev->_repo_id) {
+		CORBA_free(ev->_repo_id);
+		ev->_repo_id=NULL;
+	}
+
+	if(ev->_params) {
+		CORBA_free(ev->_params);
+		ev->_params=NULL;
+	}
+
+	if(ev->_any) {
+		CORBA_free(ev->_any);
+		ev->_any=NULL;
+	}
+}
+
+void CORBA_exception_set(CORBA_Environment *ev, CORBA_exception_type major, 
+			 const CORBA_char *except_repos_id, void *param)
+{
+	g_assert(ev!=NULL);
+
+	if(ev->_major != CORBA_NO_EXCEPTION)
+		CORBA_exception_free(ev);
+
+	ev->_major=major;
+
+	if(except_repos_id==NULL) {
+		ev->_repo_id=NULL;
+	} else {
+		ev->_repo_id=CORBA_string_dup(except_repos_id);
+	}
+
+	ev->_params=param;
+}
+
+void CORBA_exception_set_system(CORBA_Environment *ev, CORBA_unsigned_long ex_value,
+				CORBA_completion_status completed)
+{
+	CORBA_SystemException *new;
+
+	new=ORBit_alloc(sizeof(CORBA_SystemException), NULL, NULL);
+	if(new!=NULL) {
+		new->minor=0;
+		new->completed=completed;
+
+		/* XXX what should the repo ID be? */
+		CORBA_exception_set(ev, CORBA_SYSTEM_EXCEPTION,
+				    exception_table[ex_value].repo_id,
+				    new);
+	}
+}
+
+void CORBA_exception_init(CORBA_Environment *ev)
+{
+	g_assert(ev!=NULL);
+
+	ev->_major=CORBA_NO_EXCEPTION;
+	ev->_repo_id=NULL;
+	ev->_params=NULL;
+	ev->_any=NULL;
+}
+
+CORBA_char *CORBA_exception_id(CORBA_Environment *ev)
+{
+	g_assert(ev!=NULL);
+
+	if(ev->_major==CORBA_NO_EXCEPTION) {
+		return(NULL);
+	} else {
+		return(ev->_repo_id);
+	}
+}
+
+void *CORBA_exception_value(CORBA_Environment *ev)
+{
+	g_assert(ev!=NULL);
+
+	if(ev->_major==CORBA_NO_EXCEPTION) {
+		return(NULL);
+	} else {
+		return(ev->_params);
+	}
+}
+
+#ifndef __KORBIT__
+CORBA_any *CORBA_exception_as_any(CORBA_Environment *ev)
+{
+	g_assert(ev!=NULL);
+
+	if(ev->_major==CORBA_NO_EXCEPTION) {
+		return(NULL);
+	}
+
+	if(ev->_any!=NULL) {
+		return(ev->_any);
+	}
+
+	ev->_any=g_new(CORBA_any, 1);
+	if(ev->_any!=NULL) {
+		/* XXX is this the correct type? */
+		ev->_any->_type = (CORBA_TypeCode)TC_CORBA_ExceptionDescription;
+		ev->_any->_value = ev->_params;
+		ev->_any->_release = 0;
+	}
+
+	return(ev->_any);
+}
+#endif /* !__KORBIT__ */
+
+/**** ORBit_handle_exception
+      Inputs: 'rb' - a receive buffer for which an exception condition has
+                     been determined
+	      'ev' - memory in which to store the exception information
+
+	      'user_exceptions' -     list of user exceptions raisable
+				      for this particular operation.
+      Side-effects: reinitializes '*ev'
+
+      Description:
+           During demarshalling a reply, if reply_status != CORBA_NO_EXCEPTION,
+	   we must find out what exception was raised and place that information
+	   in '*ev'.  */
+
+void ORBit_handle_exception(GIOPRecvBuffer *rb, CORBA_Environment *ev,
+			    const ORBit_exception_demarshal_info *user_exceptions,
+			    CORBA_ORB orb)
+{
+	CORBA_SystemException *new;
+	CORBA_unsigned_long len, completion_status;
+	CORBA_char *my_repoid;
+
+	g_return_if_fail(GIOP_MESSAGE_BUFFER(rb)->message_header.message_type == GIOP_REPLY);
+
+	CORBA_exception_free(ev);
+
+	rb->cur = ALIGN_ADDRESS(rb->cur, sizeof(len));
+	rb->decoder(&len, rb->cur, sizeof(len));
+	/* (guchar *)rb->cur += sizeof(len); */
+	rb->cur = ((guchar *)rb->cur) + sizeof(len);
+
+	if(len) {
+		my_repoid = rb->cur;
+		rb->cur = ((guchar *)rb->cur) + len;
+	} else
+		my_repoid = NULL;
+
+	if(rb->message.u.reply.reply_status == CORBA_SYSTEM_EXCEPTION) {
+		CORBA_unsigned_long minor;
+
+		ev->_major = CORBA_SYSTEM_EXCEPTION;
+
+		rb->cur = ALIGN_ADDRESS(rb->cur, sizeof(minor));
+		rb->decoder(&minor, rb->cur, sizeof(minor));
+		rb->cur = ((guchar *)rb->cur) + sizeof(minor);
+
+		rb->cur = ALIGN_ADDRESS(rb->cur, sizeof(completion_status));
+		rb->decoder(&completion_status, rb->cur, sizeof(completion_status));
+		rb->cur = ((guchar *)rb->cur) + sizeof(completion_status);
+
+		new=ORBit_alloc(sizeof(CORBA_SystemException), NULL, NULL);
+
+		if(new!=NULL) {
+			new->minor=minor;
+			new->completed=completion_status;
+			
+		/* XXX what should the repo ID be? */
+		CORBA_exception_set(ev, CORBA_SYSTEM_EXCEPTION,
+				    my_repoid,
+				    new);
+		}
+	} else if(rb->message.u.reply.reply_status == CORBA_USER_EXCEPTION) {
+		int i;
+
+		if(!user_exceptions) {
+			/* weirdness; they raised an exception that we don't
+			   know about */
+			CORBA_exception_set_system(ev, ex_CORBA_MARSHAL,
+						   CORBA_COMPLETED_MAYBE);
+		} else {
+			for(i = 0; user_exceptions[i].tc != CORBA_OBJECT_NIL;
+			    i++) {
+				if(!strcmp(user_exceptions[i].tc->repo_id,
+					   my_repoid))
+					break;
+			}
+
+			if(user_exceptions[i].tc == CORBA_OBJECT_NIL) {
+				/* weirdness; they raised an exception
+				   that we don't know about */
+				CORBA_exception_set_system(ev, ex_CORBA_MARSHAL,
+							   CORBA_COMPLETED_MAYBE);
+			} else {
+				user_exceptions[i].demarshal(rb, ev);
+			}
+		}
+	};
+
+	/* ignore LOCATION_FORWARD here, that gets handled in the stub */
+}
+
+void
+ORBit_send_system_exception(GIOPSendBuffer *send_buffer,
+			    CORBA_Environment *ev)
+{
+	CORBA_unsigned_long minor;
+	CORBA_unsigned_long completion_status;
+	CORBA_SystemException *se = ev->_params;
+
+	minor = se->minor;
+	completion_status = se->completed;
+
+	ENCODER_CALL(CORBA_char, ev->_repo_id);
+	giop_send_buffer_append_mem_indirect_a(send_buffer, &minor,
+					       sizeof(minor));
+	giop_send_buffer_append_mem_indirect_a(send_buffer,
+					       &completion_status,
+					       sizeof(completion_status));
+}
+
+void
+ORBit_send_user_exception(GIOPSendBuffer *send_buffer,
+			  CORBA_Environment *ev,
+			  const ORBit_exception_marshal_info *user_exceptions)
+{
+	int i;
+
+	for(i = 0; user_exceptions[i].tc != CORBA_OBJECT_NIL; i++) {
+		if(!strcmp(user_exceptions[i].tc->repo_id, ev->_repo_id))
+			break;
+	}
+
+	if(user_exceptions[i].tc == CORBA_OBJECT_NIL) {
+		CORBA_Environment fakeev;
+		CORBA_exception_init(&fakeev);
+		CORBA_exception_set_system(&fakeev, ex_CORBA_UNKNOWN,
+					   CORBA_COMPLETED_MAYBE);
+		ORBit_send_system_exception(send_buffer, &fakeev);
+		CORBA_exception_free(&fakeev);
+	} else {
+		ENCODER_CALL(CORBA_char, ev->_repo_id);
+
+		if(user_exceptions[i].marshal && ev->_params)
+			user_exceptions[i].marshal(send_buffer, ev);
+	}
+}
+
+void
+ORBit_handle_system_exception(CORBA_Environment *ev,
+			      CORBA_unsigned_long system_exception_minor,
+			      CORBA_unsigned_long completion_status,
+			      GIOPRecvBuffer *recv_buffer,
+			      GIOPSendBuffer *send_buffer)
+{
+	CORBA_exception_set_system(ev, system_exception_minor, completion_status);
+
+	if(send_buffer)
+		giop_send_buffer_unuse(send_buffer);
+
+	if(recv_buffer)
+		giop_recv_buffer_unuse(recv_buffer);
+}
diff -urN linux-2.4.1/net/korbit/orb/env.h linux-2.4.1-korbit/net/korbit/orb/env.h
--- linux-2.4.1/net/korbit/orb/env.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/env.h	Thu Feb  1 16:21:56 2001
@@ -0,0 +1,79 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998, 1999 Richard H. Porter, Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_ENV_H_
+#define _ORBIT_ENV_H_
+
+#include "orbit_types.h"
+
+extern void CORBA_exception_set(CORBA_Environment *ev,
+	CORBA_exception_type major, 
+	const CORBA_char *except_repos_id,
+	void *param);
+
+extern void CORBA_exception_set_system(CORBA_Environment *ev,
+	CORBA_unsigned_long ex_value,
+	CORBA_completion_status completed);
+
+extern void CORBA_exception_init(CORBA_Environment *ev);
+
+extern CORBA_char *CORBA_exception_id(CORBA_Environment *e);
+
+extern void *CORBA_exception_value(CORBA_Environment *ev);
+
+extern void CORBA_exception_free(CORBA_Environment *ev);
+
+#ifndef __KORBIT__
+extern CORBA_any *CORBA_exception_as_any(CORBA_Environment *ev);
+#endif /* !__KORBIT__ */
+
+typedef struct {
+	const CORBA_TypeCode tc;
+	void (*demarshal)(GIOPRecvBuffer *_ORBIT_recv_buffer, CORBA_Environment *ev);
+} ORBit_exception_demarshal_info;
+
+typedef struct {
+	const CORBA_TypeCode tc;
+	void (*marshal)(GIOPSendBuffer *_ORBIT_send_buffer, CORBA_Environment *ev);
+} ORBit_exception_marshal_info;
+
+/* ORBit-specific */
+void ORBit_handle_exception(GIOPRecvBuffer *rb, CORBA_Environment *ev,
+			    const ORBit_exception_demarshal_info *user_exceptions,
+			    CORBA_ORB orb);
+void ORBit_send_system_exception(GIOPSendBuffer *send_buffer,
+				 CORBA_Environment *ev);
+void ORBit_send_user_exception(GIOPSendBuffer *send_buffer,
+			       CORBA_Environment *ev,
+			       const ORBit_exception_marshal_info *user_exceptions);
+
+/* Used by stubs */
+void ORBit_handle_system_exception(CORBA_Environment *ev,
+				   CORBA_unsigned_long system_exception_minor,
+				   CORBA_unsigned_long completion_status,
+				   GIOPRecvBuffer *recv_buffer,
+				   GIOPSendBuffer *send_buffer);
+
+#endif /* !_ORBIT_ENV_H_ */
diff -urN linux-2.4.1/net/korbit/orb/genrand.c linux-2.4.1-korbit/net/korbit/orb/genrand.c
--- linux-2.4.1/net/korbit/orb/genrand.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/genrand.c	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,131 @@
+#include "genrand.h"
+#include "ORBitutil/util.h"
+#include <unistd.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <glib.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <limits.h>
+#include <stdio.h>
+#ifdef __KERNEL__
+#include <linux/random.h>
+#endif
+
+static gboolean
+genrand_dev(guchar *buffer, int buf_len)
+{
+#ifdef __KERNEL__
+  get_random_bytes(buffer, buf_len);
+#else /*! __KERNEL__*/
+  int fd;
+
+  fd = open("/dev/urandom", O_RDONLY);
+  if(fd < 0)
+    return FALSE;
+
+  if(read(fd, buffer, buf_len) < buf_len)
+    {
+      close(fd);
+      return FALSE;
+    }
+
+  close(fd);
+#endif /*! __KERNEL__*/
+
+  return TRUE;
+}
+
+#ifndef __KORBIT__
+static volatile int received_alarm = 0;
+
+static void
+handle_alarm(int signum)
+{
+  received_alarm = 1;
+}
+
+static inline guchar
+hashlong(long val)
+{
+  guchar retval, *ptr;
+  int i;
+
+  for(ptr = (guchar *)&val, i = 0; i < sizeof(val); i++)
+    retval ^= ptr[i];
+
+  return retval;
+}
+
+static gboolean
+genrand_unix(guchar *buffer, int buf_len)
+{
+  struct sigaction sa, oldsa;
+  struct itimerval it, oldit;
+  int i;
+  long min, max;
+  long *counts;
+  double diff;
+  long *uninit;
+
+  counts = alloca(buf_len * sizeof(long));
+
+  memset(&sa, 0, sizeof(sa));
+  sa.sa_handler = handle_alarm;
+  sigaction(SIGALRM, &sa, &oldsa);
+  memset(&it, 0, sizeof(it));
+  it.it_value.tv_usec = 1;
+  getitimer(ITIMER_REAL, &oldit);
+
+  for(i = 0, min = LONG_MAX, max = 0; i < buf_len; i++)
+    {
+      received_alarm = 0;
+      setitimer(ITIMER_REAL, &it, NULL);
+      for(counts[i] = 0; !received_alarm; counts[i]++);
+
+      max = MAX(counts[i], max);
+      min = MIN(counts[i], min);
+    }
+
+  if(!(max - min)) 
+  {
+          freeca(counts);
+          return FALSE;
+  }
+  
+  diff = max - min;
+
+  uninit = alloca(buf_len * sizeof(long)); /* Purposely not initialized */
+  for(i = 0; i < buf_len; i++)
+    {
+      long diffval;
+      diffval = counts[i] - min;
+
+      buffer[i] ^= (guchar)( ((double) (diffval*256)  / diff )) ^ hashlong(uninit[i]);
+    }
+
+  setitimer(ITIMER_REAL, &oldit, NULL);
+  sigaction(SIGALRM, &oldsa, NULL);
+
+  freeca(counts);
+  freeca(uninit);
+  
+  return TRUE;
+}
+#endif /* !__KORBIT__ */
+
+void
+orbit_genrand(guchar *buffer, int buf_len)
+{
+  g_return_if_fail(buf_len);
+
+  if(genrand_dev(buffer, buf_len))
+    return;
+#ifndef __KORBIT__
+  else if(genrand_unix(buffer, buf_len))
+    return;
+#endif
+  else
+    g_error("Couldn't generate random data!");
+}
+
diff -urN linux-2.4.1/net/korbit/orb/genrand.h linux-2.4.1-korbit/net/korbit/orb/genrand.h
--- linux-2.4.1/net/korbit/orb/genrand.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/genrand.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,8 @@
+#ifndef ORBIT_GENRAND_H
+#define ORBIT_GENRAND_H 1
+
+#include <glib.h>
+
+void orbit_genrand(guchar *buffer, int buf_len);
+
+#endif /* ORBIT_GENRAND_H */
diff -urN linux-2.4.1/net/korbit/orb/iop.h linux-2.4.1-korbit/net/korbit/orb/iop.h
--- linux-2.4.1/net/korbit/orb/iop.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/iop.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,207 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_IOP_H_
+#define _ORBIT_IOP_H_
+
+#include <ORBitutil/basic_types.h>
+
+#include <orb/corba_basic_sequences_type.h>
+
+#ifndef HAVE_CORBA_PRINCIPAL
+#define HAVE_CORBA_PRINCIPAL 1
+typedef CORBA_sequence_octet CORBA_Principal;
+#endif
+
+typedef CORBA_unsigned_long IOP_ProfileId;
+
+#define IOP_TAG_INTERNET_IOP 0
+#define IOP_TAG_MULTIPLE_COMPONENTS 1
+#define IOP_TAG_ORBIT_SPECIFIC 0xbadfaecal
+
+typedef struct IOP_TaggedProfile {
+	IOP_ProfileId tag;
+	CORBA_sequence_octet profile_data;
+} IOP_TaggedProfile;
+
+typedef struct CORBA_sequence_TaggedProfile {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	IOP_TaggedProfile *_buffer;
+} CORBA_sequence_TaggedProfile;
+
+typedef struct IOP_IOR {
+	CORBA_char *type_id;
+	CORBA_sequence_TaggedProfile profiles;
+} IOP_IOR;
+
+typedef CORBA_unsigned_long IOP_ComponentId;
+
+typedef struct IOP_TaggedComponent {
+	IOP_ComponentId tag;
+	CORBA_sequence_octet component_data;
+} IOP_TaggedComponent;
+
+typedef struct CORBA_sequence_TaggedComponent {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	IOP_TaggedComponent *_buffer;
+} CORBA_sequence_TaggedComponent;
+
+typedef struct CORBA_sequence_TaggedComponent IOP_MultipleComponentProfile;
+
+#define IOP_TAG_ORB_TYPE 0
+#define IOP_TAG_CODE_SETS 1
+#define IOP_TAG_SEC_NAME 14
+#define IOP_TAG_ASSOCIATION_OPTIONS 13
+#define IOP_TAG_GENERIC_SEC_MECH 12
+
+typedef CORBA_unsigned_long IOP_ServiceId;
+
+typedef struct IOP_ServiceContext {
+	IOP_ServiceId context_id;
+	CORBA_sequence_octet context_data;
+} IOP_ServiceContext;
+
+typedef struct CORBA_sequence_ServiceContext {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	IOP_ServiceContext *_buffer;
+} CORBA_sequence_ServiceContext;
+
+typedef struct CORBA_sequence_ServiceContext IOP_ServiceContextList;
+
+#define IOP_TransactionService 0
+#define IOP_CodeSets 1
+
+typedef CORBA_unsigned_long CONV_FRAME_CodeSetId;
+
+typedef struct CORBA_sequence_CodeSetId {
+	CORBA_unsigned_long _maximum;
+	CORBA_unsigned_long _length;
+	CONV_FRAME_CodeSetId *_buffer;
+} CORBA_sequence_CodeSetId;
+
+typedef struct CONV_FRAME_CodeSetComponent {
+	CONV_FRAME_CodeSetId native_code_set;
+	CORBA_sequence_CodeSetId conversion_code_sets;
+} CONV_FRAME_CodeSetComponent;
+
+typedef struct CONV_FRAME_CodeSetComponentInfo {
+	CONV_FRAME_CodeSetComponent ForCharData;
+	CONV_FRAME_CodeSetComponent ForWcharData;
+} CONV_FRAME_CodeSetComponentInfo;
+
+typedef struct CONV_FRAME_CodeSetContext {
+	CONV_FRAME_CodeSetId char_data;
+	CONV_FRAME_CodeSetId wchar_data;
+} CONV_FRAME_CodeSetContext;
+
+typedef struct GIOP_Version {
+	CORBA_octet major;
+	CORBA_octet minor;
+} GIOP_Version;
+
+typedef enum {
+	GIOP_Request=0,
+	GIOP_Reply,
+	GIOP_CancelRequest,
+	GIOP_LocateRequest,
+	GIOP_LocateReply,
+	GIOP_CloseConnection,
+	GIOP_MessageError
+} GIOP_MsgType_1_0;
+
+typedef struct GIOP_MessageHeader_1_0 {
+	CORBA_char magic[4];
+	GIOP_Version GIOP_version;
+	CORBA_boolean byte_order;
+	CORBA_octet message_type;
+	CORBA_unsigned_long message_size;
+} GIOP_MessageHeader_1_0;
+
+typedef struct GIOP_MessageHeader_1_1 {
+	CORBA_char magic[4];
+	GIOP_Version GIOP_version;
+	CORBA_octet flags;
+	CORBA_octet message_type;
+	CORBA_unsigned_long message_size;
+} GIOP_MessageHeader_1_1;
+
+typedef struct GIOP_RequestHeader_1_0 {
+	IOP_ServiceContextList service_context;
+	CORBA_unsigned_long request_id;
+	CORBA_boolean response_expected;
+	CORBA_sequence_octet object_key;
+	CORBA_char *operation;
+	CORBA_Principal requesting_principal;
+} GIOP_RequestHeader_1_0;
+
+typedef struct GIOP_RequestHeader_1_1 {
+	IOP_ServiceContextList service_context;
+	CORBA_unsigned_long request_id;
+	CORBA_boolean response_expected;
+	CORBA_octet reserved[3];
+	CORBA_sequence_octet object_key;
+	CORBA_char *operation;
+	CORBA_Principal requesting_principal;
+} GIOP_RequestHeader_1_1;
+
+typedef struct GIOP_SystemExceptionReplyBody {
+	CORBA_char *exception_id;
+	CORBA_unsigned_long minor_code_value;
+	CORBA_unsigned_long completion_status;
+} GIOP_SystemExceptionReplyBody;
+
+typedef struct GIOP_CancelRequestHeader {
+	CORBA_unsigned_long request_id;
+} GIOP_CancelRequestHeader;
+
+typedef struct GIOP_LocateRequestHeader {
+	CORBA_unsigned_long request_id;
+	CORBA_sequence_octet object_key;
+} GIOP_LocateRequestHeader;
+
+typedef struct IIOP_Version {
+	CORBA_octet major;
+	CORBA_octet minor;
+} IIOP_Version;
+
+typedef struct IIOP_ProfileBody_1_0 {
+	IIOP_Version iiop_version;
+	CORBA_char *host;
+	CORBA_unsigned_short port;
+	CORBA_sequence_octet object_key;
+} IIOP_ProfileBody_1_0;
+
+typedef struct IIOP_ProfileBody_1_1 {
+	IIOP_Version iiop_version;
+	CORBA_char *host;
+	CORBA_unsigned_short port;
+	CORBA_sequence_octet object_key;
+	CORBA_sequence_TaggedComponent components;
+} IIOP_ProfileBody_1_1;
+
+#endif /* !_ORBIT_IOP_H_ */
diff -urN linux-2.4.1/net/korbit/orb/ir.c linux-2.4.1-korbit/net/korbit/orb/ir.c
--- linux-2.4.1/net/korbit/orb/ir.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/ir.c	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,293 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+
+#include "orbit.h"
+
+/* FIXME: Right now this function doesn't record whether or not it has
+   already visited a given TypeCode.  I'm not sure if every recursive
+   type will have a tk_recursive node in it; if not, then this will
+   need to be reworked a bit.  */
+CORBA_boolean CORBA_TypeCode_equal(CORBA_TypeCode obj, CORBA_TypeCode tc, CORBA_Environment *ev)
+{
+	int i;
+
+	g_return_val_if_fail(obj!=NULL, CORBA_FALSE);
+	g_return_val_if_fail(tc!=NULL, CORBA_FALSE);
+
+	if (obj->kind != tc->kind) {
+		return CORBA_FALSE;
+	}
+
+	switch (obj->kind) {
+	case CORBA_tk_wstring:
+	case CORBA_tk_string:
+		return obj->length == tc->length;
+	case CORBA_tk_objref:
+		return ! strcmp (obj->repo_id, tc->repo_id);
+	case CORBA_tk_except:
+	case CORBA_tk_struct:
+		if (strcmp (obj->repo_id, tc->repo_id)
+		    || obj->sub_parts != tc->sub_parts)
+			return CORBA_FALSE;
+		for (i = 0; i < obj->sub_parts; ++i)
+			if (! CORBA_TypeCode_equal (obj->subtypes[i],
+						    tc->subtypes[i], ev))
+				return CORBA_FALSE;
+		break;
+	case CORBA_tk_union:
+		if (strcmp (obj->repo_id, tc->repo_id)
+		    || obj->sub_parts != tc->sub_parts
+		    || ! CORBA_TypeCode_equal (obj->discriminator,
+					       tc->discriminator, ev)
+		    || obj->default_index != tc->default_index)
+			return CORBA_FALSE;
+		for (i = 0; i < obj->sub_parts; ++i)
+
+			if (! CORBA_TypeCode_equal (obj->subtypes[i],
+						    tc->subtypes[i], ev)
+			    || ! ORBit_any_equivalent (obj->sublabels[i],
+						       tc->sublabels[i], ev))
+				return CORBA_FALSE;
+
+		break;
+	case CORBA_tk_enum:
+		if (obj->sub_parts != tc->sub_parts
+		    || strcmp (obj->repo_id, tc->repo_id))
+			return CORBA_FALSE;
+		for (i = 0; i < obj->sub_parts; ++i)
+			if (strcmp (obj->subnames[i], tc->subnames[i]))
+				return CORBA_FALSE;
+		break;
+	case CORBA_tk_sequence:
+	case CORBA_tk_array:
+		if (obj->length != tc->length)
+			return CORBA_FALSE;
+		g_assert (obj->sub_parts == 1);
+		g_assert (tc->sub_parts == 1);
+		return CORBA_TypeCode_equal (obj->subtypes[0], tc->subtypes[0],
+					     ev);
+	case CORBA_tk_alias:
+		if (strcmp (obj->repo_id, tc->repo_id))
+			return CORBA_FALSE;
+		
+		g_assert (obj->sub_parts == 1);
+		g_assert (tc->sub_parts == 1);
+
+		return CORBA_TypeCode_equal (obj->subtypes[0], tc->subtypes[0],
+					       ev);
+		break;
+	case CORBA_tk_recursive:
+		return obj->recurse_depth == tc->recurse_depth;
+	case CORBA_tk_fixed:
+		return obj->digits == tc->digits && obj->scale == tc->scale;
+
+	default:
+		/* Everything else is primitive.  */
+		break;
+	}
+
+	return CORBA_TRUE;
+}
+
+CORBA_TCKind CORBA_TypeCode_kind(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	return obj->kind;
+}
+
+static void bad_kind (CORBA_Environment *ev)
+{
+	CORBA_TypeCode_BadKind *err;
+	err = g_new (CORBA_TypeCode_BadKind, 1);
+	if (err == NULL) {
+		CORBA_exception_set_system (ev, ex_CORBA_NO_MEMORY,
+					    CORBA_COMPLETED_NO);
+	} else {
+		err->dummy = 23;
+		CORBA_exception_set (ev, CORBA_USER_EXCEPTION,
+				     "IDL:omg.org/CORBA/TypeCode/BadKind/1.0",
+				     err);
+	}
+}
+
+CORBA_RepositoryId CORBA_TypeCode_id(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_objref || obj->kind == CORBA_tk_struct
+	       || obj->kind == CORBA_tk_enum || obj->kind == CORBA_tk_alias
+	       || obj->kind == CORBA_tk_except)) {
+		bad_kind (ev);
+		return NULL;
+	}
+	return obj->repo_id;
+}
+
+CORBA_Identifier CORBA_TypeCode_name(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_objref || obj->kind == CORBA_tk_struct
+	       || obj->kind == CORBA_tk_enum || obj->kind == CORBA_tk_alias
+	       || obj->kind == CORBA_tk_except)) {
+		bad_kind (ev);
+		return NULL;
+	}
+
+	return obj->name;
+}
+
+CORBA_unsigned_long CORBA_TypeCode_member_count(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_struct || obj->kind == CORBA_tk_union
+	       || obj->kind == CORBA_tk_enum)) {
+		bad_kind (ev);
+		return 0;
+	}
+	return obj->sub_parts;
+}
+
+static void bounds_error (CORBA_Environment *ev)
+{
+	CORBA_TypeCode_Bounds *err;
+	err = g_new (CORBA_TypeCode_Bounds, 1);
+	if (err == NULL) {
+		CORBA_exception_set_system (ev, ex_CORBA_NO_MEMORY,
+					    CORBA_COMPLETED_NO);
+	} else {
+		err->dummy = 23;
+		CORBA_exception_set (ev, CORBA_USER_EXCEPTION,
+				     "IDL:omg.org/CORBA/TypeCode/Bounds/1.0",
+				     err);
+	}
+}
+
+CORBA_Identifier CORBA_TypeCode_member_name(CORBA_TypeCode obj, CORBA_unsigned_long index, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_struct || obj->kind == CORBA_tk_union
+	       || obj->kind == CORBA_tk_enum)) {
+		bad_kind (ev);
+		return NULL;
+	}
+	if (index > obj->sub_parts) {
+		bounds_error (ev);
+		return NULL;
+	}
+	return obj->subnames[index];
+}
+
+CORBA_TypeCode CORBA_TypeCode_member_type(CORBA_TypeCode obj, CORBA_unsigned_long index, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_struct || obj->kind == CORBA_tk_union
+	       || obj->kind == CORBA_tk_enum)) {
+		bad_kind (ev);
+		return NULL;
+	}
+	if (index > obj->sub_parts) {
+		bounds_error (ev);
+		return NULL;
+	}
+	return obj->subtypes[index];
+}
+
+CORBA_any *CORBA_TypeCode_member_label(CORBA_TypeCode obj, CORBA_unsigned_long index, CORBA_Environment *ev)
+{
+	if (obj->kind != CORBA_tk_union) {
+		bad_kind (ev);
+		return NULL;
+	}
+	if (index > obj->sub_parts) {
+		bounds_error (ev);
+		return NULL;
+	}
+	return &obj->sublabels[index];
+}
+
+CORBA_TypeCode CORBA_TypeCode_discriminator_type(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (obj->kind != CORBA_tk_union) {
+		bad_kind (ev);
+		return NULL;
+	}
+	return obj->discriminator;
+}
+
+CORBA_long CORBA_TypeCode_default_index(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (obj->kind != CORBA_tk_union) {
+		bad_kind (ev);
+		return 0;
+	}
+	return obj->default_index;
+}
+
+CORBA_unsigned_long CORBA_TypeCode_length(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_string || obj->kind == CORBA_tk_wstring
+	       || obj->kind == CORBA_tk_array)) {
+		bad_kind (ev);
+		return 0;
+	}
+	return obj->length;
+}
+
+CORBA_TypeCode CORBA_TypeCode_content_type(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (! (obj->kind == CORBA_tk_sequence || obj->kind == CORBA_tk_array
+	       || obj->kind == CORBA_tk_alias)) {
+		bad_kind (ev);
+		return NULL;
+	}
+	g_assert (obj->sub_parts == 1);
+	return obj->subtypes[0];
+}
+
+CORBA_unsigned_short CORBA_TypeCode_fixed_digits(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (obj->kind != CORBA_tk_fixed) {
+		bad_kind (ev);
+		return 0;
+	}
+	return obj->digits;
+}
+
+CORBA_short CORBA_TypeCode_fixed_scale(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	if (obj->kind != CORBA_tk_fixed) {
+		bad_kind (ev);
+		return 0;
+	}
+	return obj->scale;
+}
+
+CORBA_long CORBA_TypeCode_param_count(CORBA_TypeCode obj, CORBA_Environment *ev)
+{
+	g_assert(!"Deprecated");
+	return(0);
+}
+
+CORBA_any *CORBA_TypeCode_parameter(CORBA_TypeCode obj, CORBA_long index, CORBA_Environment *ev)
+{
+	g_assert(!"Deprecated");
+	return(NULL);
+}
diff -urN linux-2.4.1/net/korbit/orb/ir.h linux-2.4.1-korbit/net/korbit/orb/ir.h
--- linux-2.4.1/net/korbit/orb/ir.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/ir.h	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,100 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_IR_H_
+#define _ORBIT_IR_H_
+
+#include "orbit_types.h"
+
+extern CORBA_boolean CORBA_TypeCode_equal(
+	CORBA_TypeCode obj,
+	CORBA_TypeCode tc,
+	CORBA_Environment *ev);
+
+extern CORBA_TCKind CORBA_TypeCode_kind(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_RepositoryId CORBA_TypeCode_id(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_Identifier CORBA_TypeCode_name(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_unsigned_long CORBA_TypeCode_member_count(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_Identifier CORBA_TypeCode_member_name(
+	CORBA_TypeCode obj,
+	CORBA_unsigned_long index,
+	CORBA_Environment *ev);
+
+extern CORBA_TypeCode CORBA_TypeCode_member_type(
+	CORBA_TypeCode obj,
+	CORBA_unsigned_long index,
+	CORBA_Environment *ev);
+
+extern CORBA_any *CORBA_TypeCode_member_label(
+	CORBA_TypeCode obj,
+	CORBA_unsigned_long index,
+	CORBA_Environment *ev);
+
+extern CORBA_TypeCode CORBA_TypeCode_discriminator_type(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_long CORBA_TypeCode_default_index(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_unsigned_long CORBA_TypeCode_length(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_TypeCode CORBA_TypeCode_content_type(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_unsigned_short CORBA_TypeCode_fixed_digits(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_short CORBA_TypeCode_fixed_scale(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_long CORBA_TypeCode_param_count(
+	CORBA_TypeCode obj,
+	CORBA_Environment *ev);
+
+extern CORBA_any *CORBA_TypeCode_parameter(
+	CORBA_TypeCode obj,
+	CORBA_long index,
+	CORBA_Environment *ev);
+
+#endif /* !_ORBIT_IR_H_ */
diff -urN linux-2.4.1/net/korbit/orb/options.c linux-2.4.1-korbit/net/korbit/orb/options.c
--- linux-2.4.1/net/korbit/orb/options.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/options.c	Thu Feb  1 11:47:12 2001
@@ -0,0 +1,160 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+/*
+ * Option parsing
+ *
+ * All ORB options are stripped from the application's argv, and argc is
+ * adjusted accordingly
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <glib.h>
+
+#include "options.h"
+
+#ifndef __KORBIT__
+void ORBit_option_set(ORBit_orb_options *option, const char *val)
+{
+	g_assert(option!=NULL);
+
+	if(option->type==no_arg && option->arg!=NULL) {
+		/* Treat as an int arg with val=1
+		*/
+		int *int_arg=(int *)option->arg;
+
+		*int_arg=1;
+	} else {
+		if(option->type==string_arg && option->arg!=NULL) {
+			char **str_arg=(char **)option->arg;
+
+			/* free any existing value */
+			if(*str_arg!=NULL) {
+				g_free(*str_arg);
+			}
+			*str_arg=g_strdup(val);
+		} else if(option->type==int_arg && option->arg!=NULL) {
+			int *int_arg=(int *)option->arg;
+
+			*int_arg=atoi(val);
+		}
+
+	}
+}
+
+void ORBit_option_parse(int *argc, char **argv, ORBit_orb_options *options)
+{
+	int i,j,numargs;
+	char name[1024], *val;
+	ORBit_orb_options *search=NULL;
+	int *erase;
+
+	numargs=*argc;
+
+	erase=g_new0(int, *argc);
+
+	for(i=1; i< *argc; i++) {
+		if(argv[i][0]!='-') {
+			if(search==NULL) {
+				/* Skip non-option */
+				continue;
+			} else {
+				/* an required option value has been found */
+				erase[i]=1;
+				numargs-=1;
+
+				if(search->arg==NULL) {
+					/* dont store any values, just strip
+					 * the argv
+					 */
+					search=NULL;
+					continue;
+				}
+
+				ORBit_option_set(search, argv[i]);
+
+				search=NULL;
+				continue;
+			}
+		} else {
+			if(search!=NULL &&
+			  (search->type==string_arg || search->type==int_arg)) {
+				fprintf(stderr, "Option %s requires an argument\n", search->name);
+			}
+		}
+
+		val=argv[i];
+		while(*val && *val=='-')
+			val++;
+
+		strncpy(name,val,1023);
+		name[1023]='\0';
+
+		val=strchr(name, '=');
+		if(val!=NULL) {
+			*val++='\0';
+		}
+
+		for(search=options;search->name!=NULL;search++) {
+			if(!strcmp(name, search->name)) {
+				break;
+			}
+		}
+
+		if(search->name==NULL) {
+			/* Didn't find it in our list of interesting options */
+			search=NULL;
+		} else {
+			/* Found it */
+			erase[i]=1;
+			numargs-=1;
+
+			if(search->type==no_arg || val!=NULL) {
+				ORBit_option_set(search, val);
+				search=NULL;
+			}
+		}
+	}
+
+	j=1;
+	for(i=1; i< *argc; i++) {
+		if(erase[i]==1) {
+			continue;
+		} else {
+			if(j<numargs) {
+				argv[j++]=argv[i];
+			} else {
+				argv[j++]='\0';
+			}
+		}
+	}
+
+	*argc=numargs;
+
+	g_free(erase);
+}
+#endif /* !__KORBIT__ */
diff -urN linux-2.4.1/net/korbit/orb/options.h linux-2.4.1-korbit/net/korbit/orb/options.h
--- linux-2.4.1/net/korbit/orb/options.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/options.h	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,46 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_OPTIONS_H_
+#define _ORBIT_OPTIONS_H_
+
+typedef enum {
+	no_arg=0,
+	string_arg,
+	int_arg
+} ORBit_opt_type;
+
+typedef struct {
+	char *name;
+	ORBit_opt_type type;
+	void *arg;
+} ORBit_orb_options;
+
+#ifndef __KORBIT__
+extern void ORBit_option_set(ORBit_orb_options *found, const char *val);
+extern void ORBit_option_parse(int *argc, char **argv, ORBit_orb_options *options);
+#endif
+
+#endif /* !_ORBIT_OPTIONS_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orb.c linux-2.4.1-korbit/net/korbit/orb/orb.c
--- linux-2.4.1/net/korbit/orb/orb.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orb.c	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,1700 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@acm.org>
+ *          Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+#define o_return_val_if_fail(expr, val) if(!(expr)) { CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM, CORBA_COMPLETED_NO); return (val); }
+#define o_return_if_fail(expr) if(!(expr)) { CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM, CORBA_COMPLETED_NO); return; }
+
+#include "config.h"
+
+#include <unistd.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#include <pwd.h>
+#include <time.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <utime.h>
+
+#include "../IIOP/iiop-endianP.h"
+#include "orbit.h"
+
+#include "orbit_poa.h"
+#include "orbit_object.h"
+#include "orbit_object_type.h"
+
+#ifndef __KERNEL__
+#define freeca(ptr)
+#endif
+
+#ifndef SUN_LEN
+/* This system is not POSIX.1g.  */
+#define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path)  \
+                      + strlen ((ptr)->sun_path))
+#endif
+
+static void ORBit_ORB_release(CORBA_ORB orb, CORBA_Environment *ev);
+
+static const ORBit_RootObject_Interface CORBA_ORB_epv =
+{
+	(void (*)(gpointer, CORBA_Environment *))ORBit_ORB_release
+};
+
+
+static int ORBit_ORBid_setup(CORBA_ORB orb, CORBA_ORBid id)
+{
+	g_assert(orb!=NULL);
+	g_assert(id!=NULL);
+
+	if(strcmp(id, "orbit-local-orb")) {
+#ifdef __KORBIT__
+		printf("ORBit_ORBid_setup: Unknown ORB id: %s\n", id);
+#else
+		fprintf(stderr, "ORBit_ORBid_setup: Unknown ORB id: %s\n", id);
+#endif
+		return(0);
+	}
+
+	orb->orb_identifier=g_strdup(id);
+
+	return(1);
+}
+
+#ifndef __KORBIT__
+static gboolean
+free_key_and_data(gpointer key, gpointer data, gpointer user_data)
+{
+	g_free(key); g_free(data);
+
+	return TRUE;
+}
+
+static void ORBit_rc_load(const char *rcfile, ORBit_orb_options *options)
+{
+	FILE *fp;
+	GHashTable *read_options;
+	ORBit_orb_options *search;
+
+	fp=fopen(rcfile, "r");
+
+	if(fp==NULL)
+		return;
+
+	read_options=g_hash_table_new(g_str_hash, g_str_equal);
+
+	while(!feof(fp)) {
+		char buf[1024];
+
+		if(fgets(buf, 1024, fp)!=NULL) {
+			guchar *bptr, *tmp, *key, *data;
+			size_t start, len;
+
+			if(buf[0]=='#')
+				continue;
+			
+			bptr=buf;
+			tmp=strpbrk(bptr, " \t\n=");
+			if(tmp==NULL) continue;
+			*tmp++='\0';
+			key=g_strdup(bptr);
+			bptr=tmp;
+
+			start=0;
+			while(bptr+start != '\0' &&
+			     (isspace(bptr[start]) || bptr[start]=='='))
+				start++;
+			len=strcspn(bptr+start, " \t\n");
+			bptr[start+len]='\0';
+			if(len>0) {
+				data=g_strdup(bptr+start);
+			} else {
+				data=g_strdup("TRUE");
+			}
+
+			g_hash_table_insert(read_options, key, data);
+		}
+	}
+	fclose(fp);
+
+	for(search=options;search->name!=NULL;search++) {
+		char *read_val;
+
+		read_val=g_hash_table_lookup(read_options, search->name);
+		if(read_val!=NULL) {
+			ORBit_option_set(search, read_val);
+		}
+	}
+
+	g_hash_table_foreach_remove(read_options, free_key_and_data, NULL);
+	g_hash_table_destroy(read_options);
+}
+#endif /* !__KORBIT__ */
+
+static void ORBit_ORB_release(CORBA_ORB orb, CORBA_Environment *ev) 
+{
+	g_assert(orb!=NULL);
+
+	if(--(ORBIT_ROOT_OBJECT(orb)->refs))
+		return;
+
+	if(orb->orb_identifier!=NULL) {
+		g_free(orb->orb_identifier);
+	}
+	if(!CORBA_Object_is_nil(orb->imr, ev)) {
+		CORBA_Object_release(orb->imr, ev); 
+	}
+	if(!CORBA_Object_is_nil(orb->ir, ev)) {
+		CORBA_Object_release(orb->ir, ev); 
+	}
+	if(!CORBA_Object_is_nil(orb->naming, ev)) {
+		CORBA_Object_release(orb->naming, ev);
+	}
+	if(!CORBA_Object_is_nil(orb->root_poa, ev)) {
+		CORBA_Object_release(orb->root_poa, ev);
+	}
+	if(orb->cnx.ipv4)
+		giop_connection_unref(orb->cnx.ipv4);
+	if(orb->cnx.ipv6)
+		giop_connection_unref(orb->cnx.ipv6);
+#ifndef __KORBIT__
+	if(orb->cnx.usock)
+		giop_connection_unref(orb->cnx.usock);
+#endif
+
+	g_free(orb);
+}
+
+#ifndef __KORBIT__
+static GIOPConnection*
+ORBit_ORB_make_usock_connection(void)
+{
+	GIOPConnection *retval = NULL;
+	GString *tmpstr;
+	struct stat statbuf;
+
+	tmpstr = g_string_new(NULL);
+
+	g_string_sprintf(tmpstr, "/tmp/orbit-%s", g_get_user_name());
+		
+	if(mkdir(tmpstr->str, 0700) != 0) {
+		int e = errno;
+			
+		switch (e) {
+		case 0:
+		case EEXIST:
+			if (stat(tmpstr->str, &statbuf) != 0)
+				g_error ("Can not stat %s\n", tmpstr->str);
+
+			if (statbuf.st_uid != getuid ())
+				g_error ("Owner of %s is not the current user\n",
+					 tmpstr->str);
+
+			if((statbuf.st_mode & (S_IRWXG|S_IRWXO))
+			   || !S_ISDIR(statbuf.st_mode))
+				g_error ("Wrong permissions for %s\n",
+					 tmpstr->str);
+			break;
+				
+		default:
+			g_error("Unknown error on directory creation of %s (%s)\n",
+				tmpstr->str, g_strerror (e));
+		}
+	}
+
+	{
+		struct utimbuf utb;
+		memset(&utb, 0, sizeof(utb));
+		utime(tmpstr->str, &utb);
+	}
+
+
+#ifdef WE_DONT_CARE_ABOUT_STUPID_2DOT0DOTX_KERNELS
+	g_string_sprintf(tmpstr, "/tmp/orbit-%s",
+			 g_get_user_name());
+	dirh = opendir(tmpstr->str);
+	while(!retval && (dent = readdir(dirh))) {
+		int usfd, ret;
+		struct sockaddr_un saddr;
+
+		saddr.sun_family = AF_UNIX;
+
+		if(strncmp(dent->d_name, "orb-", 4))
+			continue;
+
+		g_snprintf(saddr.sun_path, sizeof(saddr.sun_path),
+			   "/tmp/orbit-%s/%s",
+			   g_get_user_name(), dent->d_name);
+
+		usfd = socket(AF_UNIX, SOCK_STREAM, 0);
+		g_assert(usfd >= 0);
+
+		ret = connect(usfd, &saddr, SUN_LEN(&saddr));
+		close(usfd);
+
+		if(ret >= 0)
+			continue;
+
+		unlink(saddr.sun_path);
+	}
+	closedir(dirh);
+#endif /* WE_DONT_CARE_ABOUT_STUPID_2DOT0DOTX_KERNELS */
+
+	srand(time(NULL));
+	while(!retval) {
+		g_string_sprintf(tmpstr, "/tmp/orbit-%s/orb-%d%d",
+				 g_get_user_name(), rand(), rand());
+		retval =
+			GIOP_CONNECTION(iiop_connection_server_unix(tmpstr->str));
+	}
+
+	g_string_free(tmpstr, TRUE);
+
+	return retval;
+}
+#endif /* !__KORBIT__ */
+
+
+// Synchronize between the user process starting up the orb and the ORB thread
+// this mutex gets released when the orb is all fired up and ready to go.
+static DECLARE_MUTEX(StartupSem);
+static CORBA_ORB TheOneTrueOrb = 0;
+
+struct CORBA_ORB_init_args {  // A pointer to this struct is passed to
+	int *argc;            // __CORBA_ORB_init
+	char **argv;
+	CORBA_ORBid orb_identifier;
+	CORBA_Environment *ev;
+};
+
+
+CORBA_ORB __CORBA_ORB_init(struct CORBA_ORB_init_args *Args) {
+	int *argc = Args->argc;
+	char **argv = Args->argv;
+	CORBA_ORBid orb_identifier = Args->orb_identifier;
+	CORBA_Environment *ev = Args->ev;
+
+	int no_iiop_server=0;
+	int no_iiop_proxy=0;
+#ifdef __KORBIT__
+	int use_ipv4=1;
+#else
+	int use_ipv4=0;
+#endif
+	int use_ipv6=0;
+	int use_usock=1;
+	int debug_level=0;
+	int debug_modules=0;
+	int nosysrc=0;
+	int nouserrc=0;
+	char *imr_ior=NULL, *imr_addr=NULL;
+	char *ir_ior=NULL, *ir_addr=NULL;
+	char *naming_ior=NULL, *naming_addr=NULL;
+	char *root_poa_ior=NULL, *root_poa_addr=NULL;
+	char *orb_id_opt=NULL;
+#ifndef __KORBIT__
+	char *ctmp;
+#endif
+	CORBA_ORB orb = 0;
+
+	/* The variable addresses in these structs need to be assigned at
+	 * run-time if you want to compile with -pedantic
+	 *
+	 * (You will also get scads of warnings about "long long" too)
+	 */
+
+	ORBit_orb_options pre_rc_options[]={
+		{"ORBNoSystemRC", no_arg, NULL},
+		{"ORBNoUserRC", no_arg, NULL},
+		{NULL, 0, NULL},
+	};
+
+	/* These options are compatible with MICO */
+	ORBit_orb_options options[]={
+		{"ORBNoIIOPServer", no_arg, NULL},
+		{"ORBNoIIOPProxy", no_arg, NULL},
+		{"ORBid", string_arg, NULL},
+		{"ORBImplRepoIOR", string_arg, NULL},
+		{"ORBImplRepoAddr", string_arg, NULL},
+		{"ORBIfaceRepoIOR", string_arg, NULL},
+		{"ORBIfaceRepoAddr", string_arg, NULL},
+		{"ORBNamingIOR", string_arg, NULL},
+		{"ORBNamingAddr", string_arg, NULL},
+		{"ORBDebugLevel", int_arg, NULL},
+		{"ORBBindAddr", string_arg, NULL}, /* XXX need to make
+						      libIIOP support this */
+		{"ORBIIOPAddr", string_arg, NULL},
+
+	/* These options aren't */
+		{"ORBDebugModules", int_arg, NULL},
+		{"ORBRootPOAIOR", string_arg, NULL},
+		{"ORBRootPOAAddr", string_arg, NULL},
+		{"ORBIIOPUSock", int_arg, NULL},
+		{"ORBIIOPIPv4", int_arg, NULL},
+		{"ORBIIOPIPv6", int_arg, NULL},
+		{NULL,0,NULL},
+	};
+
+	if (ev == NULL || !argc || !argv || !orb_identifier) {
+		if (ev) {
+			CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM, 
+						   CORBA_COMPLETED_NO);
+		}
+		up(&StartupSem);   // Okay, let the insmod thread continue...
+		return 0;
+	}
+
+	pre_rc_options[0].arg = (void *) &nosysrc;
+	pre_rc_options[1].arg = (void *) &nouserrc;
+	options[0].arg = (void *) &no_iiop_server;
+	options[1].arg = (void *) &no_iiop_proxy;
+	options[2].arg = (void *) &orb_id_opt;
+	options[3].arg = (void *) &imr_ior;
+	options[4].arg = (void *) &imr_addr;
+	options[5].arg = (void *) &ir_ior;
+	options[6].arg = (void *) &ir_addr;
+	options[7].arg = (void *) &naming_ior;
+	options[8].arg = (void *) &naming_addr;
+	options[9].arg = (void *) &debug_level;
+	options[12].arg = (void *) &debug_modules;
+	options[13].arg = (void *) &root_poa_ior;
+	options[14].arg = (void *) &root_poa_addr;
+	options[15].arg = (void *) &use_usock;
+	options[16].arg = (void *) &use_ipv4;
+	options[17].arg = (void *) &use_ipv6;
+
+#ifndef __KORBIT__
+	ORBit_option_parse(argc, argv, pre_rc_options);
+
+	if(!nosysrc) {
+		ORBit_rc_load(ORBit_SYSRC, options);
+	}
+
+	if(!nouserrc) {
+		char *buf;
+
+		ctmp = g_get_home_dir();
+
+		buf = alloca(strlen(ctmp) + sizeof("/.orbitrc"));
+		sprintf(buf, "%s/.orbitrc", ctmp);
+		ORBit_rc_load(buf, options);
+		freeca(buf);
+	}
+
+	ORBit_option_parse(argc, argv, options);
+#endif /* !__KORBIT__ */
+
+	ORBit_Trace_setLevel(debug_level);
+	ORBit_Trace_setModules(debug_modules);
+
+	CORBA_exception_init(ev);
+
+	ORBit_chunks_init();
+
+	giop_init(argv[0]);
+
+	orb=g_new0(struct CORBA_ORB_type, 1);
+
+	if(orb==NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		goto error;
+	}
+
+	ORBit_pseudo_object_init(ORBIT_PSEUDO_OBJECT(orb), ORBIT_PSEUDO_ORB, ev);
+
+	ORBit_RootObject_set_interface(ORBIT_ROOT_OBJECT(orb),
+				       (gpointer)&CORBA_ORB_epv, ev);
+
+	ORBIT_ROOT_OBJECT(orb)->refs = 1;
+
+	if(orb_id_opt!=NULL) {
+		if(!ORBit_ORBid_setup(orb, orb_id_opt))
+			goto error;
+		g_free(orb_id_opt);
+	} else if(orb_identifier!=NULL) {
+		if(!ORBit_ORBid_setup(orb, orb_identifier))
+			goto error;
+	} else {
+		orb->orb_identifier=g_strdup("orbit-local-orb");
+	}
+
+	if(orb->orb_identifier==NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		goto error;
+	}
+
+	if(use_ipv4) {
+		orb->cnx.ipv4 = GIOP_CONNECTION(iiop_connection_server());
+
+		giop_connection_ref(orb->cnx.ipv4);
+		GIOP_CONNECTION(orb->cnx.ipv4)->orb_data = orb;
+	}
+
+	if(use_ipv6) {
+		orb->cnx.ipv6 = GIOP_CONNECTION(iiop_connection_server_ipv6());
+		giop_connection_ref(orb->cnx.ipv6);
+		GIOP_CONNECTION(orb->cnx.ipv6)->orb_data = orb;
+	}
+
+#ifndef __KORBIT__
+	if(use_usock) {
+		orb->cnx.usock = ORBit_ORB_make_usock_connection();
+
+		giop_connection_ref(orb->cnx.usock);
+		GIOP_CONNECTION(orb->cnx.usock)->orb_data = orb;
+	}
+#endif
+
+	orb->objrefs = g_hash_table_new((GHashFunc)g_CORBA_Object_hash,
+					(GCompareFunc)g_CORBA_Object_equal);
+	orb->poas = g_ptr_array_new();
+
+	/* when I figure out what MICO is doing with the iiop_proxy and
+	 * iiop_server stuff, it'll get handled here.
+	 */
+
+	/*
+	 * Connect to / create implementation repository
+	 */
+
+	{
+		CORBA_Object imr=NULL;
+
+		if(imr_ior!=NULL) {
+			imr=CORBA_ORB_string_to_object(orb, imr_ior, ev);
+			g_free(imr_ior);
+		} else if(imr_addr!=NULL) {
+			/*imr=CORBA_ORB_bind(orb, "IDL:omg.org/CORBA/ImplRepository:1.0", imr_addr, ev);*/
+			g_free(imr_addr);
+		}
+
+		if(!CORBA_Object_is_nil(imr, ev)) {
+			CORBA_ORB_set_initial_reference(orb, "ImplementationRepository", imr, ev);
+		}
+	}
+
+	/*
+	 * Connect to / create interface repository
+	 */
+
+	{
+		CORBA_Object ir=NULL;
+
+		if(ir_ior!=NULL) {
+			ir=CORBA_ORB_string_to_object(orb, ir_ior, ev);
+			g_free(ir_ior);
+		} else if(ir_addr!=NULL) {
+			/*ir=CORBA_ORB_bind(orb, "IDL:omg.org/CORBA/Repository:1.0", ir_addr, ev);*/
+			g_free(ir_addr);
+		}
+
+		if(!CORBA_Object_is_nil(ir, ev)) {
+			CORBA_ORB_set_initial_reference(orb, "InterfaceRepository", ir, ev);
+		}
+	}
+
+	/*
+	 * Connect to naming service
+	 */
+
+	{
+		CORBA_Object naming=NULL;
+
+		if(naming_ior!=NULL) {
+			naming=CORBA_ORB_string_to_object(orb, naming_ior, ev);
+			g_free(naming_ior);
+		} else if(naming_addr!=NULL) {
+			/*CORBA_ORB_ObjectTag tag=CORBA_ORB_string_to_tag(orb, "root", ev);*/
+
+			/*naming=CORBA_ORB_bind_tag(orb, "IDL:omg.org/CosNaming/NamingContext:1.0", tag, naming_addr, ev);*/
+			g_free(naming_addr);
+		}
+
+		if(!CORBA_Object_is_nil(naming, ev)) {
+			CORBA_ORB_set_initial_reference(orb, "NameService", naming, ev);
+		}
+	}
+
+	/*
+	 * Connect to / create RootPOA
+	 */
+
+	{
+		PortableServer_POA root_poa=CORBA_OBJECT_NIL;
+	  
+		if(root_poa_ior!=NULL) {
+			root_poa=(PortableServer_POA)
+				CORBA_ORB_string_to_object(orb,
+							   root_poa_ior, ev);
+			g_free(root_poa_ior);
+		}
+		       
+		/* And attatch it to the orb */
+
+		if(!CORBA_Object_is_nil((CORBA_Object)root_poa, ev)) {
+			CORBA_ORB_set_initial_reference((CORBA_ORB)orb,
+							"RootPOA",
+							(CORBA_Object)root_poa,
+							ev);
+		}
+	}
+
+	ORBit_custom_run_setup(orb, ev);
+
+	if (!strcmp("server", argv[0]))  // Only do this for servers.
+		TheOneTrueOrb = orb;
+	up(&StartupSem);   // Okay, let the insmod thread continue...
+	return orb;
+
+error:
+	if(orb!=NULL) {
+		ORBit_ORB_release(orb, ev);
+		orb = NULL;
+	}
+	g_free(imr_ior);
+	g_free(imr_addr);
+	g_free(ir_ior);
+	g_free(ir_addr);
+	g_free(naming_ior);
+	g_free(naming_addr);
+	g_free(root_poa_ior);
+	g_free(root_poa_addr);
+	g_free(orb_id_opt);
+
+	TheOneTrueOrb = 0;
+	up(&StartupSem);   // Okay, let the insmod thread continue...
+	return 0;
+}
+
+
+#if __KERNEL__
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+
+// This is the main corba thread function...
+//
+void __CORBA_ORB_run(CORBA_ORB orb, CORBA_Environment *ev);
+int MainCORBAThread(void *Args) {
+	// Make a directory in /proc... yaay...
+	proc_mkdir("corba", 0);
+
+	__CORBA_ORB_init((struct CORBA_ORB_init_args*)Args);
+	if (TheOneTrueOrb == 0) return 0;
+
+	strcpy(current->comm, "korbit"); // Set the thread name...
+
+	lock_kernel();   /* This seems to be required for exit_mm */
+	exit_mm(current);
+
+	__CORBA_ORB_run(TheOneTrueOrb, 
+			((struct CORBA_ORB_init_args*)Args)->ev);
+	return 0;
+}
+#endif
+
+
+/* Section 4.4
+ *
+ * Adjusts argc and argv appropriately
+ */
+
+CORBA_ORB CORBA_ORB_init(int *argc, char **argv, CORBA_ORBid orb_identifier, 
+			 CORBA_Environment *ev) {
+
+	struct CORBA_ORB_init_args Args;
+	Args.argc = argc;
+	Args.argv = argv;
+	Args.orb_identifier = orb_identifier;
+	Args.ev = ev;
+
+#ifdef __KERNEL__
+	if (!strcmp(argv[0], "server")) {             // Are we a server?
+		down(&StartupSem);  // Grab the semaphore...
+		if (TheOneTrueOrb) {
+			CORBA_exception_init(ev);
+			goto out_success;
+		}
+
+		// This releases the semaphore when it is done initializing.
+		(void)kernel_thread(MainCORBAThread, &Args, 
+				    CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
+
+		// This will block until the semaphore is released by the 
+		// ORB thread.
+		down(&StartupSem);
+	} else {       // If we are a corba client, like CorbaFS...
+		return __CORBA_ORB_init(&Args);
+	}
+
+ out_success:
+	up(&StartupSem);   // Okay, we're now here. 
+#else
+	__CORBA_ORB_init(&Args);
+#endif
+	if (TheOneTrueOrb) 
+		return (CORBA_ORB)CORBA_Object_duplicate((CORBA_Object)TheOneTrueOrb, ev);
+	return 0;
+}
+
+
+
+
+typedef struct {
+	CORBA_Object obj;
+	CDR_Codec *codec;
+	gboolean emit_active;
+} profile_user_data;
+
+static void ORBit_emit_profile(gpointer item, gpointer userdata)
+{
+	ORBit_Object_info *profile=(ORBit_Object_info *)item;
+	profile_user_data *data=(profile_user_data *)userdata;
+	CORBA_Object obj=data->obj;
+	CDR_Codec encaps_codec_d;
+	CDR_Codec *codec=data->codec, *encaps = &encaps_codec_d;
+	gboolean emit_active=data->emit_active;
+	static const CORBA_octet iiopversion[] = {1,0};
+	CORBA_octet codecbuf[2048];
+
+	g_assert(obj!=NULL);
+	g_assert(codec!=NULL);
+	g_assert(profile!=NULL);
+
+	if((profile == obj->active_profile) && (emit_active == FALSE))
+		return;			/* we already did this one */
+
+	switch(profile->profile_type) {
+	case IOP_TAG_INTERNET_IOP:
+		CDR_codec_init_static(encaps);
+		encaps->buffer = codecbuf;
+		encaps->release_buffer = CORBA_FALSE;
+		encaps->buf_len = 2048;
+		encaps->readonly = CORBA_FALSE;
+		encaps->host_endian = encaps->data_endian = FLAG_ENDIANNESS;
+
+		CDR_put_ulong(codec, IOP_TAG_INTERNET_IOP);
+		CDR_put_octet(encaps, FLAG_ENDIANNESS);
+		CDR_put_octets(encaps, (gpointer)iiopversion, sizeof(iiopversion));
+		CDR_put_string(encaps, profile->tag.iopinfo.host);
+		CDR_put_ushort(encaps, profile->tag.iopinfo.port);
+		CDR_put_ulong(encaps, profile->object_key._length);
+		CDR_put_octets(encaps, profile->object_key._buffer,
+			       profile->object_key._length);
+		CDR_put_ulong(codec, encaps->wptr);
+		CDR_put_octets(codec, encaps->buffer, encaps->wptr);
+		break;
+
+	case IOP_TAG_ORBIT_SPECIFIC:
+		CDR_codec_init_static(encaps);
+		encaps->buffer = codecbuf;
+		encaps->release_buffer = CORBA_FALSE;
+		encaps->buf_len = 2048;
+		encaps->readonly = CORBA_FALSE;
+		encaps->host_endian = encaps->data_endian = FLAG_ENDIANNESS;
+
+		CDR_put_ulong(codec, IOP_TAG_ORBIT_SPECIFIC);
+		CDR_put_octet(encaps, FLAG_ENDIANNESS);
+		CDR_put_octets(encaps, (gpointer)iiopversion, sizeof(iiopversion));
+		CDR_put_string(encaps, profile->tag.orbitinfo.unix_sock_path);
+		CDR_put_ushort(encaps, profile->tag.orbitinfo.ipv6_port);
+		CDR_put_ulong(encaps, profile->object_key._length);
+		CDR_put_octets(encaps, profile->object_key._buffer,
+			profile->object_key._length);
+		CDR_put_ulong(codec, encaps->wptr);
+		CDR_put_octets(codec, encaps->buffer, encaps->wptr);
+		break;
+
+	default:
+		g_warning("Skipping tag %d", profile->profile_type);
+		break;
+	}
+}
+
+CORBA_char *CORBA_ORB_object_to_string(CORBA_ORB orb,
+				       CORBA_Object obj,
+				       CORBA_Environment *ev)
+{
+  int i;
+  CDR_Codec codec_d;
+  CDR_Codec *codec = &codec_d;
+  CORBA_char *rc = NULL;
+  CORBA_unsigned_long ntags;
+  profile_user_data data;
+  CORBA_octet codecbuf[2048];
+  char *ctmp;
+
+  g_return_val_if_fail(ev, NULL);
+  o_return_val_if_fail(orb && obj, NULL);
+
+  if(!obj || !orb) {
+	  CORBA_exception_set_system(ev,
+				     ex_CORBA_BAD_PARAM,
+				     CORBA_COMPLETED_NO);
+	  return NULL;
+  }
+
+  if(ORBIT_ROOT_OBJECT(obj)->is_pseudo_object) {
+	  CORBA_exception_set_system(ev,
+				     ex_CORBA_MARSHAL,
+				     CORBA_COMPLETED_NO);
+	  return NULL;
+  }
+
+  CDR_codec_init_static(codec);
+
+  codec->buffer = codecbuf;
+  codec->release_buffer = CORBA_FALSE;
+  codec->buf_len = 2048;
+  codec->readonly = CORBA_FALSE;
+  codec->host_endian = codec->data_endian = FLAG_ENDIANNESS;
+
+  CDR_put_octet(codec, FLAG_ENDIANNESS);
+
+  CDR_put_string(codec, obj->object_id);
+  ntags = g_slist_length(obj->profile_list);
+  CDR_put_ulong(codec, ntags);
+
+  data.obj=obj;
+  data.codec=codec;
+  data.emit_active=TRUE;
+  if(obj->active_profile != NULL)
+	  ORBit_emit_profile(obj->active_profile, &data); /* do this one first */
+
+  data.emit_active=FALSE;
+  g_slist_foreach(obj->profile_list, ORBit_emit_profile, &data);
+
+  rc = CORBA_string_alloc(4 + (codec->wptr * 2) + 1);
+  strcpy(rc, "IOR:");
+
+#define hexdigit(n) (((n)>9)?(n+'a'-10):(n+'0'))
+
+  for(i = 0, ctmp = rc + strlen("IOR:"); i < codec->wptr; i++) {
+	  *(ctmp++) = hexdigit((((codec->buffer[i]) & 0xF0) >> 4));
+	  *(ctmp++) = hexdigit(((codec->buffer[i]) & 0xF));
+  }
+  *ctmp = '\0';
+
+  {
+	  /* Debug check */
+	  CORBA_Object obj;
+	  CORBA_Environment myev;
+
+	  CORBA_exception_init(&myev);
+
+	  obj = CORBA_ORB_string_to_object(orb, rc, &myev);
+
+	  if (CORBA_Object_is_nil(obj, &myev)) {
+		  g_warning("Bug in %s, created bad IOR `%s'\n",
+			    __FUNCTION__, rc);
+		  CORBA_free(rc);
+		  return NULL;
+	  }
+			  
+	  CORBA_Object_release(obj, &myev);
+  }
+  
+  return rc;
+}
+
+/* Quote from the GNU libc manual:
+
+   "If you try to allocate more storage than the machine can provide,
+    you don't get a clean error message. Instead you get a fatal
+    signal like the one you would get from an infinite recursion;
+    probably a segmentation violation (see section Program Error
+    Signals)."
+
+   The man page claims alloca() returns NULL on failure; this appears
+   to be a load of shit on Linux where you just get flaming death, but
+   we check anyway in case other systems work that way.
+
+   On Linux we check that the size is less than MAX_STACK_ALLOC
+
+   Note that the CORBA_alloc() calls in here can still cause
+   program abort, and really that should be fixed in a similar
+   way since our lengths are coming in from unpredictable sources
+   like files or the network.
+*/
+
+#define MAX_STACK_ALLOC 8192
+
+CORBA_Object CORBA_ORB_string_to_object(CORBA_ORB orb, CORBA_char *str,
+					CORBA_Environment *ev)
+{
+	GSList *profiles=NULL;
+	CORBA_Object retval = NULL;
+	CORBA_char *type_id;
+	ORBit_Object_info *object_info;
+	CDR_Codec codec_d, encaps_codec_d;
+	CDR_Codec *codec = &codec_d, *encaps_codec = &encaps_codec_d;
+	CORBA_octet *buffer, endian;
+	int i, j;
+	CORBA_unsigned_long len, seq_len, misclen;
+
+	g_return_val_if_fail(ev, CORBA_OBJECT_NIL);
+	o_return_val_if_fail(orb && str, CORBA_OBJECT_NIL);
+
+	if(strncmp(str, "IOR:", 4)) {
+		CORBA_exception_set_system(ev, ex_CORBA_MARSHAL,
+					   CORBA_COMPLETED_NO);
+		return(CORBA_OBJECT_NIL);
+	}
+
+	CDR_codec_init_static(codec);
+	len = strlen(str);
+
+	if((len % 2) || len <= 4) {
+		CORBA_exception_set_system(ev, ex_CORBA_MARSHAL,
+					   CORBA_COMPLETED_NO);
+		return(CORBA_OBJECT_NIL);
+	}
+
+	codec->buf_len = (len-4)/2;
+	buffer = alloca(codec->buf_len);
+
+	codec->buffer=buffer;
+	codec->release_buffer = CORBA_FALSE;
+	codec->readonly = TRUE;
+
+	for(j = 0, i = 4; i < len; i+=2) {
+		buffer[j++] = HEXOCTET(str[i], str[i+1]);
+	};
+
+	CDR_get_octet(codec, &endian);
+
+	codec->data_endian = endian;
+	codec->host_endian = FLAG_ENDIANNESS;
+
+	CDR_get_string_static(codec, &type_id);
+
+	CDR_get_seq_begin(codec, &seq_len);
+
+	for(i = 0; i < seq_len; i++) {
+		IOP_ProfileId tag;
+
+		object_info=g_new0(ORBit_Object_info, 1);
+
+		if (!CDR_get_ulong(codec, &tag))
+			goto error_out;
+
+		switch(tag) {
+		case IOP_TAG_INTERNET_IOP:
+			if (!CDR_get_ulong(codec, &misclen))
+				goto error_out;
+			
+			CDR_codec_init_static(encaps_codec);
+
+			if (misclen > MAX_STACK_ALLOC)
+				goto error_out;
+			
+			encaps_codec->buffer = alloca(misclen);
+			if (encaps_codec->buffer == NULL)
+				/* misclen was probably junk */
+				goto error_out;
+			
+			encaps_codec->release_buffer = FALSE;
+			if(!CDR_buffer_gets(codec, encaps_codec->buffer, misclen))
+				goto error_out;
+
+			encaps_codec->buf_len = misclen;
+			encaps_codec->readonly = CORBA_TRUE;
+			if(!CDR_get_octet(encaps_codec, &endian))
+				goto error_out;
+			encaps_codec->data_endian = endian;
+			encaps_codec->host_endian = FLAG_ENDIANNESS;
+
+			if (encaps_codec->data_endian > 1)
+				goto error_out;
+			
+			object_info->profile_type = IOP_TAG_INTERNET_IOP;
+			if(!CDR_get_octet(encaps_codec, &object_info->iiop_major))
+				goto error_out;
+			if(object_info->iiop_major != 1)
+				goto error_out;
+			if(!CDR_get_octet(encaps_codec, &object_info->iiop_minor))
+				goto error_out;
+			if(!CDR_get_string(encaps_codec, &object_info->tag.iopinfo.host))
+				goto error_out;
+			if(!CDR_get_ushort(encaps_codec, &object_info->tag.iopinfo.port))
+				goto error_out;
+			if(!CDR_get_seq_begin(encaps_codec, &object_info->object_key._length))
+				goto error_out;
+
+			object_info->object_key._maximum = 0;
+
+			/* The POA gives out ORBit_alloc()d profiles, so we have to too */
+			object_info->object_key._buffer = ORBit_alloc(object_info->object_key._length, NULL, NULL);
+			if(!CDR_buffer_gets(encaps_codec, object_info->object_key._buffer,
+					    object_info->object_key._length))
+				goto error_out;
+
+			ORBit_set_object_key(object_info);
+			profiles=g_slist_append(profiles, object_info);
+			break;
+
+		case IOP_TAG_MULTIPLE_COMPONENTS:
+			/* Just skip any multiple_components data, for now */
+			if(!CDR_get_ulong(codec, &misclen))
+				goto error_out;
+
+			CDR_codec_init_static(encaps_codec);
+
+			if (misclen > MAX_STACK_ALLOC)
+				goto error_out;
+			
+			encaps_codec->buf_len = misclen;
+			encaps_codec->buffer = alloca(misclen);
+			if (encaps_codec->buffer == NULL)
+				/* misclen was probably junk */
+				goto error_out;
+
+			encaps_codec->release_buffer = FALSE;
+			encaps_codec->readonly = CORBA_TRUE;
+			if(!CDR_buffer_gets(codec, encaps_codec->buffer, misclen))
+				goto error_out;
+			break;
+
+		case IOP_TAG_ORBIT_SPECIFIC:
+			if(!CDR_get_ulong(codec, &misclen))
+				goto error_out;
+
+			CDR_codec_init_static(encaps_codec);
+
+			if (misclen > MAX_STACK_ALLOC)
+				goto error_out;
+			
+			encaps_codec->buffer = alloca(misclen);
+			if (encaps_codec->buffer == NULL)
+				/* misclen was probably junk */
+				goto error_out;
+			
+			encaps_codec->release_buffer = FALSE;
+			if(!CDR_buffer_gets(codec, encaps_codec->buffer, misclen))
+				goto error_out;
+
+			encaps_codec->buf_len = misclen;
+			encaps_codec->readonly = CORBA_TRUE;
+
+			if(!CDR_get_octet(encaps_codec, &endian))
+				goto error_out;
+
+			encaps_codec->data_endian = endian;
+			encaps_codec->host_endian = FLAG_ENDIANNESS;
+
+			if (encaps_codec->data_endian > 1)
+				goto error_out;
+			
+			object_info->profile_type=IOP_TAG_ORBIT_SPECIFIC;
+			if(!CDR_get_octet(encaps_codec, &object_info->iiop_major))
+				goto error_out;
+
+			if(object_info->iiop_major != 1)
+				goto error_out;
+			if(!CDR_get_octet(encaps_codec, &object_info->iiop_minor))
+				goto error_out;
+
+			if(!CDR_get_string(encaps_codec, &object_info->tag.orbitinfo.unix_sock_path))
+				goto error_out;
+
+			if(!CDR_get_ushort(encaps_codec, &object_info->tag.orbitinfo.ipv6_port))
+				goto error_out;
+			if(!CDR_get_seq_begin(encaps_codec, &object_info->object_key._length))
+				goto error_out;
+			object_info->object_key._maximum = 0;
+
+			/* The POA gives out ORBit_alloc()d profiles, so we have to too */
+			object_info->object_key._buffer = ORBit_alloc(object_info->object_key._length, NULL, NULL);
+			if(!CDR_buffer_gets(encaps_codec, object_info->object_key._buffer,
+					    object_info->object_key._length))
+				goto error_out;
+
+			ORBit_set_object_key(object_info);
+			profiles=g_slist_append(profiles, object_info);
+			break;
+		default:
+			g_warning("Unknown tag 0x%x", tag);
+
+			/* Skip it */
+			if(!CDR_get_ulong(codec, &misclen))
+				goto error_out;
+
+			CDR_codec_init_static(encaps_codec);
+
+			if (misclen > MAX_STACK_ALLOC)
+				goto error_out;
+			
+			encaps_codec->buf_len = misclen;
+			encaps_codec->buffer = alloca(misclen);
+			if (encaps_codec->buffer == NULL)
+				/* misclen was probably junk */
+				goto error_out;
+
+			encaps_codec->release_buffer = FALSE;
+			encaps_codec->readonly = CORBA_TRUE;
+			if(!CDR_buffer_gets(codec, encaps_codec->buffer, misclen))
+				goto error_out;
+
+			break;
+		}
+	}
+
+	freeca(buffer); /* Same as codec->buffer */
+	freeca(encaps_codec->buffer);
+	
+	return ORBit_create_object_with_info(profiles, type_id, orb, ev);
+
+ error_out:
+
+	if(object_info) {
+		CORBA_free(object_info->object_key._buffer);
+		g_free(object_info);
+		ORBit_delete_profiles(profiles);
+	}
+
+	freeca(buffer); /* Same as codec->buffer */
+	freeca(encaps_codec->buffer);
+
+	return retval;
+}
+
+/* Section 4.1.2 */
+CORBA_boolean CORBA_ORB_get_service_information(CORBA_ORB orb, CORBA_ServiceType service_type, CORBA_ServiceInformation *service_information, CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(CORBA_FALSE);
+}
+
+CORBA_Current *CORBA_ORB_get_current(CORBA_ORB orb, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(ev, NULL);
+	o_return_val_if_fail(orb, NULL);
+
+	/* XXX check this over */
+	return (CORBA_Current *)GET_THREAD_DATA();
+}
+
+/* Section 4.5 */
+CORBA_ORB_ObjectIdList *CORBA_ORB_list_initial_services(CORBA_ORB orb, CORBA_Environment *ev)
+{
+	static const char *services[] = {"RootPOA"};
+	CORBA_ORB_ObjectIdList *list;
+
+	g_return_val_if_fail(ev, NULL);
+	o_return_val_if_fail(orb, NULL);
+
+	list = (CORBA_ORB_ObjectIdList *)CORBA_sequence_octet__alloc();
+	list->_maximum=list->_length= 1;
+	list->_buffer = (CORBA_ORB_ObjectId *)services;
+	CORBA_sequence_set_release((void *)list, CORBA_FALSE);
+
+	/* defined reserved references are:
+	 *	RootPOA
+	 *	POACurrent
+	 *	InterfaceRepository
+	 *	NameService
+	 *	TradingService
+	 *	SecurityCurrent
+	 *	TransactionCurrent
+	 */
+
+	return list;
+}
+
+/* Section 4.5
+ *
+ * raises InvalidName
+ */
+CORBA_Object CORBA_ORB_resolve_initial_references(CORBA_ORB orb, CORBA_ORB_ObjectId identifier, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(ev, CORBA_OBJECT_NIL);
+	o_return_val_if_fail(orb, CORBA_OBJECT_NIL);
+
+	if(!strcmp(identifier, "ImplementationRepository"))
+		return CORBA_Object_duplicate(orb->imr, ev);
+	else if(!strcmp(identifier, "InterfaceRepository"))
+		return CORBA_Object_duplicate(orb->ir, ev);
+	else if(!strcmp(identifier, "NameService"))
+		return CORBA_Object_duplicate(orb->naming, ev);
+	else if(!strcmp(identifier, "RootPOA")) {
+		if(CORBA_Object_is_nil(orb->root_poa, ev)) {
+			CORBA_PolicyList policies = {0,0,NULL,CORBA_FALSE};
+			PortableServer_POAManager poa_mgr;
+			/* Create a poa manager */
+			poa_mgr = ORBit_POAManager_new(ev);
+			poa_mgr->orb = orb;
+
+			/* Create the root poa */
+			orb->root_poa = (CORBA_Object)
+				ORBit_POA_new(orb,
+					      "RootPOA",
+					      poa_mgr,
+					      &policies,
+					      ev);
+			CORBA_Object_duplicate(orb->root_poa, ev);
+		}
+
+		return CORBA_Object_duplicate(orb->root_poa, ev);
+	}
+
+	/* throw user exception: InvalidName */
+	CORBA_exception_set(ev,CORBA_USER_EXCEPTION,
+			    ex_CORBA_ORB_InvalidName,
+			    NULL);
+
+	goto error;
+error:
+	return(NULL);
+}
+
+/* This is a MICO extension
+ *
+ * raises InvalidName
+ */
+void CORBA_ORB_set_initial_reference(CORBA_ORB orb, CORBA_ORB_ObjectId identifier, CORBA_Object obj, CORBA_Environment *ev)
+{
+	g_return_if_fail(ev);
+	o_return_if_fail(orb && identifier && obj);
+
+	if(!strcmp(identifier, "ImplementationRepository")) {
+		if(!CORBA_Object_is_nil(orb->imr, ev)) {
+			CORBA_Object_release(orb->imr, ev);
+		}
+		orb->imr=CORBA_Object_duplicate(obj, ev);
+	} else if(!strcmp(identifier, "InterfaceRepository")) {
+		if(!CORBA_Object_is_nil(orb->ir, ev)) {
+			CORBA_Object_release(orb->ir, ev);
+		}
+		orb->ir=CORBA_Object_duplicate(obj, ev);
+	} else if(!strcmp(identifier, "NameService")) {
+		if(!CORBA_Object_is_nil(orb->naming, ev)) {
+			CORBA_Object_release(orb->naming, ev);
+		}
+		orb->naming=CORBA_Object_duplicate(obj, ev);
+	} else if(!strcmp(identifier, "RootPOA")) {
+		if(!CORBA_Object_is_nil(orb->root_poa, ev)) {
+			CORBA_Object_release(orb->root_poa, ev);
+		}
+		orb->root_poa=CORBA_Object_duplicate(obj, ev);
+	} else {
+		/* throw user exception: InvalidName */
+		CORBA_exception_set(ev,CORBA_USER_EXCEPTION,ex_CORBA_ORB_InvalidName,NULL);	
+		goto error;
+	}
+
+	return;
+error:
+	return;
+}
+
+/* Section 4.9.1 */
+CORBA_boolean CORBA_ORB_work_pending(CORBA_ORB orb, CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(CORBA_FALSE);
+}
+
+/* Section 4.9.2 */
+void CORBA_ORB_perform_work(CORBA_ORB orb, CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return;
+}
+
+/* Section 4.9.4 */
+void
+CORBA_ORB_shutdown(CORBA_ORB orb,
+		   CORBA_boolean wait_for_completion,
+		   CORBA_Environment *ev)
+{
+	g_return_if_fail(ev);
+	o_return_if_fail(orb);
+
+	/* XXX implement on a per-ORB basis, and also
+	   handle whatever wait_for_completion means */
+
+	if(orb->cnx.ipv4)
+		giop_connection_unref(orb->cnx.ipv4);
+	if(orb->cnx.ipv6)
+		giop_connection_unref(orb->cnx.ipv6);
+#ifndef __KORBIT__
+	if(orb->cnx.usock)
+		giop_connection_unref(orb->cnx.usock);
+#endif
+
+	giop_main_quit();
+}
+
+/* Section 4.9.3 */
+/* CORBA_ORB_run is in server.c */
+
+/* Section 4.7 */
+CORBA_PolicyType
+CORBA_Policy__get_policy_type(CORBA_Policy obj, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(ev, 0);
+	o_return_val_if_fail(obj, 0);
+
+	return obj->policy_type;
+}
+
+/* Section 4.7 */
+CORBA_Policy CORBA_Policy_copy(CORBA_Policy obj, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(ev, CORBA_OBJECT_NIL);
+	o_return_val_if_fail(obj, CORBA_OBJECT_NIL);
+
+	ORBIT_ROOT_OBJECT_REF(obj);
+
+	return obj;
+}
+
+/* Section 4.7
+ *
+ * raises CORBA_NO_PERMISSION
+ */
+void CORBA_Policy_destroy(CORBA_Policy obj, CORBA_Environment *ev)
+{
+	g_return_if_fail(ev);
+	o_return_if_fail(obj);
+
+	ORBIT_ROOT_OBJECT_UNREF(obj);
+	if(ORBIT_ROOT_OBJECT(obj)->refs <= 0)
+		ORBIT_ROOT_OBJECT_release(obj, ev);
+}
+
+#ifndef __KORBIT__
+/* Section 4.8.2 */
+CORBA_Policy CORBA_DomainManager_get_domain_policy(CORBA_DomainManager obj, CORBA_PolicyType policy_type, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(ev, CORBA_OBJECT_NIL);
+	o_return_val_if_fail(obj, CORBA_OBJECT_NIL);
+
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+/* Section 4.8.2 */
+void CORBA_ConstructionPolicy_make_domain_manager(CORBA_ConstructionPolicy obj, CORBA_InterfaceDef object_type, CORBA_boolean constr_policy, CORBA_Environment *
+ev)
+{
+	g_return_if_fail(ev);
+	o_return_if_fail(obj && object_type);
+
+	g_assert(!"Not yet implemented");
+	return;
+}
+
+/* Section 4.2.8 */
+CORBA_DomainManagerList *CORBA_Object_get_domain_managers(CORBA_Object obj, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(ev, NULL);
+	o_return_val_if_fail(obj, NULL);
+
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+CORBA_TypeCode CORBA_ORB_create_struct_tc(CORBA_ORB obj, CORBA_RepositoryId id, CORBA_Identifier name, CORBA_StructMemberSeq members, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+	int i;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc == NULL)
+	  goto tc_alloc_failed;
+
+	tc->subtypes=g_new0(CORBA_TypeCode, members._length);
+	if(tc->subtypes == NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->subnames=g_new0(char *, members._length);
+	if(tc->subnames == NULL)
+	  goto subnames_alloc_failed;
+
+	tc->kind=CORBA_tk_struct;
+	tc->name=g_strdup(name);
+	tc->repo_id=g_strdup(id);
+	tc->sub_parts=members._length;
+	tc->length=members._length;
+
+	for(i=0;i<members._length;i++) {
+		CORBA_StructMember *mem=(CORBA_StructMember *)&(members._buffer[i]);
+
+		g_assert(&(mem->type)!=NULL);
+
+		tc->subtypes[i] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+		memcpy(tc->subtypes[i], mem->type, (size_t)sizeof(struct CORBA_TypeCode_struct));
+		tc->subnames[i]=g_strdup(mem->name);
+	}
+
+	return(tc);
+
+ subnames_alloc_failed:
+	g_free(tc->subtypes);
+ subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return NULL;
+}
+
+CORBA_TypeCode 
+CORBA_ORB_create_union_tc(CORBA_ORB obj, CORBA_RepositoryId id,
+			  CORBA_Identifier name,
+			  CORBA_TypeCode discriminator_type,
+			  CORBA_UnionMemberSeq members,
+			  CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+	int i;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+
+	if(tc == NULL)
+	  goto tc_alloc_failed;
+
+	tc->discriminator = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+
+	if(tc->discriminator == NULL)
+	  goto discriminator_alloc_failed;
+
+	memcpy(tc->discriminator, discriminator_type, (size_t)sizeof(CORBA_TypeCode));
+
+	tc->subtypes=g_new0(CORBA_TypeCode, members._length);
+	if(tc->subtypes==NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->subnames=g_new0(char *, members._length);
+	if(tc->subnames==NULL)
+	  goto subnames_alloc_failed;
+
+	tc->sublabels=g_new0(CORBA_any, members._length);
+	if(tc->sublabels == NULL)
+	  goto sublabels_alloc_failed;
+
+	tc->kind=CORBA_tk_union;
+	tc->name=g_strdup(name);
+	tc->repo_id=g_strdup(id);
+	tc->sub_parts=members._length;
+	tc->length=members._length;
+	tc->default_index=-1;
+
+	for(i=0;i<members._length;i++) {
+		CORBA_UnionMember *mem=(CORBA_UnionMember *)&(members._buffer[i]);
+
+		g_assert(&(mem->label)!=NULL);
+		memcpy(&(tc->sublabels[i]), &(mem->label), (size_t)sizeof(CORBA_any));
+		g_assert(&(mem->type)!=NULL);
+		tc->subtypes[i] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+		memcpy(tc->subtypes[i], mem->type, (size_t)sizeof(struct CORBA_TypeCode_struct));
+		tc->subnames[i]=g_strdup(mem->name);
+
+		if(mem->label._type->kind==CORBA_tk_octet) {
+			tc->default_index=i;
+		}
+	}
+
+	return(tc);
+
+sublabels_alloc_failed:
+	g_free(tc->sublabels);
+subnames_alloc_failed:
+	g_free(tc->subtypes);
+subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc->discriminator);
+discriminator_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return NULL;
+}
+
+CORBA_TypeCode CORBA_ORB_create_enum_tc(CORBA_ORB obj, CORBA_RepositoryId id, CORBA_Identifier name, CORBA_EnumMemberSeq members, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+	int i;
+
+	tc = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc == NULL)
+	  goto tc_alloc_failed;
+
+	tc->subnames=g_new0(char *, members._length);
+	if(tc->subnames==NULL)
+	  goto subnames_alloc_failed;
+
+	tc->kind = CORBA_tk_enum;
+	tc->name = g_strdup(name);
+	tc->repo_id = g_strdup(id);
+	tc->sub_parts = members._length;
+	tc->length = members._length;
+
+	for(i=0;i<members._length;i++) {
+		tc->subnames[i]=g_strdup(members._buffer[i]);
+	}
+
+	return(tc);
+
+ subnames_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return(NULL);
+}
+
+CORBA_TypeCode CORBA_ORB_create_alias_tc(CORBA_ORB obj, CORBA_RepositoryId id, CORBA_Identifier name, CORBA_TypeCode original_type, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL)
+	  goto tc_alloc_failed;
+	
+	/* Can't use chunks here, because it's sometimes an array. Doh! */
+	tc->subtypes=g_new0(CORBA_TypeCode, 1);
+	if(tc->subtypes==NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->kind=CORBA_tk_alias;
+	tc->name=g_strdup(name);
+	tc->repo_id=g_strdup(id);
+	tc->sub_parts=1;
+	tc->length=1;
+
+	tc->subtypes[0] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	memcpy(tc->subtypes[0], original_type, (size_t)sizeof(struct CORBA_TypeCode_struct));
+
+	return(tc);
+ subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return NULL;
+}
+
+CORBA_TypeCode CORBA_ORB_create_exception_tc(CORBA_ORB obj, CORBA_RepositoryId id, CORBA_Identifier name, CORBA_StructMemberSeq members, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+	int i;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL)
+	  goto tc_alloc_failed;
+
+	tc->subtypes=g_new0(CORBA_TypeCode, members._length);
+	if(tc->subtypes==NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->subnames=g_new0(char *, members._length);
+	if(tc->subnames==NULL)
+	  goto subnames_alloc_failed;
+
+	tc->kind=CORBA_tk_except;
+	tc->name=g_strdup(name);
+	tc->repo_id=g_strdup(id);
+	tc->sub_parts=members._length;
+	tc->length=members._length;
+
+	for(i=0;i<members._length;i++) {
+		CORBA_StructMember *mem=(CORBA_StructMember *)&(members._buffer[i]);
+
+		g_assert(mem->type != NULL);
+		tc->subtypes[i] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+		memcpy(tc->subtypes[i], mem->type, (size_t)sizeof(struct CORBA_TypeCode_struct));
+		tc->subnames[i]=g_strdup(mem->name);
+	}
+
+	return(tc);
+
+ subnames_alloc_failed:
+	g_free(tc->subtypes);
+ subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return(NULL);
+}
+
+CORBA_TypeCode CORBA_ORB_create_interface_tc(CORBA_ORB obj, CORBA_RepositoryId id, CORBA_Identifier name, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY,
+					   CORBA_COMPLETED_NO);
+		return(NULL);
+	}
+
+	tc->kind=CORBA_tk_objref;
+	tc->name=g_strdup(name);
+	tc->repo_id=g_strdup(id);
+
+	return(tc);
+}
+
+CORBA_TypeCode CORBA_ORB_create_string_tc(CORBA_ORB obj, CORBA_unsigned_long bound, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		return(NULL);
+	}
+
+	tc->kind=CORBA_tk_string;
+	tc->length=bound;
+
+	return(tc);
+}
+
+CORBA_TypeCode CORBA_ORB_create_wstring_tc(CORBA_ORB obj, CORBA_unsigned_long bound, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		return(NULL);
+	}
+
+	tc->kind=CORBA_tk_wstring;
+	tc->length=bound;
+
+	return(tc);
+}
+
+CORBA_TypeCode CORBA_ORB_create_fixed_tc(CORBA_ORB obj, CORBA_unsigned_short digits, CORBA_short scale, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		return(NULL);
+	}
+
+	tc->kind=CORBA_tk_fixed;
+	tc->digits=digits;
+	tc->scale=scale;
+
+	return(tc);
+}
+
+CORBA_TypeCode CORBA_ORB_create_sequence_tc(CORBA_ORB obj, CORBA_unsigned_long bound, CORBA_TypeCode element_type, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL)
+	  goto tc_alloc_failed;
+
+	/* Can't use chunks here because we can only be sure of getting
+	   one consecutive chunk from glib */
+	tc->subtypes=g_new0(CORBA_TypeCode, 1);
+	if(tc->subtypes==NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->kind=CORBA_tk_sequence;
+	tc->sub_parts=1;
+	tc->length=bound;
+
+	tc->subtypes[0] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	memcpy(tc->subtypes[0], element_type,
+	       (size_t)sizeof(struct CORBA_TypeCode_struct));
+
+	return(tc);
+
+ subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return(NULL);
+}
+
+CORBA_TypeCode CORBA_ORB_create_recursive_sequence_tc(CORBA_ORB obj, CORBA_unsigned_long bound, CORBA_unsigned_long offset, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL)
+	  goto tc_alloc_failed;
+
+	tc->subtypes=g_new0(CORBA_TypeCode, 1);
+	if(tc->subtypes==NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->kind=CORBA_tk_sequence;
+	tc->sub_parts=1;
+	tc->length=bound;
+
+	tc->subtypes[0] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	tc->subtypes[0]->kind=CORBA_tk_recursive;
+	tc->subtypes[0]->recurse_depth=offset;
+
+	return(tc);
+
+ subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return(NULL);
+}
+
+CORBA_TypeCode CORBA_ORB_create_array_tc(CORBA_ORB obj, CORBA_unsigned_long length, CORBA_TypeCode element_type, CORBA_Environment *ev)
+{
+	CORBA_TypeCode tc;
+
+	tc=ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	if(tc==NULL)
+	  goto tc_alloc_failed;
+
+	tc->subtypes=g_new0(CORBA_TypeCode, 1);
+	if(tc->subtypes==NULL)
+	  goto subtypes_alloc_failed;
+
+	tc->kind=CORBA_tk_array;
+	tc->sub_parts=1;
+	tc->length=length;
+
+	tc->subtypes[0] = ORBIT_CHUNK_ALLOC(CORBA_TypeCode);
+	memcpy(tc->subtypes[0], element_type, (size_t)sizeof(CORBA_TypeCode));
+
+	return(tc);
+
+ subtypes_alloc_failed:
+	ORBIT_CHUNK_FREE(CORBA_TypeCode, tc);
+ tc_alloc_failed:
+	CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+	return(NULL);
+}
+#endif /* !__KORBIT__ */
diff -urN linux-2.4.1/net/korbit/orb/orb.h linux-2.4.1-korbit/net/korbit/orb/orb.h
--- linux-2.4.1/net/korbit/orb/orb.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orb.h	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,231 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_ORB_H_
+#define _ORBIT_ORB_H_
+
+#include "orb/orbit_types.h"
+#ifndef __KORBIT__
+#include "orb/interface_repository.h"
+#endif /* !__KORBIT__ */
+
+extern CORBA_ORB CORBA_ORB_init(
+	int *argc,
+	char **argv,
+	CORBA_ORBid orb_identifier,
+	CORBA_Environment *ev);
+
+extern CORBA_char *CORBA_ORB_object_to_string(
+	CORBA_ORB orb,
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern CORBA_Object CORBA_ORB_string_to_object(
+	CORBA_ORB orb,
+	CORBA_char *str,
+	CORBA_Environment *ev);
+
+extern CORBA_Status CORBA_ORB_get_default_context(
+	CORBA_ORB orb,
+	CORBA_Context *ctx,
+	CORBA_Environment *ev);
+
+extern CORBA_boolean CORBA_ORB_get_service_information(
+	CORBA_ORB orb,
+	CORBA_ServiceType service_type,
+	CORBA_ServiceInformation *service_information,
+	CORBA_Environment *ev);
+
+extern CORBA_Current *CORBA_ORB_get_current(
+	CORBA_ORB orb,
+	CORBA_Environment *ev);
+
+extern CORBA_ORB_ObjectIdList* CORBA_ORB_list_initial_services(
+	CORBA_ORB orb,
+	CORBA_Environment *ev);
+
+extern CORBA_Object CORBA_ORB_resolve_initial_references(
+	CORBA_ORB orb,
+	CORBA_ORB_ObjectId identifier,
+	CORBA_Environment *ev);
+
+extern void CORBA_ORB_set_initial_reference(
+	CORBA_ORB orb,
+	CORBA_ORB_ObjectId identifier,
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern CORBA_boolean CORBA_ORB_work_pending(
+	CORBA_ORB orb,
+	CORBA_Environment *ev);
+
+extern void CORBA_ORB_perform_work(
+	CORBA_ORB orb,
+	CORBA_Environment *ev);
+
+extern void CORBA_ORB_shutdown(
+	CORBA_ORB orb,
+	CORBA_boolean wait_for_completion,
+	CORBA_Environment *ev);
+
+extern void CORBA_ORB_run(
+	CORBA_ORB orb,
+	CORBA_Environment *ev);
+
+extern CORBA_PolicyType CORBA_Policy__get_policy_type(
+	CORBA_Policy obj,
+	CORBA_Environment *ev);
+
+extern CORBA_Policy CORBA_Policy_copy(
+	CORBA_Policy obj,
+	CORBA_Environment *ev);
+
+extern void CORBA_Policy_destroy(
+	CORBA_Policy obj,
+	CORBA_Environment *ev);
+
+#ifndef __KORBIT__
+extern CORBA_InterfaceDef CORBA_Object_get_interface(
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+#endif /* !__KORBIT__ */
+
+extern CORBA_boolean CORBA_Object_is_nil(
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern CORBA_Object CORBA_Object_duplicate(
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern void CORBA_Object_release(
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern CORBA_boolean CORBA_Object_non_existent(
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern CORBA_boolean CORBA_Object_is_equivalent(
+	CORBA_Object obj,
+	CORBA_Object other_object,
+	CORBA_Environment *ev);
+
+extern CORBA_unsigned_long CORBA_Object_hash(
+	CORBA_Object obj,
+	CORBA_unsigned_long maximum,
+	CORBA_Environment *ev);
+
+extern CORBA_Policy CORBA_Object_get_policy(
+	CORBA_Object obj,
+	CORBA_PolicyType policy_type,
+	CORBA_Environment *ev);
+
+#ifndef __KORBIT__
+extern CORBA_DomainManagerList *CORBA_Object_get_domain_managers(
+	CORBA_Object obj,
+	CORBA_Environment *ev);
+
+extern CORBA_Policy CORBA_DomainManager_get_domain_policy(
+	CORBA_DomainManager obj,
+	CORBA_PolicyType policy_type,
+	CORBA_Environment *ev);
+
+extern void CORBA_ConstructionPolicy_make_domain_manager(
+	CORBA_ConstructionPolicy obj,
+	CORBA_Object /*CORBA_InterfaceDef*/ object_type,
+	CORBA_boolean constr_policy,
+	CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_struct_tc(CORBA_ORB obj,
+					  CORBA_RepositoryId id,
+					  CORBA_Identifier name,
+					  CORBA_StructMemberSeq members,
+					  CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_union_tc(CORBA_ORB obj,
+					 CORBA_RepositoryId id,
+					 CORBA_Identifier name,
+					 CORBA_TypeCode discriminator_type,
+					 CORBA_UnionMemberSeq members,
+					 CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_enum_tc(CORBA_ORB obj,
+					CORBA_RepositoryId id,
+					CORBA_Identifier name,
+					CORBA_EnumMemberSeq members,
+					CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_alias_tc(CORBA_ORB obj,
+					 CORBA_RepositoryId id,
+					 CORBA_Identifier name,
+					 CORBA_TypeCode original_type,
+					 CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_exception_tc(CORBA_ORB obj,
+					     CORBA_RepositoryId id,
+					     CORBA_Identifier name,
+					     CORBA_StructMemberSeq members,
+					     CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_interface_tc(CORBA_ORB obj,
+					     CORBA_RepositoryId id,
+					     CORBA_Identifier name,
+					     CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_string_tc(CORBA_ORB obj,
+					  CORBA_unsigned_long bound,
+					  CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_wstring_tc(CORBA_ORB obj,
+					   CORBA_unsigned_long bound,
+					   CORBA_Environment *ev);
+
+CORBA_TypeCode CORBA_ORB_create_fixed_tc(CORBA_ORB obj,
+					 CORBA_unsigned_short digits,
+					 CORBA_short scale,
+					 CORBA_Environment *ev);
+
+extern CORBA_TypeCode CORBA_ORB_create_sequence_tc(
+	CORBA_ORB obj,
+	CORBA_unsigned_long bound,
+	CORBA_TypeCode element_type,
+	CORBA_Environment *ev);
+
+extern CORBA_TypeCode CORBA_ORB_create_recursive_sequence_tc(
+	CORBA_ORB obj,
+	CORBA_unsigned_long bound,
+	CORBA_unsigned_long offset,
+	CORBA_Environment *ev);
+
+extern CORBA_TypeCode CORBA_ORB_create_array_tc(
+	CORBA_ORB obj,
+	CORBA_unsigned_long length,
+	CORBA_TypeCode element_type,
+	CORBA_Environment *ev);
+
+#endif /* !__KORBIT__ */
+
+#endif /* !_ORBIT_ORB_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit.c linux-2.4.1-korbit/net/korbit/orb/orbit.c
--- linux-2.4.1/net/korbit/orb/orbit.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit.c	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,387 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+/*
+ * This file is a repository for random functions that don't fit anywhere
+ * else, and for ORBit-specific stuff.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <math.h>
+
+#include "orbit.h"
+
+const guint orbit_major_version = ORBIT_MAJOR_VERSION,
+	orbit_minor_version = ORBIT_MINOR_VERSION,
+	orbit_micro_version = ORBIT_MICRO_VERSION;
+const char orbit_version[] = ORBIT_VERSION;
+
+typedef struct ORBitClassInfo ORBitClassInfo;
+
+typedef void (*ORBitObjectInitFunc)(CORBA_Object _handle_to_be, gpointer class_data);
+
+struct ORBitClassInfo {
+  char *name;
+  gulong id;
+  gpointer method_stubs, method_skels;
+  ORBitObjectInitFunc class_vtable_init_func;
+  ORBitClassInfo **parent_classes;
+};
+
+GHashTable *orbit_class_list = NULL, *orbit_class_byid;
+glong class_id_counter = -1;
+
+void CORBA_any_set_release(CORBA_any *any, CORBA_boolean flag)
+{
+	g_assert(any!=NULL);
+
+	if(flag==CORBA_TRUE) {
+		any->_release |= CORBA_ANYFLAGS_RELEASE;
+	} else {
+		any->_release &= ~CORBA_ANYFLAGS_RELEASE;
+	}
+
+}
+
+CORBA_boolean CORBA_any_get_release(CORBA_any *any)
+{
+	g_assert(any!=NULL);
+
+	if(any->_release & CORBA_ANYFLAGS_RELEASE)
+		return(CORBA_TRUE);
+	else
+		return(CORBA_FALSE);
+}
+
+void CORBA_sequence_set_release(void *seq, CORBA_boolean flag)
+{
+	struct CORBA_Sequence_type *sequence;
+
+	g_assert(seq!=NULL);
+
+	sequence=(struct CORBA_Sequence_type *)seq;
+
+	if(flag==CORBA_TRUE) {
+		sequence->_release |= CORBA_ANYFLAGS_RELEASE;
+	} else {
+		sequence->_release &= ~CORBA_ANYFLAGS_RELEASE;
+	}
+}
+
+CORBA_boolean CORBA_sequence_get_release(void *seq)
+{
+	struct CORBA_Sequence_type *sequence;
+
+	g_assert(seq!=NULL);
+
+	sequence=(struct CORBA_Sequence_type *)seq;
+
+	if(sequence->_release & CORBA_ANYFLAGS_RELEASE)
+		return(CORBA_TRUE);
+	else
+		return(CORBA_FALSE);
+}
+
+/*
+ * As far as I understand, values returned by CORBA_*_alloc() are supposed to be
+ * freeable by CORBA_free(), so we can't use memory chunks here in any reasonable
+ * fashion.
+ */
+gpointer
+CORBA_any__free(gpointer mem, gpointer func_data, CORBA_boolean free_strings)
+{
+	CORBA_any *aval = mem;
+
+	if(aval->_release)
+		ORBit_free(aval->_value, free_strings);
+	CORBA_Object_release((CORBA_Object)aval->_type, NULL);
+
+	return aval + 1;
+}
+
+CORBA_any *CORBA_any_alloc(void)
+{
+	CORBA_any *retval = ORBit_alloc(sizeof(CORBA_any), &CORBA_any__free,
+					GINT_TO_POINTER(1));
+
+	memset(retval, 0, sizeof(CORBA_any)); /* Make things easier on stubs */
+
+	return retval;
+}
+
+/*
+ * Compares the typecodes of each any
+ */
+CORBA_boolean ORBit_any_equivalent(CORBA_any obj, CORBA_any any, CORBA_Environment *ev)
+{
+	return(CORBA_FALSE);
+}
+
+/* This is needed by skels, that generate a __free function when they see
+   the TypeCode interface */
+gpointer
+CORBA_TypeCode__free(gpointer mem, gpointer func_data, CORBA_boolean free_strings)
+{
+	CORBA_Object_release(*(CORBA_Object *)mem, NULL);
+	return ((guchar *)mem) + sizeof(CORBA_TypeCode);
+}
+
+CORBA_char *CORBA_string_dup(const CORBA_char *string)
+{
+	if(!string)
+		return NULL;
+
+	return strcpy(ORBit_alloc(strlen(string)+1, NULL, NULL), string);
+}
+
+CORBA_char *CORBA_string_alloc(CORBA_unsigned_long len)
+{
+	return ORBit_alloc(len + 1, NULL, NULL);
+}
+
+CORBA_wchar *CORBA_wstring_alloc(CORBA_unsigned_long len)
+{
+	return ORBit_alloc(len + 1, NULL, NULL);
+}
+
+gpointer
+CORBA_string__free(gpointer str, gpointer dat, CORBA_boolean free_strings)
+{
+	if(free_strings)
+		CORBA_free(*((gpointer *)str));
+	return (gpointer)((guchar *)str + sizeof(CORBA_char *));
+}
+
+gpointer CORBA_Object__free(gpointer str, gpointer dat, CORBA_boolean free_strings)
+{
+	CORBA_Environment ev;
+	CORBA_exception_init(&ev);
+	CORBA_Object_release(*((gpointer *)str), &ev);
+	CORBA_exception_free(&ev);
+	return (gpointer)((guchar *)str + sizeof(CORBA_Object));
+}
+
+/* 19.14 */
+
+/* The big picture for fixeds.
+   We have to represent a number in memory.
+
+   1 2 3 . 4 5 6 7
+
+   There are three pieces of information in a fixed:
+
+   - Number of significant digits. (_digits)
+
+   - The scale. The number of places the decimal point is to the right
+   of the first significant digit. (_scale)
+
+   - The digits themselves (_value)
+
+ */
+CORBA_long CORBA_fixed_integer_part(const void *fp)
+{
+	CORBA_long retval = 0;
+	int i, power_of_ten, digit;
+	const CORBA_fixed_d_s *val = fp;
+
+	g_return_val_if_fail(fp != NULL, INT_MIN);
+
+	for(i = 0; i < (val->_digits - val->_scale); i++) {
+		power_of_ten = val->_digits - i - val->_scale - 1;
+		digit = val->_value[i];
+		retval += digit * ((int)pow(10, power_of_ten));
+	}
+
+	return retval;
+}
+
+CORBA_long CORBA_fixed_fraction_part(const void *fp)
+{
+	CORBA_long retval = 0;
+	int i, power_of_ten, digit;
+	const CORBA_fixed_d_s *val = fp;
+
+	g_return_val_if_fail(fp != NULL, INT_MIN);
+
+	for(i = val->_digits - val->_scale; i < val->_digits; i++){
+		power_of_ten = val->_digits - i - 1;
+		digit = val->_value[i];
+		retval += digit * ((int)pow(10, power_of_ten));
+	}
+
+	return retval;
+}
+
+static inline
+CORBA_long do_div (CORBA_long *n)
+{
+  int __res;
+
+  __res = (*n) % (unsigned) 10;
+  *n = (*n) / (unsigned) 10;
+
+  return __res;
+}
+
+void CORBA_fixed_set(void *rp, CORBA_long i, CORBA_long f)
+{
+	CORBA_fixed_d_s *val = rp;
+	CORBA_long left_to_eat, cur;
+	signed char sign = 1;
+
+	g_return_if_fail(rp != NULL);
+
+	memset(val->_value, 0, val->_digits);
+
+	if(i) sign = i/abs(i);
+	val->_sign = sign;
+	i = abs(i);
+	f = abs(f);
+
+	for(cur = 0, left_to_eat = i;
+	    left_to_eat != 0 && cur < val->_digits; cur++) {
+		val->_value[cur] = do_div(&left_to_eat) * sign;
+		sign = 1;
+	}
+
+	val->_scale = cur - 1;
+
+	for(left_to_eat = f;
+	    left_to_eat != 0 && cur < val->_digits; cur++) {
+		val->_value[cur] = do_div(&left_to_eat);
+	}
+}
+
+void CORBA_fixed_add(void *rp, const void *f1p, const void *f2p)
+{
+	g_assert(!"Not yet implemented");
+}
+
+void CORBA_fixed_sub(void *rp, const void *f1p, const void *f2p)
+{
+	g_assert(!"Not yet implemented");
+}
+
+void CORBA_fixed_mul(void *rp, const void *f1p, const void *f2p)
+{
+	g_assert(!"Not yet implemented");
+}
+
+void CORBA_fixed_div(void *rp, const void *f1p, const void *f2p)
+{
+	g_assert(!"Not yet implemented");
+}
+
+CORBA_fixed_d_s *CORBA_fixed_alloc(CORBA_unsigned_short d)
+{
+	return (CORBA_fixed_d_s *)
+		g_malloc(sizeof(CORBA_fixed_d_s) + d + 1);
+}
+
+void CORBA_free(void *storage)
+{
+	ORBit_free(storage, CORBA_TRUE);
+}
+
+int ORBit_parse_unixsock(CORBA_Object obj,
+			 char *sockpath,
+			 gboolean existing_only)
+{
+	if(!sockpath || !*sockpath)
+		return -1;
+	
+	obj->connection =
+		GIOP_CONNECTION(iiop_connection_unix_get(sockpath,
+							 existing_only));
+
+	if(!obj->connection)
+		return -1;
+
+	giop_connection_ref(obj->connection);
+	return 0;
+}
+
+int ORBit_parse_inet(CORBA_Object obj, char *hostname, unsigned short port,
+			 gboolean existing_only)
+{
+	obj->connection = GIOP_CONNECTION(iiop_connection_get(hostname, port, existing_only));
+
+	if(!obj->connection)
+		return -1;
+	giop_connection_ref(obj->connection);
+	return 0;
+}
+
+static const CORBA_unsigned_long zero_int = 0;
+struct iovec ORBit_default_principal_iovec = {(gpointer)&zero_int, sizeof(zero_int)};
+
+void ORBit_set_default_principal(CORBA_Principal *principal)
+{
+	gpointer t;
+
+	if((gpointer)ORBit_default_principal_iovec.iov_base != (gpointer)&zero_int)
+		g_free(ORBit_default_principal_iovec.iov_base);
+
+	ORBit_default_principal_iovec.iov_len = principal->_length
+		+ sizeof(CORBA_unsigned_long);
+
+	t = ORBit_default_principal_iovec.iov_base =
+		g_malloc(ORBit_default_principal_iovec.iov_len);
+
+	memcpy(t, &principal->_length, sizeof(principal->_length));
+
+	t = ((guchar *)t) + sizeof(principal->_length);
+	memcpy(t, principal->_buffer, principal->_length);
+}
+
+CORBA_unsigned_long ORBit_class_assignment_counter = 0;
+GHashTable *ORBit_class_assignments = NULL;
+
+/* XXX not thread-safe */
+CORBA_unsigned_long
+ORBit_register_class(const PortableServer_ClassInfo *class_info)
+{
+	CORBA_unsigned_long retval;
+
+	if(!ORBit_class_assignments)
+		ORBit_class_assignments = g_hash_table_new(g_str_hash, g_str_equal);
+
+	/* This needs to be pre-increment - we don't want to give out
+	   classid 0, because (a) that is reserved for the base Object class
+	   (b) all the routines allocate a new id if the variable
+	   storing their ID == 0 */
+	retval = ++ORBit_class_assignment_counter;
+
+	g_hash_table_insert(ORBit_class_assignments, (gpointer)class_info->class_name,
+			    GINT_TO_POINTER(retval));
+
+	return retval;
+}
diff -urN linux-2.4.1/net/korbit/orb/orbit.h linux-2.4.1-korbit/net/korbit/orb/orbit.h
--- linux-2.4.1/net/korbit/orb/orbit.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit.h	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,207 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@acm.org>
+ *	    Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+/* these two blocks are outside of the main header for good reason...
+   People may include headers from many different stubs, and we want to
+   have the version checked on all of them.
+ */
+#ifndef ORBIT_SERIAL
+#define ORBIT_SERIAL 9
+#endif
+
+#ifdef ORBIT_IDL_SERIAL
+#if ORBIT_IDL_SERIAL < 9
+#error "You need to rerun 'orbit-idl' on the .idl file whose stubs you are using. These stubs were generated with an older version of ORBit, and need to be regenerated."
+#endif
+#endif
+
+#ifndef _ORBIT_H_
+#define _ORBIT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <glib.h>
+
+#define BACKWARDS_COMPAT_0_4
+#undef NOT_BACKWARDS_COMPAT_0_4
+
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <IIOP/IIOP.h>
+#include <ORBitutil/util.h>
+#include <orb/orbit_config.h>
+#include <orb/orbit_types.h>
+#include <orb/allocators.h>
+#include <orb/cdr.h>
+#include <orb/dii.h>
+#ifndef __KORBIT__
+#include <orb/dynany.h>
+#endif
+#include <orb/env.h>
+#include <orb/iop.h>
+#include <orb/ir.h>
+#include <orb/options.h>
+#include <orb/orb.h>
+#include <orb/poa.h>
+#include <orb/sequences.h>
+#include <orb/orbit_typecode.h>
+#include <orb/typecode.h>
+
+#ifndef ORBIT_MAJOR_VERSION
+#define ORBIT_MAJOR_VERSION (0)
+#define ORBIT_MINOR_VERSION (5)
+#define ORBIT_MICRO_VERSION (3)
+#endif
+
+extern const guint orbit_major_version,
+	orbit_minor_version,
+	orbit_micro_version;
+extern const char orbit_version[];
+
+extern void CORBA_any_set_release(
+	CORBA_any *,
+	CORBA_boolean);
+
+extern CORBA_boolean CORBA_any_get_release(
+	CORBA_any *);
+
+extern void CORBA_sequence_set_release(
+	void *,
+	CORBA_boolean);
+
+extern CORBA_boolean CORBA_sequence_get_release(
+	void *);
+
+#define CORBA_any__alloc CORBA_any_alloc
+extern CORBA_any *CORBA_any_alloc(
+	void);
+
+extern gpointer CORBA_any__free(gpointer mem, gpointer func_data,
+				CORBA_boolean free_strings);
+extern gpointer CORBA_TypeCode__free(gpointer mem, gpointer func_data,
+				     CORBA_boolean free_strings);
+
+extern CORBA_boolean ORBit_any_equivalent(
+	CORBA_any obj,
+	CORBA_any any,
+	CORBA_Environment *ev);
+
+extern CORBA_char *CORBA_string_dup(const CORBA_char *string);
+extern CORBA_char *CORBA_string_alloc(CORBA_unsigned_long len);
+extern gpointer CORBA_string__free(gpointer str, gpointer dat, CORBA_boolean free_strings);
+
+gpointer CORBA_Object__free(gpointer str, gpointer dat, CORBA_boolean free_strings);
+
+extern CORBA_wchar *CORBA_wstring_alloc(CORBA_unsigned_long len);
+#define CORBA_wstring_free CORBA_string_free
+
+/* 19.14 */
+extern CORBA_long CORBA_fixed_integer_part(
+	const void *fp);
+
+extern CORBA_long CORBA_fixed_fraction_part(
+	const void *fp);
+
+extern void CORBA_fixed_set(
+	void *rp,
+	CORBA_long i,
+	CORBA_long f);
+
+extern void CORBA_fixed_add(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern void CORBA_fixed_sub(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern void CORBA_fixed_mul(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern void CORBA_fixed_div(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern CORBA_fixed_d_s *CORBA_fixed_alloc(
+	CORBA_unsigned_short d);
+
+extern void CORBA_free(
+	void *storage);
+
+extern int ORBit_parse_inet(
+	CORBA_Object obj,
+	char *hostname,
+	unsigned short port,
+	gboolean existing_only);
+
+extern int ORBit_parse_unixsock(CORBA_Object obj,
+				char *sockpath,
+				gboolean existing_only);
+
+/****
+     This function lets you use your own event loop, if you so wish.
+     Also see IIOP.h's IIOP{Add,Remove}ConnectionHandler function pointers,
+     which are app-settable (you should set them before CORBA_ORB_init,
+     if you want them to be useful)
+ ****/
+
+    /* needs to be called by your event loop when data comes in on one of the
+       GIOPConnection fd's */
+void ORBit_custom_run_setup(CORBA_ORB orb, CORBA_Environment *ev);
+	void ORBit_handle_incoming(GIOPConnection *connection);
+
+/* Returns CORBA_TRUE if the request is OK to proceed. */
+typedef enum {
+	ORBIT_MESSAGE_BAD,
+	ORBIT_MESSAGE_ALLOW,
+	ORBIT_MESSAGE_ALLOW_ALL /* Allow all subsequent messages on
+				   this connection with no checking */
+} ORBit_MessageValidationResult;
+typedef ORBit_MessageValidationResult (*ORBit_request_validate)
+	     (CORBA_unsigned_long request_id,
+	      CORBA_Principal *principal,
+	      CORBA_char *operation);
+void ORBit_set_request_validation_handler(ORBit_request_validate validator);
+
+extern struct iovec ORBit_default_principal_iovec;
+void ORBit_set_default_principal(CORBA_Principal *principal);
+
+extern CORBA_unsigned_long ORBit_class_assignment_counter;
+
+CORBA_unsigned_long ORBit_register_class(const PortableServer_ClassInfo *class_info);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif	/* !_ORBIT_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit.h.in linux-2.4.1-korbit/net/korbit/orb/orbit.h.in
--- linux-2.4.1/net/korbit/orb/orbit.h.in	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit.h.in	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,205 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@acm.org>
+ *	    Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+/* these two blocks are outside of the main header for good reason...
+   People may include headers from many different stubs, and we want to
+   have the version checked on all of them.
+ */
+#ifndef ORBIT_SERIAL
+#define ORBIT_SERIAL @ORBIT_SERIAL@
+#endif
+
+#ifdef ORBIT_IDL_SERIAL
+#if ORBIT_IDL_SERIAL < @ORBIT_SERIAL@
+#error "You need to rerun 'orbit-idl' on the .idl file whose stubs you are using. These stubs were generated with an older version of ORBit, and need to be regenerated."
+#endif
+#endif
+
+#ifndef _ORBIT_H_
+#define _ORBIT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <glib.h>
+
+#define BACKWARDS_COMPAT_0_4
+#undef NOT_BACKWARDS_COMPAT_0_4
+
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <IIOP/IIOP.h>
+#include <ORBitutil/util.h>
+#include <orb/orbit_config.h>
+#include <orb/orbit_types.h>
+#include <orb/allocators.h>
+#include <orb/cdr.h>
+#include <orb/dii.h>
+#include <orb/dynany.h>
+#include <orb/env.h>
+#include <orb/iop.h>
+#include <orb/ir.h>
+#include <orb/options.h>
+#include <orb/orb.h>
+#include <orb/poa.h>
+#include <orb/sequences.h>
+#include <orb/orbit_typecode.h>
+#include <orb/typecode.h>
+
+#ifndef ORBIT_MAJOR_VERSION
+#define ORBIT_MAJOR_VERSION (@ORBIT_MAJOR_VERSION@)
+#define ORBIT_MINOR_VERSION (@ORBIT_MINOR_VERSION@)
+#define ORBIT_MICRO_VERSION (@ORBIT_MICRO_VERSION@)
+#endif
+
+extern const guint orbit_major_version,
+	orbit_minor_version,
+	orbit_micro_version;
+extern const char orbit_version[];
+
+extern void CORBA_any_set_release(
+	CORBA_any *,
+	CORBA_boolean);
+
+extern CORBA_boolean CORBA_any_get_release(
+	CORBA_any *);
+
+extern void CORBA_sequence_set_release(
+	void *,
+	CORBA_boolean);
+
+extern CORBA_boolean CORBA_sequence_get_release(
+	void *);
+
+#define CORBA_any__alloc CORBA_any_alloc
+extern CORBA_any *CORBA_any_alloc(
+	void);
+
+extern gpointer CORBA_any__free(gpointer mem, gpointer func_data,
+				CORBA_boolean free_strings);
+extern gpointer CORBA_TypeCode__free(gpointer mem, gpointer func_data,
+				     CORBA_boolean free_strings);
+
+extern CORBA_boolean ORBit_any_equivalent(
+	CORBA_any obj,
+	CORBA_any any,
+	CORBA_Environment *ev);
+
+extern CORBA_char *CORBA_string_dup(const CORBA_char *string);
+extern CORBA_char *CORBA_string_alloc(CORBA_unsigned_long len);
+extern gpointer CORBA_string__free(gpointer str, gpointer dat, CORBA_boolean free_strings);
+
+gpointer CORBA_Object__free(gpointer str, gpointer dat, CORBA_boolean free_strings);
+
+extern CORBA_wchar *CORBA_wstring_alloc(CORBA_unsigned_long len);
+#define CORBA_wstring_free CORBA_string_free
+
+/* 19.14 */
+extern CORBA_long CORBA_fixed_integer_part(
+	const void *fp);
+
+extern CORBA_long CORBA_fixed_fraction_part(
+	const void *fp);
+
+extern void CORBA_fixed_set(
+	void *rp,
+	CORBA_long i,
+	CORBA_long f);
+
+extern void CORBA_fixed_add(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern void CORBA_fixed_sub(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern void CORBA_fixed_mul(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern void CORBA_fixed_div(
+	void *rp,
+	const void *f1p,
+	const void *f2p);
+
+extern CORBA_fixed_d_s *CORBA_fixed_alloc(
+	CORBA_unsigned_short d);
+
+extern void CORBA_free(
+	void *storage);
+
+extern int ORBit_parse_inet(
+	CORBA_Object obj,
+	char *hostname,
+	unsigned short port,
+	gboolean existing_only);
+
+extern int ORBit_parse_unixsock(CORBA_Object obj,
+				char *sockpath,
+				gboolean existing_only);
+
+/****
+     This function lets you use your own event loop, if you so wish.
+     Also see IIOP.h's IIOP{Add,Remove}ConnectionHandler function pointers,
+     which are app-settable (you should set them before CORBA_ORB_init,
+     if you want them to be useful)
+ ****/
+
+    /* needs to be called by your event loop when data comes in on one of the
+       GIOPConnection fd's */
+void ORBit_custom_run_setup(CORBA_ORB orb, CORBA_Environment *ev);
+	void ORBit_handle_incoming(GIOPConnection *connection);
+
+/* Returns CORBA_TRUE if the request is OK to proceed. */
+typedef enum {
+	ORBIT_MESSAGE_BAD,
+	ORBIT_MESSAGE_ALLOW,
+	ORBIT_MESSAGE_ALLOW_ALL /* Allow all subsequent messages on
+				   this connection with no checking */
+} ORBit_MessageValidationResult;
+typedef ORBit_MessageValidationResult (*ORBit_request_validate)
+	     (CORBA_unsigned_long request_id,
+	      CORBA_Principal *principal,
+	      CORBA_char *operation);
+void ORBit_set_request_validation_handler(ORBit_request_validate validator);
+
+extern struct iovec ORBit_default_principal_iovec;
+void ORBit_set_default_principal(CORBA_Principal *principal);
+
+extern CORBA_unsigned_long ORBit_class_assignment_counter;
+
+CORBA_unsigned_long ORBit_register_class(const PortableServer_ClassInfo *class_info);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif	/* !_ORBIT_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit_config.h linux-2.4.1-korbit/net/korbit/orb/orbit_config.h
--- linux-2.4.1/net/korbit/orb/orbit_config.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_config.h	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,9 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+#ifndef ORB_CONFIG_H
+#define ORB_CONFIG_H 1
+
+/* When creating a memory pool for a particular type, how many chunks
+   do we want to pre-allocated? */
+#define ORBIT_CHUNKS_PREALLOC 2
+
+#endif /* ORB_CONFIG_H */
diff -urN linux-2.4.1/net/korbit/orb/orbit_object.c linux-2.4.1-korbit/net/korbit/orb/orbit_object.c
--- linux-2.4.1/net/korbit/orb/orbit_object.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_object.c	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,699 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Phil Dawes <philipd@parallax.co.uk>
+ *          Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+/*
+ *   ORBit specific CORBA_Object functions.
+ *
+ */
+
+#include <string.h>
+#include "config.h"
+#include "../IIOP/iiop-endianP.h"
+#include "orbit_object_type.h"
+#include "corba_object_type.h"
+#include "allocators.h"
+#include "iop.h"
+#include <IIOP/IIOP.h>
+
+static void ORBit_object_try_existing_connections(CORBA_Object obj);
+static void CORBA_Object_release_fn(CORBA_Object obj, CORBA_Environment *ev);
+
+static ORBit_RootObject_Interface CORBA_Object_epv =
+{
+	(void (*)(gpointer, CORBA_Environment *))CORBA_Object_release_fn,
+};
+
+void ORBit_pseudo_object_init(ORBit_PseudoObject obj,
+			      ORBit_PseudoObject_type obj_type,
+			      CORBA_Environment *ev)
+{
+	ORBIT_ROOT_OBJECT(obj)->is_pseudo_object = TRUE;
+	ORBIT_ROOT_OBJECT(obj)->refs = 0;
+	ORBIT_PSEUDO_OBJECT(obj)->pseudo_object_type = obj_type;
+}
+
+static const ORBit_RootObject_Interface CORBA_Policy__epv =
+{
+	(void (*)(gpointer, CORBA_Environment *))CORBA_Policy_destroy
+};
+
+void ORBit_policy_object_init(CORBA_Policy obj,
+			      CORBA_PolicyType obj_type,
+			      CORBA_Environment *ev)
+{
+	ORBit_pseudo_object_init(ORBIT_PSEUDO_OBJECT(obj),
+				 ORBIT_PSEUDO_POLICY, ev);
+
+	obj->policy_type = obj_type;
+
+	ORBit_RootObject_set_interface(ORBIT_ROOT_OBJECT(obj),
+				       (gpointer)&CORBA_Policy__epv,
+				       ev);
+}
+
+void ORBit_object_reference_init(CORBA_Object obj, CORBA_Environment *ev)
+{
+	/* set the interface up */
+	ORBit_RootObject_set_interface(ORBIT_ROOT_OBJECT(obj),&CORBA_Object_epv,ev);
+	/* initialise the reference count */
+	ORBIT_ROOT_OBJECT(obj)->refs = 0; 
+	ORBIT_ROOT_OBJECT(obj)->is_pseudo_object = FALSE;
+}
+
+CORBA_Object 
+ORBit_CORBA_Object_new(CORBA_Environment *ev)
+{
+	CORBA_Object obj;
+	/* Create the object */
+	obj = ORBIT_CHUNK_ALLOC(CORBA_Object);
+	memset(obj, '\0', sizeof(struct CORBA_Object_struct));
+
+	ORBit_object_reference_init(obj, ev);
+
+	return obj;
+
+}
+
+void
+ORBit_set_object_key(ORBit_Object_info *info)
+{
+	g_assert(info);
+
+	g_assert(info->object_key._length);
+
+	info->object_key_data = g_malloc(sizeof(CORBA_unsigned_long) + info->object_key._length);
+	info->object_key_data->_length = info->object_key._length;
+	memcpy(info->object_key_data->_buffer, info->object_key._buffer, info->object_key._length);
+
+	info->object_key_vec.iov_base =
+		(gpointer)info->object_key_data;
+	info->object_key_vec.iov_len = sizeof(CORBA_unsigned_long) + info->object_key._length;
+}
+
+static void ORBit_free_profile(gpointer item, gpointer data)
+{
+	ORBit_Object_info *info=(ORBit_Object_info *)item;
+
+	g_assert(info);
+
+	g_free(info->object_key_data);
+	CORBA_free(info->object_key._buffer);
+
+	if(info->profile_type == IOP_TAG_INTERNET_IOP) {
+		g_free(info->tag.iopinfo.host);
+	} else if(info->profile_type == IOP_TAG_ORBIT_SPECIFIC) {
+		g_free(info->tag.orbitinfo.unix_sock_path);
+	} else {
+		g_warning("ORBit_free_profile asked to free type %d", info->profile_type);
+	}
+
+	g_free(info);	/* Check its safe to free the item within a foreach func */
+}
+
+void ORBit_delete_profiles(GSList *profile_list)
+{
+	g_slist_foreach(profile_list, ORBit_free_profile, NULL);
+	g_slist_free(profile_list);
+}
+
+/* this function is wired up to the RootObject interface */
+void 
+CORBA_Object_release_fn(CORBA_Object obj, CORBA_Environment *ev)
+{
+
+	g_assert(obj!=NULL);
+
+	ORBIT_ROOT_OBJECT_UNREF(obj);
+
+	if(ORBIT_ROOT_OBJECT(obj)->refs <= 0) {
+		g_hash_table_remove(obj->orb->objrefs, obj);
+		
+		if(obj->connection)
+			giop_connection_unref(obj->connection);
+
+		g_free(obj->object_id);
+		ORBit_delete_profiles(obj->profile_list);
+		ORBit_delete_profiles(obj->forward_locations);
+
+		ORBIT_CHUNK_FREE(CORBA_Object, obj);
+	}
+}
+
+
+/* Sets the interface member in the RootObject to the epv specified*/
+void
+ORBit_RootObject_set_interface(ORBit_RootObject obj,
+			       ORBit_RootObject_Interface* epv,
+			       CORBA_Environment *ev)
+{
+	g_assert(obj!=NULL);
+	g_assert(epv!=NULL);
+
+	obj->interface = epv;
+}
+
+#define GET_ATOM(x) G_STMT_START{ GIOP_RECV_BUFFER(recv_buffer)->decoder(&x, (GIOP_RECV_BUFFER(recv_buffer)->cur), sizeof(x)); \
+GIOP_RECV_BUFFER(recv_buffer)->cur = ((guchar *)GIOP_RECV_BUFFER(recv_buffer)->cur) + sizeof(x); \
+}G_STMT_END
+#define ALIGNFOR(x) recv_buffer->cur = ALIGN_ADDRESS(recv_buffer->cur, sizeof(x))
+
+CORBA_Object
+ORBit_create_object_with_info(GSList *profiles,
+			      const CORBA_char *type_id,
+			      CORBA_ORB orb,
+			      CORBA_Environment *ev)
+{
+	CORBA_Object new;
+	struct CORBA_Object_struct refcheck;
+
+	if(!type_id || !*type_id) {
+		g_warning("Failing object creation because object has no type");
+		CORBA_exception_set_system(ev, ex_CORBA_MARSHAL,
+					   CORBA_COMPLETED_MAYBE);
+		return CORBA_OBJECT_NIL;
+	}
+
+	if(g_slist_length(profiles) < 1) {
+		g_warning("Failing object creation because object has no profiles");
+		CORBA_exception_set_system(ev, ex_CORBA_MARSHAL,
+					   CORBA_COMPLETED_MAYBE);
+		return CORBA_OBJECT_NIL;
+	}
+
+	/* XXX badhack :) */
+	refcheck.object_id = type_id;
+	refcheck.profile_list = profiles;
+
+	new = g_hash_table_lookup(orb->objrefs, &refcheck);
+	if(new) {
+		ORBit_delete_profiles(profiles);
+		return CORBA_Object_duplicate(new, ev);
+	}
+
+	new = ORBit_CORBA_Object_new(ev);
+	new->connection = NULL;
+ 	new->object_id = g_strdup(type_id);
+	new->orb = (CORBA_ORB)CORBA_Object_duplicate((CORBA_Object)orb, ev);
+	new->profile_list = profiles;
+	new->active_profile = NULL;
+
+	ORBit_object_try_existing_connections(new);
+
+	g_hash_table_insert(orb->objrefs, new, new);
+	
+	return CORBA_Object_duplicate(new, ev);
+}
+
+static ORBit_Object_info *
+ORBit_demarshal_profile(GIOPRecvBuffer *recv_buffer, IOP_ProfileId profile_id)
+{
+	ORBit_Object_info *object_info;
+	CORBA_unsigned_long subpart_len;
+	CORBA_octet o;
+	CDR_Codec codec_d;
+	CDR_Codec *codec=&codec_d;
+
+	object_info = g_new0(ORBit_Object_info, 1);
+
+	switch(profile_id) {
+	case IOP_TAG_INTERNET_IOP:
+		GET_ATOM(subpart_len); /* The length of the embedded sequence */
+		CDR_codec_init_static(codec);
+		codec->buffer = recv_buffer->cur;
+		codec->release_buffer = CORBA_FALSE;
+		recv_buffer->cur = ((guchar *)recv_buffer->cur) + subpart_len;
+
+		codec->readonly = CORBA_TRUE;
+		codec->host_endian = codec->data_endian = FLAG_ENDIANNESS;
+		codec->buf_len = subpart_len;
+
+		CDR_get_octet(codec, &o);
+		codec->data_endian = o;
+
+		object_info->profile_type = IOP_TAG_INTERNET_IOP;
+		CDR_get_octet(codec, &object_info->iiop_major);
+
+		if(object_info->iiop_major != 1)
+			goto error_exit;
+		/* XXX should we check for a specific minor version? */
+		CDR_get_octet(codec, &object_info->iiop_minor);
+
+		CDR_get_string(codec, &object_info->tag.iopinfo.host);
+
+		CDR_get_ushort(codec, &object_info->tag.iopinfo.port);
+
+		CDR_get_seq_begin(codec, &object_info->object_key._length);
+		object_info->object_key._buffer =
+			ORBit_alloc(object_info->object_key._length, NULL, NULL);
+		CDR_buffer_gets(codec, object_info->object_key._buffer,
+				object_info->object_key._length);
+		object_info->object_key._maximum = object_info->object_key._release = 0;
+
+		ORBit_set_object_key(object_info);
+
+		return(object_info);
+		break;
+
+	case IOP_TAG_MULTIPLE_COMPONENTS:
+	default:
+		GET_ATOM(subpart_len);
+		g_warning("IOP_TAG_MULTIPLE_COMPONENTS decoding needs finishing");
+		object_info->profile_type = IOP_TAG_MULTIPLE_COMPONENTS;
+		recv_buffer->cur = ((guchar *)recv_buffer->cur) + subpart_len;
+		return(object_info);
+		break;
+
+	case IOP_TAG_ORBIT_SPECIFIC:
+		GET_ATOM(subpart_len);
+		CDR_codec_init_static(codec);
+		codec->buffer = recv_buffer->cur;
+		codec->release_buffer = CORBA_FALSE;
+		recv_buffer->cur = ((guchar *)recv_buffer->cur) + subpart_len;
+
+		codec->readonly = CORBA_TRUE;
+		codec->host_endian = codec->data_endian = FLAG_ENDIANNESS;
+		codec->buf_len = subpart_len;
+
+		CDR_get_octet(codec, &o);
+		codec->data_endian = o;
+
+		object_info->profile_type = IOP_TAG_ORBIT_SPECIFIC;
+		CDR_get_octet(codec, &object_info->iiop_major);
+
+		if(object_info->iiop_major != 1)
+			goto error_exit;
+		/* XXX should we check for a specific minor version? */
+		CDR_get_octet(codec, &object_info->iiop_minor);
+
+		CDR_get_string(codec, &object_info->tag.orbitinfo.unix_sock_path);
+		CDR_get_ushort(codec, &object_info->tag.orbitinfo.ipv6_port);
+
+		CDR_get_seq_begin(codec, &object_info->object_key._length);
+		object_info->object_key._buffer =
+			ORBit_alloc(object_info->object_key._length, NULL, NULL);
+		CDR_buffer_gets(codec, object_info->object_key._buffer,
+				object_info->object_key._length);
+		object_info->object_key._maximum = object_info->object_key._release = 0;
+
+		ORBit_set_object_key(object_info);
+
+		return(object_info);
+		break;
+	}
+
+error_exit:
+	g_message("demarshal_profile(): IIOP major is %d",
+		  object_info->iiop_major);
+	g_free(object_info);
+
+	return(NULL);
+}
+
+GSList *ORBit_demarshal_IOR(GIOPRecvBuffer *recv_buffer)
+{
+	GSList *profiles=NULL;
+	ORBit_Object_info *object_info;
+	CORBA_unsigned_long len, seq_len;
+	IOP_ProfileId profile_id;
+	int i;
+
+	/* Get type_id */
+	ALIGNFOR(CORBA_unsigned_long);
+	GET_ATOM(len);
+
+	if(len == 0)
+		return(NULL);
+
+	recv_buffer->cur = ((guchar *)recv_buffer->cur) + len;
+
+	/* Decode the sequence<TaggedProfile> */
+	ALIGNFOR(CORBA_unsigned_long);
+	GET_ATOM(seq_len);
+	for(i = 0; i < seq_len; i++) {
+		ALIGNFOR(CORBA_unsigned_long);
+		GET_ATOM(profile_id);
+		object_info=ORBit_demarshal_profile(recv_buffer, profile_id);
+		if(object_info==NULL) {
+			goto error_exit;
+		} else {
+			profiles=g_slist_append(profiles, object_info);
+		}
+	}
+
+	return(profiles);
+
+error_exit:
+	ORBit_delete_profiles(profiles);
+	return(NULL);
+}
+
+CORBA_Object
+ORBit_demarshal_object(GIOPRecvBuffer *recv_buffer, CORBA_ORB orb)
+{
+	GSList *profiles=NULL;
+	ORBit_Object_info *object_info;
+	CORBA_char *type_id;
+	CORBA_unsigned_long len, seq_len;
+	IOP_ProfileId profile_id;
+	int i;
+	CORBA_Environment ev;
+	CORBA_Object retval;
+
+	CORBA_exception_init(&ev);
+
+	/* Get type_id */
+	ALIGNFOR(CORBA_unsigned_long);
+	GET_ATOM(len);
+
+	type_id = recv_buffer->cur;
+	recv_buffer->cur = ((guchar *)recv_buffer->cur) + len;
+
+	/* Decode the sequence<TaggedProfile> */
+	ALIGNFOR(CORBA_unsigned_long);
+	GET_ATOM(seq_len);
+
+	if(!seq_len)
+		return CORBA_OBJECT_NIL;
+
+	for(i = 0; i < seq_len; i++) {
+		ALIGNFOR(CORBA_unsigned_long);
+		GET_ATOM(profile_id);
+		object_info=ORBit_demarshal_profile(recv_buffer, profile_id);
+		if(object_info)
+			profiles=g_slist_append(profiles, object_info);
+	}
+
+	if(!profiles)
+		goto error_exit;
+
+	retval = ORBit_create_object_with_info(profiles, type_id, orb, &ev);
+
+	return retval;
+
+ error_exit:
+	ORBit_delete_profiles(profiles);
+
+	CORBA_exception_set_system(&ev, ex_CORBA_MARSHAL,
+				   CORBA_COMPLETED_MAYBE);
+	return CORBA_OBJECT_NIL;
+}
+
+static void ORBit_marshal_profile(gpointer item, gpointer data)
+{
+	ORBit_Object_info *info = (ORBit_Object_info *)item;
+	GIOPSendBuffer *send_buffer = (GIOPSendBuffer *)data;
+	static const CORBA_unsigned_long ioptag = IOP_TAG_INTERNET_IOP,
+		orbittag = IOP_TAG_ORBIT_SPECIFIC;
+	CDR_Codec codec_d;
+	CDR_Codec *codec = &codec_d;
+	CORBA_unsigned_long len;
+	CORBA_octet codecbuf[2048];
+	static const CORBA_octet oc_endian = FLAG_ENDIANNESS;
+	static const CORBA_octet iiopversion[] = {1,0};
+
+	g_assert(info);
+	g_assert(send_buffer);
+
+	if(info->profile_type == IOP_TAG_INTERNET_IOP) {
+		giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(send_buffer),
+					       &ioptag, sizeof(ioptag));
+
+		CDR_codec_init_static(codec);
+		codec->buffer = codecbuf;
+		codec->buf_len = 2048;
+		codec->release_buffer = CORBA_FALSE;
+		codec->readonly = CORBA_FALSE;
+		codec->data_endian = codec->host_endian = FLAG_ENDIANNESS;
+		CDR_put_octet(codec, oc_endian);
+		CDR_put_octet(codec, iiopversion[0]);
+		CDR_put_octet(codec, iiopversion[1]);
+		CDR_put_string(codec, info->tag.iopinfo.host);
+		CDR_put_ushort(codec, info->tag.iopinfo.port);
+		CDR_put_ulong(codec, info->object_key._length);
+		CDR_put_octets(codec, info->object_key._buffer,
+			       info->object_key._length);
+		len = codec->wptr;
+		giop_send_buffer_append_mem_indirect_a(send_buffer,
+						       &len, sizeof(len));
+		giop_send_buffer_append_mem_indirect(send_buffer,
+						     codec->buffer, codec->wptr);
+	} else if(info->profile_type==IOP_TAG_ORBIT_SPECIFIC) {
+		giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(send_buffer),
+						 &orbittag, sizeof(orbittag));
+		CDR_codec_init_static(codec);
+		codec->buffer = codecbuf;
+		codec->release_buffer = CORBA_FALSE;
+		codec->buf_len = 2048;
+		codec->readonly = CORBA_FALSE;
+		codec->data_endian = codec->host_endian = FLAG_ENDIANNESS;
+		CDR_put_octet(codec, oc_endian);
+		CDR_put_octets(codec, (gpointer)iiopversion, sizeof(iiopversion));
+		CDR_put_string(codec, info->tag.orbitinfo.unix_sock_path);
+		CDR_put_ushort(codec, info->tag.orbitinfo.ipv6_port);
+		CDR_put_ulong(codec, info->object_key._length);
+		CDR_put_octets(codec, info->object_key._buffer,
+			       info->object_key._length);
+		len = codec->wptr;
+		giop_send_buffer_append_mem_indirect_a(send_buffer,
+						       &len, sizeof(len));
+		giop_send_buffer_append_mem_indirect(send_buffer,
+						     codec->buffer, codec->wptr);
+	} else {
+		g_warning("ORBit_marshal_profile ask to marshal type %d\n", info->profile_type);
+	}
+}
+
+void
+ORBit_marshal_object(GIOPSendBuffer *send_buffer, CORBA_Object obj)
+{
+	CORBA_unsigned_long len;
+
+
+	if(!obj) {
+		static const CORBA_unsigned_long zero = 0, one = 1;
+		/* zero-length typename */
+		giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(send_buffer),
+						 &one, sizeof(one));
+		giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(send_buffer),
+					       &zero, 1);
+
+		/* zero profiles */
+		giop_message_buffer_append_mem_a(GIOP_MESSAGE_BUFFER(send_buffer),
+						 &zero, sizeof(zero));
+		return;
+	}
+	g_return_if_fail(ORBIT_ROOT_OBJECT(obj)->refs > 0);
+
+	len = strlen(obj->object_id) + 1;
+	giop_send_buffer_append_mem_indirect_a(send_buffer, &len,
+					       sizeof(len));
+	giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER(send_buffer),
+				       obj->object_id, len);
+
+	len = g_slist_length(obj->profile_list);
+	giop_send_buffer_append_mem_indirect_a(GIOP_SEND_BUFFER(send_buffer),
+					       &len, sizeof(len));
+
+	/* Marshal active first? */
+	g_slist_foreach(obj->profile_list, ORBit_marshal_profile, send_buffer);
+}
+
+static void ORBit_test_profile(gpointer item, gpointer data)
+{
+	ORBit_Object_info *info = (ORBit_Object_info *)item;
+	CORBA_Object obj = (CORBA_Object)data;
+
+	if(obj->active_profile != NULL)
+		return;		/* we already have a good profile */
+
+	if(info->profile_type == IOP_TAG_ORBIT_SPECIFIC) {
+		if(!ORBit_parse_unixsock(obj, info->tag.orbitinfo.unix_sock_path, TRUE)) {
+			/* success */
+			obj->active_profile=info;
+		}
+	} else if(info->profile_type == IOP_TAG_INTERNET_IOP) {
+		if(!ORBit_parse_inet(obj, info->tag.iopinfo.host, info->tag.iopinfo.port, TRUE)) {
+			/* success */
+			obj->active_profile=info;
+		}
+	}
+}
+
+static void
+ORBit_object_try_existing_connections(CORBA_Object obj)
+{
+	g_slist_foreach(obj->profile_list, ORBit_test_profile, obj);
+}
+
+static void ORBit_activate_profile(gpointer item, gpointer data)
+{
+	ORBit_Object_info *info = (ORBit_Object_info *)item;
+	CORBA_Object obj = (CORBA_Object)data;
+
+	if(obj->active_profile != NULL)
+		return;		/* we already have a good profile */
+
+	if(info->profile_type == IOP_TAG_ORBIT_SPECIFIC) {
+		if(!ORBit_parse_unixsock(obj, info->tag.orbitinfo.unix_sock_path, FALSE)) {
+			/* success */
+			obj->active_profile=info;
+		}
+	} else if(info->profile_type == IOP_TAG_INTERNET_IOP) {
+		if(!ORBit_parse_inet(obj, info->tag.iopinfo.host, info->tag.iopinfo.port, FALSE)) {
+			/* success */
+			obj->active_profile=info;
+		}
+	}
+}
+
+GIOPConnection *
+_ORBit_object_get_connection(CORBA_Object obj)
+{
+	g_return_val_if_fail(obj, NULL);
+
+	if (obj->connection) {
+		giop_connection_unref(obj->connection);
+		obj->connection = NULL;
+		obj->active_profile = NULL;
+	}
+
+	g_slist_foreach(obj->profile_list, ORBit_activate_profile, obj);
+
+	if(obj->active_profile == NULL || !obj->connection)
+		return NULL;
+
+	obj->connection->orb_data = obj->orb;
+
+	return obj->connection;
+}
+
+GIOPConnection *
+ORBit_object_get_forwarded_connection(CORBA_Object obj)
+{
+	g_return_val_if_fail(obj, NULL);
+
+	if (obj->connection) {
+		giop_connection_unref(obj->connection);
+		obj->connection = NULL;
+		obj->active_profile = NULL;
+	}
+
+	g_slist_foreach(obj->forward_locations, ORBit_activate_profile, obj);
+
+	if(obj->active_profile == NULL || !obj->connection)
+		return NULL;
+
+	obj->connection->orb_data = obj->orb;
+
+	return obj->connection;
+}
+
+/* This function is heavily based on the idl stubs output. Any changes there
+   will probably have to be reflected here also. */
+
+void ORBit_object_locate(CORBA_Object obj, CORBA_Environment *ev)
+{
+	GIOPConnection *cnx;
+	GIOPSendBuffer *send_buffer;
+	GIOPRecvBuffer *recv_buffer;
+	GIOP_unsigned_long request_id;
+
+	g_return_if_fail(obj!=NULL);
+	g_return_if_fail(ev!=NULL);
+
+	/* Send a LOCATE_REQUEST, wait for a LOCATE_REPLY. The reply will
+	   either say "Object here", or will carry a new location. We set
+	   obj->active_profile appropriately */
+
+	cnx=ORBit_object_get_connection(obj);
+	if((cnx==NULL) || (obj->active_profile==NULL)) {
+		CORBA_exception_set_system(ev, ex_CORBA_COMM_FAILURE, CORBA_COMPLETED_NO);
+		return;
+	}
+	request_id=giop_get_request_id();
+	send_buffer=giop_send_locate_request_buffer_use(cnx, request_id, &(obj->active_profile->object_key_vec));
+	if(!send_buffer) {
+		CORBA_exception_set_system(ev, ex_CORBA_COMM_FAILURE, CORBA_COMPLETED_NO);
+		return;
+	}
+
+	giop_send_buffer_write(send_buffer);
+	giop_send_buffer_unuse(send_buffer);
+
+	recv_buffer=giop_recv_locate_reply_buffer_use(request_id, TRUE);
+	if(recv_buffer==NULL || recv_buffer->message_buffer.message_header.message_type!=GIOP_LOCATEREPLY) {
+		CORBA_exception_set_system(ev, ex_CORBA_COMM_FAILURE, CORBA_COMPLETED_MAYBE);
+		if(recv_buffer)
+			giop_recv_buffer_unuse(recv_buffer);
+		
+		return;
+	}
+
+	ev->_major=CORBA_NO_EXCEPTION;
+	switch(recv_buffer->message.u.locate_reply.locate_status) {
+	case GIOP_UNKNOWN_OBJECT:
+		CORBA_exception_set_system(ev, ex_CORBA_OBJECT_NOT_EXIST, CORBA_COMPLETED_NO);
+		break;
+
+	case GIOP_OBJECT_HERE:
+		/* No further processing necessary */
+		break;
+
+	case GIOP_OBJECT_FORWARD:
+		/* We've been forwarded onto somewhere else. The message body
+		   contains the new IOR */
+		if(obj->forward_locations != NULL) {
+			ORBit_delete_profiles(obj->forward_locations);
+		}
+		obj->forward_locations=ORBit_demarshal_IOR(recv_buffer);
+
+		/* This will adjust obj->active_profile */
+		cnx=ORBit_object_get_forwarded_connection(obj);
+		break;
+
+	default:
+		g_message("Bad Reply in ORBit_locate_object()\n");
+		break;
+
+	}
+
+	giop_recv_buffer_unuse(recv_buffer);
+}
+
+GIOPConnection *
+ORBit_handle_location_forward(GIOPRecvBuffer *rb, CORBA_Object obj)
+{
+	GIOPConnection *retval;
+
+	if(obj->forward_locations)
+		ORBit_delete_profiles(obj->forward_locations);
+	obj->forward_locations = ORBit_demarshal_IOR(rb);
+
+	retval = ORBit_object_get_forwarded_connection(obj);
+	giop_recv_buffer_unuse(rb);
+
+	return retval;
+}
diff -urN linux-2.4.1/net/korbit/orb/orbit_object.h linux-2.4.1-korbit/net/korbit/orb/orbit_object.h
--- linux-2.4.1/net/korbit/orb/orbit_object.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_object.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,114 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Phil Dawes <philipd@parallax.co.uk>
+ *
+ */
+
+/*
+ *   ORBit specific CORBA_Object funcitons.
+ *
+ */
+#ifndef _ORBIT_ORBIT_OBJECT_H_
+#define _ORBIT_ORBIT_OBJECT_H_
+
+#include <IIOP/IIOP.h>
+#include "corba_object.h"
+
+extern CORBA_Object ORBit_CORBA_Object_new(CORBA_Environment *ev);
+extern void ORBit_CORBA_Object_free(CORBA_Object obj, CORBA_Environment *ev);
+
+
+typedef enum {
+	ORBIT_PSEUDO_ORB,
+	ORBIT_PSEUDO_POA,
+	ORBIT_PSEUDO_POAMANAGER,
+	ORBIT_PSEUDO_POLICY,
+	ORBIT_PSEUDO_TYPECODE,
+	ORBIT_PSEUDO_REQUEST,
+	ORBIT_PSEUDO_SERVERREQUEST,
+	ORBIT_PSEUDO_CONTEXT
+} ORBit_PseudoObject_type;
+typedef struct ORBit_PseudoObject_struct *ORBit_PseudoObject;
+
+void ORBit_pseudo_object_init(ORBit_PseudoObject obj,
+			      ORBit_PseudoObject_type obj_type,
+			      CORBA_Environment *ev);
+void ORBit_policy_object_init(CORBA_Policy obj,
+			      CORBA_PolicyType obj_type,
+			      CORBA_Environment *ev);
+
+/* Use ORBit_CORBA_Object_new() */
+void ORBit_object_reference_init(CORBA_Object obj, CORBA_Environment *ev);
+
+typedef struct {
+	CORBA_char *host;
+	CORBA_unsigned_short port;
+} TAG_INTERNET_IOP_info;
+
+typedef struct {
+	CORBA_char *unix_sock_path;
+	CORBA_unsigned_short ipv6_port;
+} TAG_ORBIT_SPECIFIC_info;
+
+typedef struct {
+	int fill_me_in;
+} TAG_MULTIPLE_COMPONENTS_info;
+
+typedef struct {
+	CORBA_octet iiop_major, iiop_minor;
+	IOP_ProfileId profile_type;
+	union {
+		TAG_INTERNET_IOP_info iopinfo;
+		TAG_ORBIT_SPECIFIC_info orbitinfo;
+		TAG_MULTIPLE_COMPONENTS_info mcinfo;
+	} tag;
+
+	/* If the object key is invariant wrt to the various profiles, then
+	   this should probably go in CORBA_Object_struct
+	 */
+	CORBA_sequence_octet object_key;
+	struct { CORBA_unsigned_long _length; char _buffer[1]; } *object_key_data;
+	struct iovec object_key_vec;
+} ORBit_Object_info;
+
+void ORBit_set_object_key(ORBit_Object_info *info);
+
+CORBA_Object ORBit_create_object_with_info(GSList *profiles,
+					   const CORBA_char *type_id,
+					   CORBA_ORB orb,
+					   CORBA_Environment *ev);
+
+#define ORBit_object_get_connection(obj) \
+     ((obj)->connection && (obj)->connection->is_valid)?((obj)->connection):_ORBit_object_get_connection(obj)
+GIOPConnection *_ORBit_object_get_connection(CORBA_Object obj);
+GIOPConnection *ORBit_object_get_forwarded_connection(CORBA_Object obj);
+void ORBit_object_locate(CORBA_Object obj, CORBA_Environment *ev);
+
+void ORBit_marshal_object(GIOPSendBuffer *send_buffer, CORBA_Object obj);
+CORBA_Object ORBit_demarshal_object(GIOPRecvBuffer *recv_buffer,
+				    CORBA_ORB orb);
+GSList *ORBit_demarshal_IOR(GIOPRecvBuffer *recv_buffer);
+
+extern void ORBit_delete_profiles(GSList *profile_list);
+GIOPConnection *ORBit_handle_location_forward(GIOPRecvBuffer *rb, CORBA_Object obj);
+
+#endif /* _ORBIT_ORBIT_OBJECT_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit_object_type.h linux-2.4.1-korbit/net/korbit/orb/orbit_object_type.h
--- linux-2.4.1/net/korbit/orb/orbit_object_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_object_type.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,87 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *	  Philip Dawes
+ *	  Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+#ifndef _ORBIT_ORBIT_OBJECT_TYPE_H_
+#define _ORBIT_ORBIT_OBJECT_TYPE_H_
+
+#include "orbit_object.h"
+
+
+/****** Root object **********/
+/*****************************/
+
+typedef struct ORBit_RootObject_Interface_struct ORBit_RootObject_Interface;
+struct ORBit_RootObject_Interface_struct
+{
+	void (*release)(gpointer obj, CORBA_Environment *ev);
+};
+
+
+
+#define ORBIT_ROOT_OBJECT(x) ((ORBit_RootObject)(x))
+
+
+typedef struct ORBit_RootObject_struct *ORBit_RootObject;
+struct ORBit_RootObject_struct {
+	ORBit_RootObject_Interface* interface; /* the interface */
+
+	guchar is_pseudo_object;
+	gint refs;
+};
+
+
+/* Reference counting interface */
+
+#define ORBIT_ROOT_OBJECT_REF(obj) (ORBIT_ROOT_OBJECT(obj)->refs++)
+#define ORBIT_ROOT_OBJECT_UNREF(obj) (ORBIT_ROOT_OBJECT(obj)->refs--)
+
+
+     /* Virtual function interface*/
+
+#define ORBIT_ROOT_OBJECT_release(obj,ev) \
+(ORBIT_ROOT_OBJECT(obj)->interface->release(obj,ev))
+
+
+
+extern void ORBit_RootObject_set_interface(ORBit_RootObject obj,
+					   ORBit_RootObject_Interface* epv,
+					   CORBA_Environment *ev);
+
+
+
+/****** Pseudo object --> RootObject ********/
+/*********************************************/
+
+#define ORBIT_PSEUDO_OBJECT(x) ((ORBit_PseudoObject)(x))
+
+struct ORBit_PseudoObject_struct {
+	struct ORBit_RootObject_struct parent;
+	ORBit_PseudoObject_type pseudo_object_type;
+};
+
+
+#endif /* !_ORBIT_CORBA_OBJECT_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit_poa.c linux-2.4.1-korbit/net/korbit/orb/orbit_poa.c
--- linux-2.4.1/net/korbit/orb/orbit_poa.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_poa.c	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,809 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Phil Dawes <philipd@parallax.co.uk>
+ *	    Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+/*
+ *   ORBit specific POA funcitons.
+ *
+ */
+
+#include <string.h>
+#include "orbit.h"
+#include "orbit_poa_type.h"
+#include "orbit_poa.h"
+#include "genrand.h"
+
+#define POA_KEY_LEN (sizeof(CORBA_unsigned_long) + ORBIT_RAND_KEY_LEN)
+#define OBJ_KEY_LEN (sizeof(CORBA_unsigned_long) + ORBIT_RAND_KEY_LEN)
+
+static void ORBit_POAManager_release(PortableServer_POAManager poa_mgr,
+				     CORBA_Environment *ev);
+
+static void ORBit_POA_release(PortableServer_POA poa,
+			      CORBA_Environment *ev);
+
+static PortableServer_Servant
+ORBit_POA_ServantManager_use_servant(PortableServer_POA poa,
+				     GIOPRecvBuffer *recv_buffer,
+				     PortableServer_ServantLocator_Cookie *the_cookie,
+				     PortableServer_ObjectId *oid,
+				     ORBit_POAObject *fake_obj_impl,
+				     CORBA_Environment *ev);
+static void
+ORBit_POA_ServantManager_unuse_servant(PortableServer_Servant servant,
+				       PortableServer_POA poa,
+				       GIOPRecvBuffer *recv_buffer,
+				       PortableServer_ServantLocator_Cookie cookie,
+				       PortableServer_ObjectId *oid,
+				       ORBit_POAObject *fake_obj_impl,
+				       CORBA_Environment *ev);
+
+static const ORBit_RootObject_Interface CORBA_POAManager_epv =
+{
+	(void (*)(gpointer, CORBA_Environment *))ORBit_POAManager_release,
+};
+
+static const ORBit_RootObject_Interface CORBA_POA_epv =
+{
+	(void (*)(gpointer, CORBA_Environment *))ORBit_POA_release,
+};
+
+guint
+g_sequence_octet_hash(CORBA_sequence_octet *so)
+{
+  const char *s = (char*)so->_buffer;
+  const char *p, *e = ((char *)so->_buffer) + so->_length;
+  guint h=0, g;
+
+  for(p = s; p < e; p ++) {
+    h = ( h << 4 ) + *p;
+    if ( ( g = h & 0xf0000000 ) ) {
+      h = h ^ (g >> 24);
+      h = h ^ g;
+    }
+  }
+
+  return h;
+}
+
+gint
+g_sequence_octet_compare(CORBA_sequence_octet *s1, CORBA_sequence_octet *s2)
+{
+	if(s2->_length != s1->_length)
+		return FALSE;
+
+	return !memcmp(s1->_buffer, s2->_buffer, s1->_length);
+}
+
+PortableServer_POAManager 
+ORBit_POAManager_new(CORBA_Environment *ev)
+{
+	PortableServer_POAManager poa_mgr;
+
+	poa_mgr = g_new0(struct PortableServer_POAManager_type, 1);
+
+	if(poa_mgr == NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		goto error;
+	}
+
+	/* Initialise poa manager */
+
+	ORBit_pseudo_object_init(ORBIT_PSEUDO_OBJECT(poa_mgr),
+				 ORBIT_PSEUDO_POAMANAGER, ev);
+	ORBIT_ROOT_OBJECT(poa_mgr)->refs = 0;
+	ORBit_RootObject_set_interface(ORBIT_ROOT_OBJECT(poa_mgr),
+				       (gpointer)&CORBA_POAManager_epv, ev);
+
+	poa_mgr->poa_collection = NULL;
+	poa_mgr->state = PortableServer_POAManager_HOLDING;
+
+	return poa_mgr;
+
+error:
+	if(poa_mgr != NULL){
+		ORBit_POAManager_release(poa_mgr, ev);
+	}
+	return NULL;
+}
+
+static void
+ORBit_POAManager_release(PortableServer_POAManager poa_mgr,
+			 CORBA_Environment *ev)
+{
+
+	if(--(ORBIT_ROOT_OBJECT(poa_mgr)->refs) > 0)
+		return;
+
+	if(poa_mgr != NULL) {
+		if(poa_mgr->poa_collection != NULL)  {
+			g_slist_free(poa_mgr->poa_collection);
+			poa_mgr->poa_collection = NULL;
+		}
+		g_free(poa_mgr);
+		poa_mgr = NULL;
+	}
+}
+
+static void
+ORBit_POAManager_register_poa(PortableServer_POAManager poa_mgr, 
+			      PortableServer_POA poa,
+			      CORBA_Environment *ev)
+{
+	poa_mgr->poa_collection = g_slist_remove(poa_mgr->poa_collection, poa);
+	poa_mgr->poa_collection = 
+		g_slist_append(poa_mgr->poa_collection, poa);
+}
+
+static void
+ORBit_POAManager_unregister_poa(PortableServer_POAManager poa_mgr, 
+				PortableServer_POA poa,
+				CORBA_Environment *ev)
+{
+	poa_mgr->poa_collection = g_slist_remove(poa_mgr->poa_collection, poa);
+}
+
+static void
+ORBit_POA_set_policy(PortableServer_POA poa,
+		     CORBA_Policy policy,
+		     CORBA_Environment *ev)
+{
+	switch(policy->policy_type) {
+	case PortableServer_THREAD_POLICY_ID:
+		poa->thread = ((PortableServer_ThreadPolicy)policy)->value;
+		break;
+	case PortableServer_LIFESPAN_POLICY_ID:
+		poa->lifespan = ((PortableServer_LifespanPolicy)policy)->value;
+		break;
+	case PortableServer_ID_UNIQUENESS_POLICY_ID:
+		poa->id_uniqueness = ((PortableServer_IdUniquenessPolicy)policy)->value;
+		break;
+	case PortableServer_ID_ASSIGNMENT_POLICY_ID:
+		poa->id_assignment = ((PortableServer_IdAssignmentPolicy)policy)->value;
+		break;
+	case PortableServer_IMPLICIT_ACTIVATION_POLICY_ID:
+	  poa->implicit_activation = ((PortableServer_ImplicitActivationPolicy)policy)->value;
+		break;
+	case PortableServer_SERVANT_RETENTION_POLICY_ID:
+	  poa->servant_retention = ((PortableServer_ServantRetentionPolicy)policy)->value;
+		break;
+	case PortableServer_REQUEST_PROCESSING_POLICY_ID:
+		poa->request_processing = ((PortableServer_ServantRetentionPolicy)policy)->value;
+		break;
+	default:
+		g_warning("Unknown policy type, cannot set it on this POA");
+	}
+}
+
+
+static void
+ORBit_POA_check_policy_conflicts(PortableServer_POA poa,
+		     CORBA_Environment *ev)
+{
+
+  /* Check for those policy combinations that aren't allowed */
+  if ((poa->servant_retention == PortableServer_NON_RETAIN &&
+       poa->request_processing == PortableServer_USE_ACTIVE_OBJECT_MAP_ONLY) ||
+      
+      (poa->request_processing == PortableServer_USE_DEFAULT_SERVANT &&
+       poa->id_uniqueness == PortableServer_UNIQUE_ID) ||
+      
+      (poa->implicit_activation == PortableServer_IMPLICIT_ACTIVATION &&
+       (poa->id_assignment == PortableServer_USER_ID ||
+	poa->servant_retention == PortableServer_NON_RETAIN))
+      )
+    {
+      CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+			  ex_PortableServer_POA_InvalidPolicy,
+			  NULL);
+    }
+}
+      
+
+static void
+ORBit_POA_set_policylist(PortableServer_POA poa,
+			 CORBA_PolicyList *policies,
+			 CORBA_Environment *ev)
+{
+	CORBA_unsigned_long i;
+
+	for(i = 0; i < policies->_length; i++) {
+		if(ev->_major != CORBA_NO_EXCEPTION)
+			break;
+		ORBit_POA_set_policy(poa, policies->_buffer[i], ev);
+	}
+}
+
+PortableServer_POA 
+ORBit_POA_new(CORBA_ORB orb,
+	      CORBA_char *adapter_name,
+	      PortableServer_POAManager the_POAManager,
+	      CORBA_PolicyList *policies,
+	      CORBA_Environment *ev)
+{
+	PortableServer_POA poa;
+
+	/* Create the object */
+	poa = (PortableServer_POA) g_new0(struct PortableServer_POA_type, 1); 
+	if(poa == NULL) {
+		CORBA_exception_set_system(ev, ex_CORBA_NO_MEMORY, CORBA_COMPLETED_NO);
+		goto error;
+	}
+
+	ORBit_pseudo_object_init(ORBIT_PSEUDO_OBJECT(poa), ORBIT_PSEUDO_POA, ev);
+
+	ORBIT_ROOT_OBJECT(poa)->refs = 0;
+	ORBit_RootObject_set_interface(ORBIT_ROOT_OBJECT(poa),
+				       (gpointer)&CORBA_POA_epv, ev);
+
+	if(ev->_major != CORBA_NO_EXCEPTION) goto error;
+
+	/* If no POAManager was specified, create one */
+	if(the_POAManager == NULL) {
+	  the_POAManager = ORBit_POAManager_new(ev);
+	}	  
+
+	/* Register this poa with the poa manager */
+	if(the_POAManager != NULL)
+		ORBit_POAManager_register_poa(the_POAManager,poa,ev);
+	if(ev->_major != CORBA_NO_EXCEPTION) goto error;
+
+	/* Wire up the poa_manager */
+	poa->the_POAManager = the_POAManager;
+
+	/* Initialise the child poas table */
+	poa->child_POAs = NULL;      /* initialise the slist */
+
+	poa->held_requests = NULL;
+
+	poa->poaID = orb->poas->len;
+	g_ptr_array_set_size(orb->poas, orb->poas->len + 1);
+	g_ptr_array_index(orb->poas, poa->poaID) = poa;
+
+	poa->orb = orb;
+
+	g_return_val_if_fail(ev->_major == CORBA_NO_EXCEPTION, NULL);
+
+	/* Need to initialise poa policies etc.. here */
+	poa->thread = PortableServer_ORB_CTRL_MODEL;
+	poa->lifespan = PortableServer_TRANSIENT;
+	poa->id_uniqueness = PortableServer_UNIQUE_ID;
+	poa->id_assignment = PortableServer_SYSTEM_ID;
+	poa->servant_retention = PortableServer_RETAIN;
+	poa->request_processing = PortableServer_USE_ACTIVE_OBJECT_MAP_ONLY;
+	poa->implicit_activation = PortableServer_NO_IMPLICIT_ACTIVATION;
+	if (policies) {
+	  ORBit_POA_set_policylist(poa, policies, ev);
+	  ORBit_POA_check_policy_conflicts(poa, ev);
+	  if(ev->_major != CORBA_NO_EXCEPTION) goto error;
+	}
+
+	/* copy the name  */
+	poa->the_name = CORBA_string_dup(adapter_name);
+
+	poa->active_object_map = g_hash_table_new((GHashFunc)g_sequence_octet_hash,
+						  (GCompareFunc)g_sequence_octet_compare);
+	poa->objnum_to_obj = g_ptr_array_new();
+	g_ptr_array_set_size(poa->objnum_to_obj, 1);
+	g_ptr_array_index(poa->objnum_to_obj, 0) = NULL;
+
+	orbit_genrand(poa->rand_data, ORBIT_RAND_KEY_LEN);
+
+	return poa;
+
+error:
+	if(poa && poa->the_name){
+		CORBA_free(poa->the_name);
+	}
+
+	if(poa != NULL){
+		ORBit_POA_release(poa, NULL);
+	}
+	return NULL;
+}
+
+static void
+ORBit_POA_release(PortableServer_POA poa,
+		  CORBA_Environment *ev)
+{
+	ORBIT_ROOT_OBJECT_UNREF(poa);
+
+	if(ORBIT_ROOT_OBJECT(poa)->refs <= 0) {
+		CORBA_free(poa->the_name);
+
+		g_slist_foreach(poa->child_POAs, (GFunc)CORBA_Object_release,
+				ev);
+
+		if(poa->parent_poa)
+			ORBit_POA_remove_child(poa->parent_poa, poa, ev);
+
+		ORBit_POAManager_unregister_poa(poa->the_POAManager, 
+						poa, ev);
+
+		g_ptr_array_index(poa->orb->poas, poa->poaID) = NULL;
+
+		g_free(poa);
+	}
+}
+
+void
+ORBit_POA_add_child(PortableServer_POA poa,
+		    PortableServer_POA child_poa,
+		    CORBA_Environment *ev)
+
+{
+	g_return_if_fail(poa != NULL);
+	g_return_if_fail(child_poa != NULL);
+
+	poa->child_POAs = g_slist_prepend(poa->child_POAs, child_poa);
+}
+
+void
+ORBit_POA_remove_child(PortableServer_POA poa,
+		       PortableServer_POA child_poa,
+		       CORBA_Environment *ev)
+{
+	g_return_if_fail(poa != NULL);
+	g_return_if_fail(child_poa != NULL);
+
+	poa->child_POAs = g_slist_remove(poa->child_POAs, child_poa);
+}
+
+extern ORBit_request_validate ORBIT_request_validator;
+
+gboolean
+ORBit_POA_handle_request(GIOPRecvBuffer *recv_buffer,
+			 PortableServer_POA poa)
+{
+	PortableServer_ServantBase *servant;
+	PortableServer_ServantLocator_Cookie cookie;
+	ORBit_POAObject *obj_impl = NULL, tmp_obj_impl;
+	ORBitSkeleton skel;
+	gpointer imp = NULL;
+	CORBA_Environment ev;
+	GIOPSendBuffer *send_buffer;
+	guchar *opname;
+	PortableServer_ObjectId *oid = NULL;
+
+	CORBA_exception_init(&ev);
+
+	switch(poa->the_POAManager->state) {
+	case PortableServer_POAManager_HOLDING:
+		poa->held_requests = g_slist_prepend(poa->held_requests,
+						     recv_buffer);
+		return FALSE;
+		break;
+	case PortableServer_POAManager_DISCARDING:
+		send_buffer = giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(recv_buffer)->connection,
+							 NULL,
+							 recv_buffer->message.u.request.request_id,
+							 CORBA_SYSTEM_EXCEPTION);
+		CORBA_exception_set_system(&ev,
+					    ex_CORBA_TRANSIENT,
+					    CORBA_COMPLETED_NO);
+		ORBit_send_system_exception(send_buffer, &ev);
+		giop_send_buffer_write(send_buffer);
+		giop_recv_buffer_unuse(recv_buffer);
+		giop_send_buffer_unuse(send_buffer);
+		CORBA_exception_free(&ev);
+		return TRUE;
+		break;
+	case PortableServer_POAManager_INACTIVE:
+		send_buffer = giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(recv_buffer)->connection,
+							 NULL,
+							 recv_buffer->message.u.request.request_id,
+							 CORBA_SYSTEM_EXCEPTION);
+		CORBA_exception_set_system(&ev,
+					    ex_CORBA_OBJ_ADAPTER,
+					    CORBA_COMPLETED_NO);
+		ORBit_send_system_exception(send_buffer, &ev);
+		giop_send_buffer_write(send_buffer);
+		giop_recv_buffer_unuse(recv_buffer);
+		giop_send_buffer_unuse(send_buffer);
+		CORBA_exception_free(&ev);
+		return TRUE;
+		break;
+	case PortableServer_POAManager_ACTIVE:
+	default:
+		break;
+	}
+
+	servant = NULL;
+
+	if(recv_buffer->message.u.request.object_key._length
+	   < (POA_KEY_LEN + sizeof(CORBA_unsigned_long))) {
+		CORBA_exception_set_system(&ev,
+					   ex_CORBA_OBJECT_NOT_EXIST,
+					   CORBA_COMPLETED_NO);
+		goto errout;
+	}
+
+	obj_impl = ORBit_POA_find_oid_for_object_key(poa, &(recv_buffer->message.u.request.object_key), &oid);
+
+	if(poa->servant_retention == PortableServer_RETAIN
+	   && obj_impl) {
+		servant = obj_impl->servant;
+		oid = obj_impl->object_id;
+	}
+
+	if(!servant) {
+		switch(poa->request_processing) {
+		case PortableServer_USE_SERVANT_MANAGER:
+			servant = ORBit_POA_ServantManager_use_servant(poa,
+								       recv_buffer,
+								       &cookie,
+								       oid,
+								       &tmp_obj_impl,
+								       &ev);
+			break;
+		case PortableServer_USE_DEFAULT_SERVANT:
+			servant = poa->default_servant;
+			if(servant == NULL) {
+				CORBA_exception_set_system(&ev,
+							   ex_CORBA_OBJ_ADAPTER,
+							   CORBA_COMPLETED_NO);
+				goto errout;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	if(!poa || !servant || !servant->_private) {
+		CORBA_exception_set_system(&ev,
+					   ex_CORBA_OBJECT_NOT_EXIST,
+					   CORBA_COMPLETED_NO);
+		goto errout;
+	}
+
+	opname = recv_buffer->message.u.request.operation;
+
+	skel = ORBIT_OBJECT_KEY(servant->_private)->class_info->relay_call(servant, recv_buffer, &imp);
+	
+	if(!skel) {
+		if (opname[0] == '_' && strcmp(opname + 1, "is_a") == 0) {
+			skel = (gpointer)&ORBit_impl_CORBA_Object_is_a;
+		}
+		else {
+			CORBA_exception_set_system(&ev, ex_CORBA_BAD_OPERATION,
+						   CORBA_COMPLETED_NO);
+			goto errout;
+		}
+	}
+	else if (!imp) {
+		CORBA_exception_set_system(&ev, ex_CORBA_NO_IMPLEMENT,
+					   CORBA_COMPLETED_NO);
+		goto errout;
+	}
+
+	/* If it got through the random keys, and nobody else had the opportunity to say otherwise, it must be auth'd */
+
+	if(!ORBIT_request_validator)
+		GIOP_MESSAGE_BUFFER(recv_buffer)->connection->is_auth = TRUE;
+
+	skel(servant, recv_buffer, &ev, imp);
+
+	if(poa->request_processing == PortableServer_USE_SERVANT_MANAGER) {
+		ORBit_POA_ServantManager_unuse_servant(servant,
+						       poa,
+						       recv_buffer,
+						       cookie, oid,
+						       &tmp_obj_impl,
+						       &ev);
+	}
+
+	if(!obj_impl)
+		CORBA_free(oid);
+
+	CORBA_exception_free(&ev);
+
+	return TRUE;
+
+ errout:
+	if(ev._major == CORBA_SYSTEM_EXCEPTION) {
+		GIOPSendBuffer *reply_buf;
+
+		reply_buf =
+			giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(recv_buffer)->connection,
+						   NULL,
+						   recv_buffer->message.u.request.request_id,
+						   CORBA_SYSTEM_EXCEPTION);
+
+		 ORBit_send_system_exception(reply_buf, &ev);
+
+		 giop_send_buffer_write(reply_buf);
+		 giop_send_buffer_unuse(reply_buf);
+	} else /* User exceptions are handled in the skels! */
+		g_assert(ev._major == CORBA_NO_EXCEPTION);
+
+	if(!obj_impl)
+		CORBA_free(oid);
+
+	CORBA_exception_free(&ev);
+
+	return TRUE;
+}
+
+PortableServer_POA
+ORBit_POA_find_POA_for_object_key(PortableServer_POA root_poa,
+				  CORBA_sequence_octet *key)
+{
+	CORBA_unsigned_long pid;
+
+	if(key->_length < (sizeof(CORBA_unsigned_long) + ORBIT_RAND_KEY_LEN))
+		return NULL;
+
+	pid = *((CORBA_unsigned_long *)key->_buffer);
+
+	if(pid < root_poa->orb->poas->len) {
+		PortableServer_POA poa;
+		poa = g_ptr_array_index(root_poa->orb->poas, pid);
+		if(!poa)
+			return NULL;
+		if(memcmp(poa->rand_data, key->_buffer + sizeof(CORBA_unsigned_long), ORBIT_RAND_KEY_LEN))
+			return NULL;
+		return poa;
+	} else
+		return NULL;
+}
+
+void
+ORBit_POA_find_object_key_for_oid(PortableServer_POA poa,
+				  ORBit_POAObject *obj,
+				  PortableServer_ObjectId *oid,
+				  CORBA_sequence_octet *retval)
+{
+	CORBA_long *vptr;
+
+	g_return_if_fail(poa && (obj || oid));
+	g_return_if_fail(retval);
+
+	if(oid)
+		g_assert(!oid->_buffer[oid->_length - 1]);
+
+	if(obj)
+		retval->_length = POA_KEY_LEN + OBJ_KEY_LEN;
+	else
+		retval->_length = POA_KEY_LEN  + sizeof(CORBA_long) + oid->_length;
+	retval->_buffer = CORBA_octet_allocbuf(retval->_length);
+	CORBA_sequence_set_release(retval, CORBA_TRUE);
+
+	vptr = (CORBA_long *)retval->_buffer;
+	*vptr = poa->poaID;
+	memcpy(retval->_buffer + sizeof(CORBA_unsigned_long), poa->rand_data, ORBIT_RAND_KEY_LEN);
+
+	vptr = (CORBA_long *)(retval->_buffer + POA_KEY_LEN);
+	if(obj) {
+		*vptr = obj->objnum;
+		memcpy(retval->_buffer + POA_KEY_LEN + sizeof(CORBA_unsigned_long), obj->rand_data, ORBIT_RAND_KEY_LEN);
+	} else {
+		*vptr = -((CORBA_long)oid->_length);
+		memcpy(retval->_buffer + POA_KEY_LEN + sizeof(CORBA_unsigned_long), oid->_buffer, oid->_length);
+	}
+}
+
+ORBit_POAObject *
+ORBit_POA_find_oid_for_object_key(PortableServer_POA poa,
+				  CORBA_sequence_octet *object_key,
+				  PortableServer_ObjectId **oid)
+{
+	CORBA_long onum;
+	guchar *nptr;
+	ORBit_POAObject *objinfo;
+
+	*oid = NULL;
+	nptr = object_key->_buffer + POA_KEY_LEN;
+
+	if(object_key->_length < (POA_KEY_LEN + sizeof(CORBA_long))) {
+		return NULL;
+	}
+
+	onum = *((CORBA_long *)nptr);
+
+	if(onum < 0) {
+		/* onum will be the -strlen(ObjectId) */
+		if(object_key->_length < (POA_KEY_LEN + sizeof(CORBA_long) - onum))
+			return NULL;
+
+		*oid = (PortableServer_ObjectId *)CORBA_sequence_octet__alloc();
+		(*oid)->_length = -onum;
+		(*oid)->_buffer = CORBA_octet_allocbuf((*oid)->_length);
+		memcpy((*oid)->_buffer, object_key->_buffer + POA_KEY_LEN + sizeof(CORBA_long), (*oid)->_length);
+
+		return NULL;
+	}
+
+	if(onum >= poa->objnum_to_obj->len)
+		return NULL;
+
+	objinfo = g_ptr_array_index(poa->objnum_to_obj, onum);
+
+	if(GPOINTER_TO_UINT(objinfo) <= poa->objnum_to_obj->len)
+		return NULL;
+
+	if(object_key->_length < (POA_KEY_LEN + OBJ_KEY_LEN))
+		return NULL;
+
+	if(memcmp(object_key->_buffer + POA_KEY_LEN + sizeof(CORBA_long), objinfo->rand_data, ORBIT_RAND_KEY_LEN))
+		return NULL;
+
+	return objinfo;
+}
+
+DEFINE_LOCK(id_assignment_counter);
+static int id_assignment_counter = 0;
+
+PortableServer_ObjectId *
+ORBit_POA_allocate_oid(PortableServer_POA poa,
+		       const char *basis)
+{
+	PortableServer_ObjectId *new_objid;
+	char buf[512];
+	int len;
+
+	new_objid = (PortableServer_ObjectId *)CORBA_sequence_octet__alloc();
+
+	GET_LOCK(id_assignment_counter);
+	g_snprintf(buf, sizeof(buf), "%s%d", basis?basis:"Object",
+		   id_assignment_counter);
+	id_assignment_counter++;
+	RELEASE_LOCK(id_assignment_counter);
+
+	len = strlen(buf)+1;
+	new_objid->_buffer = CORBA_octet_allocbuf(len);
+	new_objid->_length = len;
+	new_objid->_maximum = len;
+	new_objid->_release = CORBA_TRUE;
+
+	strcpy((CORBA_char *)new_objid->_buffer, buf);
+
+	return new_objid;
+}
+
+static PortableServer_Servant
+ORBit_POA_ServantManager_use_servant(PortableServer_POA poa,
+				     GIOPRecvBuffer *recv_buffer,
+				     PortableServer_ServantLocator_Cookie *the_cookie,
+				     PortableServer_ObjectId *oid,
+				     ORBit_POAObject *fake_obj_impl,
+				     CORBA_Environment *ev)
+{
+	if(poa->servant_retention == PortableServer_RETAIN) {
+		POA_PortableServer_ServantActivator *sm;
+		POA_PortableServer_ServantActivator__epv *epv;
+		
+		sm = (POA_PortableServer_ServantActivator *)poa->servant_manager;
+		epv = sm->vepv->PortableServer_ServantActivator_epv;
+		return epv->incarnate(sm, oid, poa, ev);
+	} else {
+		POA_PortableServer_ServantLocator *sm;
+		POA_PortableServer_ServantLocator__epv *epv;
+		PortableServer_ServantBase *retval;
+
+		sm = (POA_PortableServer_ServantLocator *)poa->servant_manager;
+		epv = sm->vepv->PortableServer_ServantLocator_epv;
+		retval = epv->preinvoke(sm, oid,
+					poa, recv_buffer->message.u.request.operation,
+					the_cookie,
+					ev);
+
+		((ORBit_ObjectKey *)retval->_private)->object = fake_obj_impl;
+		fake_obj_impl->object_id = oid;
+		fake_obj_impl->poa = poa;
+		fake_obj_impl->orb = poa->orb;
+		fake_obj_impl->objnum = -1;
+#ifdef NOT_BACKWARDS_COMPAT_0_4
+		fake_obj_impl->use_count = NULL;
+		fake_obj_impl->death_callback = NULL;
+#endif
+
+		return retval;
+	}
+}
+
+static void
+ORBit_POA_ServantManager_unuse_servant(PortableServer_Servant servant,
+				       PortableServer_POA poa,
+				       GIOPRecvBuffer *recv_buffer,
+				       PortableServer_ServantLocator_Cookie cookie,
+				       PortableServer_ObjectId *oid,
+				       ORBit_POAObject *fake_obj_impl,
+				       CORBA_Environment *ev)
+{
+	POA_PortableServer_ServantLocator *sm;
+	POA_PortableServer_ServantLocator__epv *epv;
+
+	if(poa->servant_retention != PortableServer_NON_RETAIN)
+		return;
+
+	sm = (POA_PortableServer_ServantLocator *)poa->servant_manager;
+	epv = sm->vepv->PortableServer_ServantLocator_epv;
+	
+	((ORBit_ObjectKey *)((PortableServer_ServantBase *)servant)->_private)->object = NULL;
+	epv->postinvoke(sm, oid,
+			poa, recv_buffer->message.u.request.operation,
+			cookie, servant, ev);
+
+}
+
+typedef struct {
+	PortableServer_POA poa;
+	CORBA_Environment *ev;
+} EtherealizeInfo;
+
+void
+ORBit_POA_etherealize_object(PortableServer_ObjectId *oid,
+			     ORBit_POAObject *obj_impl,
+			     EtherealizeInfo *ei)
+{
+	POA_PortableServer_ServantActivator__epv *epv;
+	POA_PortableServer_ServantActivator *sm;
+
+	g_assert(ei->poa->servant_manager);
+
+	g_hash_table_remove(ei->poa->active_object_map,
+			    obj_impl->object_id);
+
+	sm = (POA_PortableServer_ServantActivator *)ei->poa->servant_manager;
+	epv = sm->vepv->PortableServer_ServantActivator_epv;
+	epv->etherealize(sm, obj_impl->object_id, ei->poa,
+			 obj_impl->servant,
+			 CORBA_TRUE, CORBA_FALSE, ei->ev);
+}
+
+void
+ORBit_POA_etherealize_objects(PortableServer_POA poa,
+			      CORBA_Environment *ev)
+{
+	EtherealizeInfo ei;
+
+	ei.poa = poa;
+	ei.ev = ev;
+
+	if(poa->servant_retention == PortableServer_RETAIN
+	   && poa->request_processing == PortableServer_USE_SERVANT_MANAGER) {
+
+		g_hash_table_foreach(poa->active_object_map,
+				     (GHFunc)ORBit_POA_etherealize_object,
+				     &ei);
+	}
+}
+
+#ifdef NOT_BACKWARDS_COMPAT_0_4
+void ORBit_servant_set_deathwatch(PortableServer_ServantBase *servant,
+				  int *use_count,
+                                  GFunc death_func,
+                                  gpointer user_data)
+{
+	ORBit_POAObject *pobj;
+
+	pobj = ORBIT_OBJECT_KEY(servant->_private)->object;
+
+	pobj->use_count = use_count;
+	pobj->death_callback = death_func;
+	pobj->user_data = user_data;
+}
+#endif
diff -urN linux-2.4.1/net/korbit/orb/orbit_poa.h linux-2.4.1-korbit/net/korbit/orb/orbit_poa.h
--- linux-2.4.1/net/korbit/orb/orbit_poa.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_poa.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,89 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Phil Dawes <philipd@parallax.co.uk>
+ *
+ */
+
+/*
+ *   ORBit specific POA funcitons.
+ *
+ */
+
+#ifndef _ORBIT_ORBIT_POA_H_
+#define _ORBIT_ORBIT_POA_H_
+
+#include "orbit_types.h"
+#include "orbit_poa_type.h"
+
+/*
+ * Creates a new POAManager
+ */
+
+extern PortableServer_POAManager ORBit_POAManager_new(CORBA_Environment *ev);
+
+extern void ORBit_POAManager_free(PortableServer_POAManager poa_mgr, 
+				  CORBA_Environment *ev);
+
+extern PortableServer_POA ORBit_POA_new(CORBA_ORB orb,
+					CORBA_char *adapter_name,
+					PortableServer_POAManager the_POAManager,
+					CORBA_PolicyList *policies,
+					CORBA_Environment *ev);
+
+extern void ORBit_POA_free(PortableServer_POA poa, CORBA_Environment *ev);
+
+extern void ORBit_POA_add_child(PortableServer_POA poa,
+				PortableServer_POA child_poa,
+				CORBA_Environment *ev);
+void ORBit_POA_remove_child(PortableServer_POA poa,
+			    PortableServer_POA child_poa,
+			    CORBA_Environment *ev);
+
+gboolean ORBit_POA_handle_request(GIOPRecvBuffer *recv_buffer,
+				  PortableServer_POA poa);
+PortableServer_POA
+ORBit_POA_find_POA_for_object_key(PortableServer_POA root_poa,
+				  CORBA_sequence_octet *key);
+void
+ORBit_POA_find_object_key_for_oid(PortableServer_POA poa,
+				  ORBit_POAObject *obj,
+				  PortableServer_ObjectId *oid,
+				  CORBA_sequence_octet *retval);
+ORBit_POAObject *
+ORBit_POA_find_oid_for_object_key(PortableServer_POA poa,
+				  CORBA_sequence_octet *object_key,
+				  PortableServer_ObjectId **oid);
+
+PortableServer_ObjectId *ORBit_POA_allocate_oid(PortableServer_POA poa,
+						const char *basis);
+
+void ORBit_POA_etherealize_objects(PortableServer_POA poa, CORBA_Environment *ev);
+
+#ifdef NOT_BACKWARDS_COMPAT_0_4
+/* Bad hack for shared libraries */
+void ORBit_servant_set_deathwatch(PortableServer_ServantBase *servant,
+				  int *use_count,
+				  GFunc death_func,
+				  gpointer user_data);
+#endif
+
+#endif /* !_ORBIT_ORBIT_POA_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit_poa_type.h linux-2.4.1-korbit/net/korbit/orb/orbit_poa_type.h
--- linux-2.4.1/net/korbit/orb/orbit_poa_type.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_poa_type.h	Thu Feb  1 11:47:13 2001
@@ -0,0 +1,112 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Phil Dawes <philipd@parallax.co.uk>
+ *
+ */
+
+/*
+ *   ORBit specific POA funcitons.
+ *
+ */
+
+#ifndef _ORBIT_ORBIT_POA_TYPE_H_
+#define _ORBIT_ORBIT_POA_TYPE_H_
+
+typedef void (*ORBitSkeleton)(PortableServer_ServantBase *_ORBIT_servant,
+			      gpointer _ORBIT_recv_buffer,
+			      CORBA_Environment *ev,
+			      gpointer implementation);
+typedef ORBitSkeleton (*ORBit_impl_finder)(PortableServer_ServantBase *servant,
+				    gpointer _ORBIT_recv_buffer,
+				    gpointer *implementation);
+typedef void (*ORBit_local_objref_init)(CORBA_Object obj,
+					PortableServer_ServantBase *servant);
+typedef struct {
+	ORBit_impl_finder relay_call;
+	const gchar *class_name;
+	ORBit_local_objref_init init_local_objref;
+} PortableServer_ClassInfo;
+
+#define ORBIT_RAND_KEY_LEN 8
+
+typedef struct {
+	PortableServer_ObjectId *object_id;
+	PortableServer_Servant servant;
+	PortableServer_POA poa;
+	CORBA_ORB orb;
+	CORBA_unsigned_long objnum;
+
+	/* Stuff for doing shared libraries nicely */
+	guchar rand_data[ORBIT_RAND_KEY_LEN];
+
+#ifdef NOT_BACKWARDS_COMPAT_0_4
+	int *use_count;
+	GFunc death_callback;
+	gpointer user_data;
+#endif
+} ORBit_POAObject;
+
+typedef struct {
+	PortableServer_ClassInfo *class_info;
+	ORBit_POAObject *object;
+} ORBit_ObjectKey;
+
+#define ORBIT_OBJECT_KEY(x) ((ORBit_ObjectKey *)(x))
+
+struct PortableServer_POA_type {
+	struct ORBit_PseudoObject_struct parent;
+
+	PortableServer_POA parent_poa;
+	CORBA_ORB orb;
+	CORBA_unsigned_long poaID;
+
+	GHashTable *active_object_map;
+	GPtrArray *objnum_to_obj; /* maps objnums to ORBit_POAObject's */
+	CORBA_long first_free_id;
+
+	/* Requests received while in a HOLDING state */
+	GSList *held_requests;
+
+	/* this'll be a hash table when I can be arsed to look up 
+	   how to implement efficient hash tables  - Phil.*/
+	GSList *child_POAs;     
+	
+	CORBA_char *the_name;
+	PortableServer_POAManager the_POAManager;
+
+	PortableServer_AdapterActivator the_activator;
+
+	PortableServer_ServantManager servant_manager;
+	PortableServer_Servant default_servant;
+
+	PortableServer_ThreadPolicyValue thread;
+	PortableServer_LifespanPolicyValue lifespan;
+	PortableServer_IdUniquenessPolicyValue id_uniqueness;
+	PortableServer_IdAssignmentPolicyValue id_assignment;
+	PortableServer_ImplicitActivationPolicyValue implicit_activation;
+	PortableServer_ServantRetentionPolicyValue servant_retention;
+	PortableServer_RequestProcessingPolicyValue request_processing;
+
+	guchar rand_data[ORBIT_RAND_KEY_LEN];
+};
+
+#endif /* !_ORBIT_ORBIT_POA_TYPE_H_ */
diff -urN linux-2.4.1/net/korbit/orb/orbit_typecode.c linux-2.4.1-korbit/net/korbit/orb/orbit_typecode.c
--- linux-2.4.1/net/korbit/orb/orbit_typecode.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_typecode.c	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,593 @@
+#include "orbit.h"
+#include "orbit_typecode.h"
+#include "cdr.h"
+#include "corba_typecode_type.h"
+#include <IIOP/giop-msg-buffer.h>
+#include "../IIOP/iiop-endianP.h"
+
+#if 0
+#define CORBA_Object_release(x, y) ({ g_message(__FILE__ ":%d Releasing object %#x from %d", __LINE__, \
+x, ORBIT_ROOT_OBJECT(x)->refs); CORBA_Object_release(x, y); })
+#define CORBA_Object_duplicate(x, y) ({ g_message(__FILE__ ":%d Duping object %#x from %d", __LINE__, \
+x, ORBIT_ROOT_OBJECT(x)->refs); CORBA_Object_duplicate(x, y); })
+#endif
+
+typedef struct{
+	CORBA_TypeCode tc;
+	guint index; 
+}TCRecursionNode;
+
+typedef struct{
+	GSList* prior_tcs; /* Could be a hash table by typecode */
+	guint current_idx; /* The "top-level" index of the start of the current codec */
+}TCEncodeContext;
+
+typedef struct{
+	GSList* prior_tcs; /* Could be a hash table by offset */
+	guint current_idx;
+}TCDecodeContext;
+
+
+
+static void tc_enc(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec(CORBA_TypeCode* t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_objref(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_objref(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_sequence(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_sequence(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_string(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_string(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_struct(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_struct(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_union(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_union(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_enum(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_enum(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_alias(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_alias(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_except(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_except(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_array(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_array(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_fixed(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_fixed(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+static void tc_enc_tk_wstring(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx);
+static void tc_dec_tk_wstring(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx);
+
+
+
+typedef void
+(*CORBA_TypeCodeEncoder)(CORBA_TypeCode t,
+		   CDR_Codec* c,
+		   TCEncodeContext* ctx);
+
+typedef void
+(*CORBA_TypeCodeDecoder)(CORBA_TypeCode t,
+		   CDR_Codec* c,
+		   TCDecodeContext* ctx);
+
+
+typedef enum{
+	TK_EMPTY,
+	TK_SIMPLE,
+	TK_COMPLEX
+} TkType;
+
+typedef struct{
+	TkType type;
+	CORBA_TypeCodeEncoder encoder;
+	CORBA_TypeCodeDecoder decoder;
+} TkInfo;
+
+static const TkInfo tk_info[CORBA_tk_last]={
+	{TK_EMPTY, NULL, NULL}, /* tk_null */
+	{TK_EMPTY, NULL, NULL}, /* tk_void */
+	{TK_EMPTY, NULL, NULL}, /* tk_short */
+	{TK_EMPTY, NULL, NULL}, /* tk_long */
+	{TK_EMPTY, NULL, NULL}, /* tk_ushort */
+	{TK_EMPTY, NULL, NULL}, /* tk_ulong */
+	{TK_EMPTY, NULL, NULL}, /* tk_float */
+	{TK_EMPTY, NULL, NULL}, /* tk_double */
+	{TK_EMPTY, NULL, NULL}, /* tk_boolean */
+	{TK_EMPTY, NULL, NULL}, /* tk_char */
+	{TK_EMPTY, NULL, NULL}, /* tk_octet */
+	{TK_EMPTY, NULL, NULL}, /* tk_any */
+	{TK_EMPTY, NULL, NULL}, /* tk_TypeCode */
+        {TK_EMPTY, NULL, NULL}, /* tk_Principal */
+	{TK_COMPLEX, tc_enc_tk_objref, tc_dec_tk_objref}, /* tk_objref */
+	{TK_COMPLEX, tc_enc_tk_struct, tc_dec_tk_struct}, /* tk_struct */
+        {TK_COMPLEX, tc_enc_tk_union, tc_dec_tk_union}, /* tk_union */
+        {TK_COMPLEX, tc_enc_tk_enum, tc_dec_tk_enum}, /* tk_enum */
+        {TK_SIMPLE, tc_enc_tk_string, tc_dec_tk_string}, /* tk_string */
+        {TK_COMPLEX, tc_enc_tk_sequence, tc_dec_tk_sequence}, /* tk_sequence */
+        {TK_COMPLEX, tc_enc_tk_array, tc_dec_tk_array}, /* tk_array */
+        {TK_COMPLEX, tc_enc_tk_alias, tc_dec_tk_alias}, /* tk_alias */
+        {TK_COMPLEX, tc_enc_tk_except, tc_dec_tk_except}, /* tk_except */
+        {TK_EMPTY, NULL, NULL}, /* tk_longlong */
+        {TK_EMPTY, NULL, NULL}, /* tk_ulonglong */
+        {TK_EMPTY, NULL, NULL}, /* tk_longdouble */
+        {TK_EMPTY, NULL, NULL}, /* tk_wchar */
+	{TK_SIMPLE, tc_enc_tk_wstring, tc_dec_tk_wstring}, /* tk_wstring */
+	{TK_SIMPLE, tc_enc_tk_fixed, tc_dec_tk_fixed} /* tk_fixed */
+};
+
+void ORBit_encode_CORBA_TypeCode(CORBA_TypeCode t, GIOPSendBuffer* buf)
+{
+        CDR_Codec codec_d;
+	CDR_Codec* codec = &codec_d;
+	TCEncodeContext ctx;
+	GSList* l;
+	CORBA_octet codecbuf[2048];
+
+	CDR_codec_init_static(codec);
+
+	codec->wptr = 0;
+	codec->buffer = codecbuf;
+	codec->release_buffer = FALSE;
+	codec->buf_len = 2048;
+	codec->data_endian=FLAG_ENDIANNESS;
+
+	ctx.current_idx=0;
+	ctx.prior_tcs=NULL;
+	tc_enc(t, codec, &ctx);
+	for(l=ctx.prior_tcs;l;l=l->next)
+		g_free(l->data);
+	g_slist_free(ctx.prior_tcs);
+	giop_send_buffer_append_mem_indirect(buf,
+					     codec->buffer,
+					     codec->wptr);
+}
+
+void ORBit_decode_CORBA_TypeCode(CORBA_TypeCode* t, GIOPRecvBuffer* buf)
+{
+        CDR_Codec codec_d;
+	CDR_Codec* codec = &codec_d;
+	TCDecodeContext ctx;
+	GSList* l;
+
+	CDR_codec_init_static(codec);
+	codec->buffer=buf->cur;
+	codec->release_buffer=CORBA_FALSE;
+	codec->readonly=CORBA_TRUE;
+	codec->buf_len =		/* hope this is correct */
+	  ((guchar *)buf->message_body) +
+	  GIOP_MESSAGE_BUFFER(buf)->message_header.message_size
+	  - ((guchar *)buf->cur);
+		
+	codec->data_endian=GIOP_MESSAGE_BUFFER(buf)->message_header.flags & 1;
+
+	ctx.current_idx=0;
+	ctx.prior_tcs=NULL;
+	tc_dec(t, codec, &ctx);
+	for(l=ctx.prior_tcs;l;l=l->next)
+		g_free(l->data);
+	g_slist_free(ctx.prior_tcs);
+	buf->cur = ((guchar *)buf->cur) + codec->rptr;
+}
+	
+
+/* Encode a typecode to a codec, possibly recursively */
+
+static void tc_enc(CORBA_TypeCode tc,
+	       CDR_Codec* codec,
+	       TCEncodeContext* ctx)
+{
+	TCRecursionNode* node;
+	const TkInfo* info;
+	GSList* l;
+	CORBA_octet codecbuf[2048];
+	CDR_Codec encaps_d;
+	CDR_Codec* encaps = &encaps_d;
+
+	g_assert(CLAMP(0, tc->kind, CORBA_tk_last) == tc->kind);
+
+	for(l=ctx->prior_tcs;l;l=l->next){
+		TCRecursionNode* node=l->data;
+		/* CORBA_CORBA_TypeCode_equal might save space, but is slow.. */
+		if(node->tc==tc){
+			CDR_put_ulong(codec, CORBA_tk_recursive);
+			CDR_put_long(codec,
+				     node->index
+				     -ctx->current_idx
+				     -codec->wptr);
+			return;
+		}
+	}
+
+	/* All right, this isn't a previously met type. So record it. */
+	/* NOTE: put kind before recording index so alignment is dealt with! */
+	CDR_put_ulong(codec, tc->kind);
+
+	node=g_new(TCRecursionNode, 1);
+	node->tc=tc;
+	node->index=ctx->current_idx+codec->wptr - 4; /* -4 for kind */
+	ctx->prior_tcs=g_slist_prepend(ctx->prior_tcs, node);
+	
+	info=&tk_info[tc->kind];
+	switch(info->type){
+		guint tmp_index;
+	case TK_EMPTY:
+		break;
+	case TK_COMPLEX:
+		tmp_index=ctx->current_idx;
+		ctx->current_idx+=codec->wptr+4; /* +4 for the length */
+		CDR_codec_init_static(encaps);
+		encaps->wptr = 0;
+		encaps->buffer = codecbuf;
+		encaps->release_buffer = FALSE;
+		encaps->buf_len = 2048;
+		encaps->data_endian=FLAG_ENDIANNESS;
+		CDR_put_octet(encaps, FLAG_ENDIANNESS);
+		(info->encoder)(tc, encaps, ctx);
+		CDR_put_ulong(codec, encaps->wptr);
+		/* Now this is a time hog */ 
+		CDR_put_octets(codec, encaps->buffer, encaps->wptr);
+		ctx->current_idx=tmp_index;
+		break;
+	case TK_SIMPLE:
+		(info->encoder)(tc, codec, ctx);
+	}
+}
+
+static void
+ORBit_TypeCode_release(gpointer obj, CORBA_Environment *ev)
+{
+  /* we will initialize the TC_ constants with a negative refcount */
+  if(ORBIT_ROOT_OBJECT(obj)->refs >= 0) {
+    ORBIT_ROOT_OBJECT_UNREF(obj);
+
+    if(ORBIT_ROOT_OBJECT(obj)->refs <= 0) {
+      CORBA_TypeCode tc = obj;
+      int i;
+
+      g_free(tc->name);
+      g_free(tc->repo_id);
+
+      for(i = 0; i < tc->sub_parts; i++) {
+	if(tc->subnames)
+	  g_free(tc->subnames[i]);
+
+	if(tc->subtypes)
+	  CORBA_Object_release((CORBA_Object)tc->subtypes[i], ev);
+
+	if(tc->sublabels)
+	  CORBA_any__free(&tc->sublabels[i], NULL, TRUE);
+      }
+
+      g_free(tc->subnames);
+      g_free(tc->subtypes);
+      g_free(tc->sublabels);
+
+      if(tc->discriminator)
+	CORBA_Object_release((CORBA_Object)tc->discriminator, ev);
+
+      g_free(obj);
+    }
+
+  }
+}
+
+const ORBit_RootObject_Interface ORBit_TypeCode_epv = {
+  &ORBit_TypeCode_release
+};
+
+static void tc_dec(CORBA_TypeCode* t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CORBA_TCKind kind;
+	CORBA_TypeCode tc;
+	const TkInfo* info;
+	TCRecursionNode* node;
+	CDR_Codec encaps_d;
+	CDR_Codec* encaps = &encaps_d;
+
+	CDR_get_ulong(c, &kind);
+
+	g_assert(CLAMP(0, kind, CORBA_tk_last) == kind);
+
+	if(kind==CORBA_tk_recursive){
+		CORBA_long offset;
+		GSList* l;
+		CDR_get_ulong(c, &offset);
+		for(l=ctx->prior_tcs;l;l=l->next){
+			node=l->data;
+			/* NOTE: below, -4 is b/c we already read offset */
+			if(node->index==ctx->current_idx+c->rptr+offset-4){
+				*t=node->tc;
+				return;
+			}
+		}
+		ORBit_Trace(TraceMod_ORB, TraceLevel_Error,
+			    "tc_dec: Invalid CORBA_TypeCode recursion offset "
+			    "in input buffer\n");
+		g_assert_not_reached();
+	}
+		
+	ORBit_Trace(TraceMod_TC, TraceLevel_Debug, "codec->host_endian: %d, codec->data_endian: %d\n", c->host_endian, c->data_endian);
+	ORBit_Trace(TraceMod_TC, TraceLevel_Debug, "kind: %d, CORBA_tk_last: %d\n", kind, CORBA_tk_last);
+	g_assert(kind<CORBA_tk_last);
+
+	node=g_new(TCRecursionNode, 1);
+	node->index=ctx->current_idx+c->rptr-4; /* -4 for the TCKind */
+	info=&tk_info[kind];
+	
+	tc=g_new0(struct CORBA_TypeCode_struct, 1);
+
+	/* Passing in NULL for CORBA_Environment is patently dangerous. */
+	ORBit_pseudo_object_init((ORBit_PseudoObject)tc,
+				 ORBIT_PSEUDO_TYPECODE, NULL);
+	ORBit_RootObject_set_interface((ORBit_RootObject)tc,
+				       (ORBit_RootObject_Interface *)&ORBit_TypeCode_epv,
+				       NULL);
+
+	tc->kind=kind;
+	switch(info->type){
+		guint tmp_index;
+		CORBA_octet o;
+
+	case TK_EMPTY:
+		break;
+
+	case TK_COMPLEX:
+		tmp_index=ctx->current_idx;
+		CDR_codec_init_static(encaps);
+		CDR_get_ulong(c, &encaps->buf_len);
+		ctx->current_idx+=c->rptr;
+		encaps->buffer=&c->buffer[c->rptr];
+		encaps->release_buffer=CORBA_FALSE;
+		CDR_get_octet(encaps, &o);
+		encaps->data_endian=o;
+		(info->decoder)(tc, encaps, ctx);
+		c->rptr += encaps->buf_len;
+		ctx->current_idx=tmp_index;
+		break;
+	case TK_SIMPLE:
+		(info->decoder)(tc, c, ctx);
+		break;
+	}
+	node->tc=tc;
+	ctx->prior_tcs=g_slist_prepend(ctx->prior_tcs, node);
+	*t=tc;
+}
+
+
+
+static void tc_enc_tk_objref(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	CDR_put_string(c, t->repo_id);
+	CDR_put_string(c, t->name);
+}
+
+static void tc_dec_tk_objref(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CDR_get_string(c, &t->repo_id);
+	CDR_get_string(c, &t->name);
+}
+
+static void tc_enc_tk_sequence(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	tc_enc(*t->subtypes, c, ctx);
+	CDR_put_ulong(c, t->length);
+}
+
+static void tc_dec_tk_sequence(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	t->subtypes=g_new(CORBA_TypeCode, 1);
+	tc_dec(&t->subtypes[0], c, ctx);
+	CORBA_Object_duplicate((CORBA_Object)t->subtypes[0], NULL);
+	CDR_get_ulong(c, &t->length);
+}
+
+static void tc_enc_tk_string(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	CDR_put_ulong(c, t->length);
+}
+
+static void tc_dec_tk_string(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CDR_get_ulong(c, &t->length);
+}
+
+static void tc_enc_tk_struct(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	CORBA_unsigned_long i;
+	CDR_put_string(c, t->repo_id);
+	CDR_put_string(c, t->name);
+	CDR_put_ulong(c, t->sub_parts);
+	for(i=0;i<t->sub_parts;i++){
+		CDR_put_string(c, t->subnames[i]);
+		tc_enc(t->subtypes[i], c, ctx);
+	}
+}
+ 
+static void tc_dec_tk_struct(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CORBA_unsigned_long i;
+	CDR_get_string(c, &t->repo_id);
+	CDR_get_string(c, &t->name);
+	CDR_get_ulong(c, &t->sub_parts);
+	t->subnames=g_new(gchar*, t->sub_parts);
+	t->subtypes=g_new(CORBA_TypeCode, t->sub_parts);
+	for(i=0;i<t->sub_parts;i++){
+		CDR_get_string(c, &t->subnames[i]);
+		tc_dec(&t->subtypes[i], c, ctx);
+		CORBA_Object_duplicate((CORBA_Object)t->subtypes[i], NULL);
+	}
+}	
+
+#define UNION_MEMBERS(dir)					\
+	MEMBER_LOOPER_##dir(ulong, long, long);			\
+    case CORBA_tk_enum: /* fall through */			\
+	MEMBER_LOOPER_##dir(ulong, unsigned_long, ulong);	\
+	MEMBER_LOOPER_##dir(octet, boolean, boolean);		\
+	MEMBER_LOOPER_##dir(octet, char, char);			\
+	MEMBER_LOOPER_##dir(ushort, short, short);		\
+	MEMBER_LOOPER_##dir(ushort, unsigned_short, ushort);	\
+	MEMBER_LOOPER_##dir(ulong_long, long_long, longlong);	\
+	MEMBER_LOOPER_##dir(ulong_long, unsigned_long_long, ulonglong);	\
+	/* MEMBER_LOOPER_##dir(wchar, wchar, wchar); */
+
+
+static void tc_enc_tk_union(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	CORBA_unsigned_long i;
+	CDR_put_string(c, t->repo_id);
+	CDR_put_string(c, t->name);
+	tc_enc(t->discriminator, c, ctx);
+	CDR_put_long(c, t->default_index);
+	CDR_put_ulong(c, t->sub_parts);
+	i=t->sub_parts;
+	/* Thank goodness the discriminator types are rather limited,
+	   we can do the marshalling inline.. */
+#define MEMBER_LOOPER_ENC(putname, typename, tkname) \
+	case CORBA_tk_##tkname: \
+		for(i=0;i<t->sub_parts;i++){ \
+			CDR_put_##putname(c, *(CORBA_##typename*) \
+				      (t->sublabels[i]._value)); \
+			CDR_put_string(c, t->subnames[i]); \
+			tc_enc(t->subtypes[i], c, ctx); \
+		} \
+		break
+
+	switch(t->discriminator->kind){
+	UNION_MEMBERS(ENC);
+	default:
+		ORBit_Trace(TraceMod_ORB, TraceLevel_Error,
+			    "tc_enc_tk_union: Illegal union discriminator "
+			    "type %s\n", t->discriminator->name);
+	}
+}
+
+static void tc_dec_tk_union(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CORBA_unsigned_long i;
+	CDR_get_string(c, &t->repo_id);
+	CDR_get_string(c, &t->name);
+	tc_dec(&t->discriminator, c, ctx);
+	CORBA_Object_duplicate((CORBA_Object)t->discriminator, NULL);
+	CDR_get_ulong(c, &t->default_index);
+	CDR_get_ulong(c, &t->sub_parts);
+
+	t->sublabels=g_new(CORBA_any, t->sub_parts);
+	t->subnames=g_new(gchar*, t->sub_parts);
+	t->subtypes=g_new(CORBA_TypeCode, t->sub_parts);
+
+#define MEMBER_LOOPER_DEC(getname, typename, tkname) \
+    case CORBA_tk_##tkname: \
+	for(i=0;i<t->sub_parts;i++){ 	\
+	    t->sublabels[i]._type = 	\
+	      CORBA_Object_duplicate((CORBA_Object)t->discriminator, NULL); \
+	    t->sublabels[i]._value = g_new(CORBA_##typename,1); \
+	    t->sublabels[i]._release = CORBA_TRUE; \
+	    CDR_get_##getname(c, t->sublabels[i]._value); \
+	    CDR_get_string(c, &t->subnames[i]); \
+	    tc_dec(&t->subtypes[i], c, ctx); \
+	    CORBA_Object_duplicate((CORBA_Object)t->subtypes[i], NULL); \
+	} \
+	break
+
+	switch(t->discriminator->kind){
+	UNION_MEMBERS(DEC);
+	default:
+	    /* XXX: what is correct error handling */
+	    g_assert(!"Not yet implemented.");
+	}
+}
+
+static void tc_enc_tk_enum(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	CORBA_unsigned_long i;
+	CDR_put_string(c, t->repo_id);
+	CDR_put_string(c, t->name);
+	CDR_put_ulong(c, t->sub_parts);
+	for(i=0;i<t->sub_parts;i++)
+		CDR_put_string(c, t->subnames[i]);
+}
+
+static void tc_dec_tk_enum(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CORBA_unsigned_long i;
+	CDR_get_string(c, &t->repo_id);
+	CDR_get_string(c, &t->name);
+	CDR_get_ulong(c, &t->sub_parts);
+	t->subnames=g_new(gchar*, t->sub_parts);
+	for(i=0;i<t->sub_parts;i++)
+		CDR_get_string(c, &t->subnames[i]);
+}
+
+static void tc_enc_tk_alias(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	CDR_put_string(c, t->repo_id);
+	CDR_put_string(c, t->name);
+	tc_enc(*t->subtypes, c, ctx);
+}
+
+static void tc_dec_tk_alias(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	CDR_get_string(c, &t->repo_id);
+	CDR_get_string(c, &t->name);
+	t->subtypes=g_new(CORBA_TypeCode, 1);
+	tc_dec(t->subtypes, c, ctx);
+	CORBA_Object_duplicate((CORBA_Object)t->subtypes[0], NULL);
+}
+
+
+static void tc_enc_tk_except(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	gulong i;
+	CDR_put_string(c, t->repo_id);
+	CDR_put_string(c, t->name);
+	CDR_put_ulong(c, t->sub_parts);
+	for(i=0;i<t->length;i++){
+		CDR_put_string(c, t->subnames[i]);
+		tc_enc(t->subtypes[i], c, ctx);
+	}
+}
+
+static void tc_dec_tk_except(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	gulong i;
+	CDR_get_string(c, &t->repo_id);
+	CDR_get_string(c, &t->name);
+	CDR_get_ulong(c, &t->sub_parts);
+	t->subtypes=g_new(CORBA_TypeCode, t->sub_parts);
+	t->subnames=g_new(gchar*, t->sub_parts);
+	for(i=0;i<t->length;i++){
+		CDR_get_string(c, &t->subnames[i]);
+		tc_dec(&t->subtypes[i], c, ctx);
+		CORBA_Object_duplicate((CORBA_Object)t->subtypes[i], NULL);
+	}
+}
+
+static void tc_enc_tk_array(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	tc_enc(*t->subtypes, c, ctx);
+	CDR_put_ulong(c, t->length);
+}
+
+static void tc_dec_tk_array(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	t->subtypes=g_new(CORBA_TypeCode, 1);
+	tc_dec(t->subtypes, c, ctx);
+	CORBA_Object_duplicate((CORBA_Object)t->subtypes[0], NULL);
+	CDR_get_ulong(c, &t->length);
+}
+
+static void tc_enc_tk_wstring(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	g_assert(!"Not yet implemented.");
+}
+
+static void tc_dec_tk_wstring(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	g_assert(!"Not yet implemented.");
+}
+
+static void tc_enc_tk_fixed(CORBA_TypeCode t, CDR_Codec* c, TCEncodeContext* ctx)
+{
+	g_assert(!"Not yet implemented.");
+}
+
+static void tc_dec_tk_fixed(CORBA_TypeCode t, CDR_Codec* c, TCDecodeContext* ctx)
+{
+	g_assert(!"Not yet implemented.");
+}
diff -urN linux-2.4.1/net/korbit/orb/orbit_typecode.h linux-2.4.1-korbit/net/korbit/orb/orbit_typecode.h
--- linux-2.4.1/net/korbit/orb/orbit_typecode.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_typecode.h	Thu Feb  1 16:21:53 2001
@@ -0,0 +1,10 @@
+#ifndef _ORBIT_ORBIT_TYPECODE_H_
+#define _ORBIT_ORBIT_TYPECODE_H_
+
+#include "orbit_types.h"
+
+extern const ORBit_RootObject_Interface ORBit_TypeCode_epv;
+void ORBit_encode_CORBA_TypeCode(CORBA_TypeCode tc, GIOPSendBuffer* buf);
+void ORBit_decode_CORBA_TypeCode(CORBA_TypeCode* tc, GIOPRecvBuffer* buf);
+
+#endif
diff -urN linux-2.4.1/net/korbit/orb/orbit_types.h linux-2.4.1-korbit/net/korbit/orb/orbit_types.h
--- linux-2.4.1/net/korbit/orb/orbit_types.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/orbit_types.h	Thu Feb  1 16:20:50 2001
@@ -0,0 +1,176 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_TYPES_H_
+#define _ORBIT_TYPES_H_
+
+#include <stddef.h>	/* for wchar_t */
+#include <sys/types.h>  /* for sysdep types */
+#include <netinet/in.h>	/* for sockaddr_in */
+#include <sys/uio.h> /* for struct iovec */
+
+#include <ORBitutil/basic_types.h>
+
+#define CORBA_TRUE 1
+#define CORBA_FALSE 0
+
+typedef CORBA_char *CORBA_ORBid;
+
+typedef CORBA_unsigned_long CORBA_ServiceOption;
+typedef CORBA_unsigned_long CORBA_ServiceDetailType;
+
+#include "corba_orb.h"
+
+/*
+ * CORBA_RepositoryId and CORBA_Identifier are defined in the Interface
+ * Repository, but are needed in other interfaces in the ORB itself.
+ */
+#if !defined(_CORBA_Identifier_defined)
+#define _CORBA_Identifier_defined 1
+typedef CORBA_char *CORBA_Identifier;
+#define CORBA_Identifier__free CORBA_string__free
+#endif
+
+#if !defined(_CORBA_RepositoryId_defined)
+#define _CORBA_RepositoryId_defined 1
+typedef CORBA_char *CORBA_RepositoryId;
+#define CORBA_RepositoryId__free CORBA_string__free
+#endif
+
+#include "corba_any.h"
+
+typedef struct CORBA_ServiceDetail_type CORBA_ServiceDetail;
+typedef struct CORBA_Request_type *CORBA_Request;
+typedef struct CORBA_ServerRequest_type *CORBA_ServerRequest;
+typedef struct CORBA_DynFixed_type *CORBA_DynFixed;
+typedef struct CORBA_Current_type *CORBA_Current;
+typedef void CORBA_Status;
+typedef CORBA_unsigned_long CORBA_enum;
+typedef CORBA_unsigned_long CORBA_Flags;
+
+typedef struct CORBA_NVList_type {
+	CORBA_Flags flags;
+	GArray *list;
+} CORBA_NVList;
+
+#include "corba_context.h"
+
+#include "corba_portableserver.h"
+
+#include "corba_env.h"
+
+#include "corba_sequences_type.h"
+
+#include "corba_basic_sequences_type.h"
+
+#include "corba_object.h"
+
+#include "orbit_object_type.h"
+
+#include "corba_object_type.h"
+
+#include "corba_orb_type.h"
+
+#include "corba_typecode.h"
+#include "corba_typecode_type.h"
+#include "corba_any_type.h"
+#include "corba_any_proto.h"
+
+#if !defined(TC_IMPL_TC_CORBA_Identifier_0)
+#define TC_IMPL_TC_CORBA_Identifier_0 '/'
+#define TC_CORBA_Identifier ((CORBA_TypeCode)&TC_CORBA_Identifier_struct)
+extern const struct CORBA_TypeCode_struct TC_CORBA_Identifier_struct;
+#endif
+
+#if !defined(TC_IMPL_TC_CORBA_RepositoryId_0)
+#define TC_IMPL_TC_CORBA_RepositoryId_0 '/'
+extern const struct CORBA_TypeCode_struct TC_CORBA_RepositoryId_struct;
+#define TC_CORBA_RepositoryId ((CORBA_TypeCode)&TC_CORBA_RepositoryId_struct)
+#endif
+
+/* 19.14 */
+
+/* XXX */
+typedef struct CORBA_fixed_d_s {
+	CORBA_unsigned_short _digits;
+	CORBA_short _scale;
+	signed char _sign;
+	signed char _value[1];
+} CORBA_fixed_d_s;
+
+#include "corba_env_type.h"
+
+
+typedef struct CORBA_WrongTransaction {
+	int dummy;
+} CORBA_WrongTransaction;
+
+#define CORBA_ARG_IN (1<<0)
+#define CORBA_ARG_OUT (1<<1)
+#define CORBA_ARG_INOUT (1<<2)
+#define CORBA_CTX_RESTRICT_SCOPE (1<<3)
+#define CORBA_CTX_DELETE_DESCENDENTS (1<<4)
+#define CORBA_OUT_LIST_MEMORY (1<<5)
+#define CORBA_IN_COPY_VALUE (1<<6)
+#define CORBA_DEPENDENT_LIST (1<<7)
+#define CORBA_INV_NO_RESPONSE (1<<8)
+#define CORBA_INV_TERM_ON_ERROR (1<<9)
+#define CORBA_RESP_NO_WAIT (1<<10)
+
+typedef struct CORBA_NamedValue {
+	CORBA_Identifier name;		/* argument name */
+	CORBA_any argument;		/* argument */
+	CORBA_long len;			/* length/count of argument value */
+	CORBA_Flags arg_modes;		/* argument mode flags */
+} CORBA_NamedValue;
+
+typedef CORBA_char *CORBA_FieldName;
+
+typedef struct CORBA_NameValuePair {
+	CORBA_FieldName id;
+	CORBA_any value;
+} CORBA_NameValuePair;
+
+struct CORBA_Current_type {
+	int fill_me_in;
+};
+
+#include "corba_portableserver_type.h"
+
+typedef CORBA_unsigned_short CORBA_ServiceType;
+
+#define CORBA_Security (1)
+
+struct CORBA_ServiceDetail_type {
+	CORBA_ServiceDetailType service_detail_type;
+	CORBA_sequence_octet service_detail;
+};
+
+typedef struct CORBA_ServiceInformation_struct {
+	CORBA_sequence_ServiceOption service_options;
+	CORBA_sequence_ServiceDetail service_details;
+} CORBA_ServiceInformation;
+
+#endif /* !_ORBIT_TYPES_H_ */
diff -urN linux-2.4.1/net/korbit/orb/poa.c linux-2.4.1-korbit/net/korbit/orb/poa.c
--- linux-2.4.1/net/korbit/orb/poa.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/poa.c	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,1387 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter, and Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *          Elliot Lee <sopwith@redhat.com>
+ *
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+
+#include "orbit.h"
+#include "orbit_poa.h"
+#include "genrand.h"
+
+PortableServer_ThreadPolicyValue
+PortableServer_ThreadPolicy__get_value(PortableServer_ThreadPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+	ev->_major = CORBA_NO_EXCEPTION;
+
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+PortableServer_LifespanPolicyValue
+PortableServer_LifespanPolicy__get_value(PortableServer_LifespanPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+PortableServer_IdUniquenessPolicyValue
+PortableServer_IdUniquenessPolicy__get_value(PortableServer_IdUniquenessPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+PortableServer_IdAssignmentPolicyValue
+PortableServer_IdAssignmentPolicy__get_value(PortableServer_IdAssignmentPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+PortableServer_ImplicitActivationPolicyValue
+PortableServer_ImplicitActivationPolicy__get_value(PortableServer_ImplicitActivationPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+PortableServer_ServantRetentionPolicyValue
+PortableServer_ServantRetentionPolicy__get_value(PortableServer_ServantRetentionPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+PortableServer_RequestProcessingPolicyValue
+PortableServer_RequestProcessingPolicy__get_value(PortableServer_RequestProcessingPolicy  obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		ev->_major = 2 ;
+		goto error_exit;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->value;
+
+error_exit:
+	CORBA_exception_set_system(ev, 0, CORBA_COMPLETED_NO);
+	return 0;
+}
+
+/* make emacs happy; */
+
+PortableServer_POAManager_State
+PortableServer_POAManager_get_state(PortableServer_POAManager obj,
+				    CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return -1;
+	}
+
+	ev->_major = CORBA_NO_EXCEPTION;
+	return obj->state;
+}
+
+/**** PortableServer_POAManager_activate
+      Inputs: 'obj' - a POAManager to activate
+      Outputs: '*ev' - result of the activate operation
+
+      Side effect: Clears the 'held_requests' lists for all POA's
+                   associated with the 'obj' POAManager.
+
+      Description: Sets the POAManager state to 'ACTIVE', then
+                   goes through all the POA's associated with this
+		   POAManager, and makes them re-process their
+		   'held_requests'
+ */
+void
+PortableServer_POAManager_activate(PortableServer_POAManager obj,
+				   CORBA_Environment *ev)
+{
+	GSList *todo;
+	GSList *curitem;
+	PortableServer_POA curpoa;
+
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	if(obj->state == PortableServer_POAManager_INACTIVE) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POAManager_AdapterInactive,
+				    NULL);
+		return;
+	}
+
+	obj->state = PortableServer_POAManager_ACTIVE;
+
+	for(curitem = obj->poa_collection; curitem;
+	    curitem = g_slist_next(curitem)) {
+		curpoa = (PortableServer_POA)curitem->data;
+
+		todo = curpoa->held_requests;
+		curpoa->held_requests = NULL;
+
+		g_slist_foreach(todo, (GFunc)ORBit_POA_handle_request,
+				curpoa);
+		g_slist_foreach(todo, (GFunc)giop_recv_buffer_unuse,
+				NULL);
+
+		g_slist_free(todo);
+	}
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+void
+PortableServer_POAManager_hold_requests(PortableServer_POAManager obj,
+					CORBA_boolean wait_for_completion,
+					CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	if(obj->state == PortableServer_POAManager_INACTIVE) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POAManager_AdapterInactive,
+				    NULL);
+		return;
+	}
+
+	obj->state = PortableServer_POAManager_HOLDING;
+	if(!wait_for_completion)
+		g_warning("hold_requests not finished - don't know how to kill outstanding request fulfillments");
+
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+void
+PortableServer_POAManager_discard_requests(PortableServer_POAManager obj,
+					   CORBA_boolean wait_for_completion,
+					   CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	if(obj->state == PortableServer_POAManager_INACTIVE) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POAManager_AdapterInactive,
+				    NULL);
+		return;
+	}
+
+	obj->state = PortableServer_POAManager_DISCARDING;
+	if(!wait_for_completion)
+		g_warning("discard_requests not finished - don't know how to kill outstanding request fulfillments");
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+void
+PortableServer_POAManager_deactivate(PortableServer_POAManager obj,
+				     CORBA_boolean etherealize_objects,
+				     CORBA_boolean wait_for_completion,
+				     CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	if(obj->state == PortableServer_POAManager_INACTIVE) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POAManager_AdapterInactive,
+				    NULL);
+		return;
+	}
+
+	obj->state = PortableServer_POAManager_INACTIVE;
+
+	if(etherealize_objects)
+		g_slist_foreach(obj->poa_collection, (GFunc)ORBit_POA_etherealize_objects, ev);
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+
+CORBA_boolean
+PortableServer_AdapterActivator_unknown_adapter(PortableServer_AdapterActivator obj,
+						PortableServer_POA parent,
+						CORBA_char *name,
+						CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(CORBA_FALSE);
+}
+
+
+/**** PortableServer_ServantActivator_incarnate
+ */
+PortableServer_Servant
+
+PortableServer_ServantActivator_incarnate
+(PortableServer_ServantActivator obj,
+ PortableServer_ObjectId *oid,
+ PortableServer_POA adapter,
+ CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+void
+PortableServer_ServantActivator_etherealize
+(PortableServer_ServantActivator obj,
+ PortableServer_ObjectId *oid, PortableServer_POA adapter,
+ PortableServer_Servant serv,
+ CORBA_boolean cleanup_in_progress,
+ CORBA_boolean remaining_activations,
+ CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return;
+}
+
+PortableServer_POA
+PortableServer_POA_create_POA
+               (PortableServer_POA poa,
+		CORBA_char *adapter_name,
+		PortableServer_POAManager a_POAManager,
+		CORBA_PolicyList* policies,
+		CORBA_Environment *ev)
+{
+	PortableServer_POA new_poa = NULL;
+	PortableServer_POA check_poa = NULL;
+	
+	/* Check for a child POA by the same name in parent */
+	check_poa = PortableServer_POA_find_POA(poa,adapter_name,
+						FALSE, ev);
+	CORBA_exception_free (ev);
+
+	if (!check_poa) {
+	  new_poa = ORBit_POA_new(poa->orb,
+				  adapter_name, a_POAManager, policies, ev);
+	} else {
+	  CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+			  ex_PortableServer_POA_AdapterAlreadyExists,
+			  NULL);
+	  new_poa = NULL;
+	}
+
+	if(ev->_major == CORBA_NO_EXCEPTION) {
+	  new_poa->parent_poa = poa;
+	  ORBit_POA_add_child(poa, new_poa, ev);
+	}
+
+	return new_poa;
+}
+
+/**** PortableServer_POA_find_POA
+      Inputs: 'obj' - a POA
+              'activate_it' - whether to activate unknown POA's
+
+      Outputs: 'child_poa'
+
+      Description: Finds (and optionally activates) a child POA of 'obj'
+                   with the specified names.
+
+      TODO: Activate non-existent adapters if asked.
+
+ */
+PortableServer_POA
+PortableServer_POA_find_POA(PortableServer_POA obj,
+			    CORBA_char *adapter_name,
+			    CORBA_boolean activate_it,
+			    CORBA_Environment *ev)
+{
+	GSList *curitem;
+	PortableServer_POA child_poa;
+
+	for(curitem = obj->child_POAs; curitem;
+	    curitem = g_slist_next(curitem)) {
+		child_poa = (PortableServer_POA)curitem->data;
+		if(!strcmp(child_poa->the_name, adapter_name)) {
+			ev->_major = CORBA_NO_EXCEPTION;
+			return child_poa;
+		}
+	}
+
+	if(activate_it)
+		g_warning("Don't yet know how to activate POA named \"%s\"",
+			  adapter_name);
+
+	CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+			    ex_PortableServer_POA_AdapterNonExistent,
+			    NULL);	
+
+	return NULL;
+}
+
+/**** PortableServer_POA_destroy
+      Inputs: 'obj' - the POA to be destroyed
+              'etherealize_objects' - flag indicating whether any servant
+	                              manager should be asked to etherealize
+				      objects in the active object map
+	      'wait_for_completion' - flag indicating whether to wait for
+	                              requests currently being handled
+ */
+void
+PortableServer_POA_destroy(PortableServer_POA obj,
+			   CORBA_boolean etherealize_objects,
+			   CORBA_boolean wait_for_completion,
+			   CORBA_Environment *ev)
+{
+	if(etherealize_objects || !wait_for_completion)
+		g_warning("PortableServer_POA_destroy not yet fully implemented; ignoring flags");
+
+	if(ORBIT_ROOT_OBJECT(obj)->refs > 1)
+		g_warning("POA has multiple refs [%d]",
+			  ORBIT_ROOT_OBJECT(obj)->refs);
+
+	CORBA_Object_release((CORBA_Object)obj, ev);
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+PortableServer_ThreadPolicy PortableServer_POA_create_thread_policy(PortableServer_POA obj, PortableServer_ThreadPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_ThreadPolicy retval;
+
+	retval = g_new(struct PortableServer_ThreadPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_THREAD_POLICY_ID, ev);
+
+	retval->value = value;
+
+	return (PortableServer_ThreadPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+PortableServer_LifespanPolicy PortableServer_POA_create_lifespan_policy(PortableServer_POA obj, PortableServer_LifespanPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_LifespanPolicy retval;
+
+	retval = g_new(struct PortableServer_LifespanPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_LIFESPAN_POLICY_ID, ev);
+
+	retval->value = value;
+
+	return (PortableServer_LifespanPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+PortableServer_IdUniquenessPolicy PortableServer_POA_create_id_uniqueness_policy(PortableServer_POA obj, PortableServer_IdUniquenessPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_IdUniquenessPolicy retval;
+
+	retval = g_new(struct PortableServer_IdUniquenessPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_ID_UNIQUENESS_POLICY_ID,
+				 ev);
+
+	retval->value = value;
+
+	return (PortableServer_IdUniquenessPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+PortableServer_IdAssignmentPolicy PortableServer_POA_create_id_assignment_policy(PortableServer_POA obj, PortableServer_IdAssignmentPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_IdAssignmentPolicy retval;
+
+	retval = g_new(struct PortableServer_IdAssignmentPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_ID_ASSIGNMENT_POLICY_ID, ev);
+
+	retval->value = value;
+
+	return (PortableServer_IdAssignmentPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+PortableServer_ImplicitActivationPolicy PortableServer_POA_create_implicit_activation_policy(PortableServer_POA obj, PortableServer_ImplicitActivationPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_ImplicitActivationPolicy retval;
+
+	retval = g_new(struct PortableServer_ImplicitActivationPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_IMPLICIT_ACTIVATION_POLICY_ID, ev);
+
+	retval->value = value;
+
+	return (PortableServer_ImplicitActivationPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+PortableServer_ServantRetentionPolicy PortableServer_POA_create_servant_retention_policy(PortableServer_POA obj, PortableServer_ServantRetentionPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_ServantRetentionPolicy retval;
+
+	retval = g_new(struct PortableServer_ServantRetentionPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_SERVANT_RETENTION_POLICY_ID, ev);
+
+	retval->value = value;
+
+	return (PortableServer_ServantRetentionPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+PortableServer_RequestProcessingPolicy PortableServer_POA_create_request_processing_policy(PortableServer_POA obj, PortableServer_RequestProcessingPolicyValue value, CORBA_Environment *ev)
+{
+	PortableServer_RequestProcessingPolicy retval;
+
+	retval = g_new(struct PortableServer_RequestProcessingPolicy_type, 1);
+	ORBit_policy_object_init((CORBA_Policy)retval,
+				 PortableServer_REQUEST_PROCESSING_POLICY_ID, ev);
+
+	retval->value = value;
+
+	return (PortableServer_RequestProcessingPolicy)CORBA_Object_duplicate((CORBA_Object)retval, ev);
+}
+
+CORBA_char *PortableServer_POA__get_the_name(PortableServer_POA obj, CORBA_Environment *ev)
+{
+	g_assert(obj);
+	g_assert(obj->the_name);
+	return obj->the_name;
+}
+
+PortableServer_POA
+PortableServer_POA__get_the_parent(PortableServer_POA obj,
+				   CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return NULL;
+	}
+
+	return obj->parent_poa;
+}
+
+PortableServer_POAManager
+PortableServer_POA__get_the_POAManager(PortableServer_POA obj,
+				       CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return NULL;
+	}
+
+	return obj->the_POAManager;
+}
+
+PortableServer_AdapterActivator PortableServer_POA__get_the_activator(PortableServer_POA obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return NULL;
+	}
+
+	return obj->the_activator;
+}
+
+void PortableServer_POA__set_the_activator(PortableServer_POA obj, PortableServer_AdapterActivator the_activator, CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev,
+					   ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	obj->the_activator = the_activator;
+}
+
+PortableServer_ServantManager PortableServer_POA_get_servant_manager(PortableServer_POA obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return NULL;
+	}
+
+	if(obj->request_processing != PortableServer_USE_SERVANT_MANAGER) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+
+	return obj->servant_manager;
+}
+
+void PortableServer_POA_set_servant_manager(PortableServer_POA obj, PortableServer_ServantManager imgr, CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	if(obj->request_processing != PortableServer_USE_SERVANT_MANAGER) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return;
+	}
+
+	obj->servant_manager = imgr;
+}
+
+PortableServer_Servant PortableServer_POA_get_servant(PortableServer_POA obj, CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return NULL;
+	}
+
+	if(obj->request_processing != PortableServer_USE_DEFAULT_SERVANT) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+
+	return obj->default_servant;
+}
+
+void PortableServer_POA_set_servant(PortableServer_POA obj, PortableServer_Servant p_servant, CORBA_Environment *ev)
+{
+	if(!obj) {
+		CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	if(obj->request_processing != PortableServer_USE_DEFAULT_SERVANT) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return;
+	}
+
+	obj->default_servant = p_servant;
+}
+
+static CORBA_unsigned_long
+get_objnum_for_obj(PortableServer_POA poa, ORBit_POAObject *obj)
+{
+	CORBA_unsigned_long retval;
+
+	if(poa->first_free_id) {
+		retval = poa->first_free_id;
+		poa->first_free_id = GPOINTER_TO_UINT(g_ptr_array_index(poa->objnum_to_obj,
+									retval));
+		g_ptr_array_index(poa->objnum_to_obj, retval) = obj;
+	} else {
+		retval = poa->objnum_to_obj->len;
+		g_ptr_array_add(poa->objnum_to_obj,
+				obj);
+	}
+
+	return retval;
+}
+
+static CORBA_ORB
+get_orb_for_poa(PortableServer_POA poa)
+{
+	if(poa->orb)
+		return poa->orb;
+	if(poa->parent_poa)
+		return get_orb_for_poa(poa->parent_poa);
+
+	return CORBA_OBJECT_NIL;
+}
+
+PortableServer_ObjectId *
+PortableServer_POA_activate_object(PortableServer_POA obj,
+				   PortableServer_Servant p_servant,
+				   CORBA_Environment *ev)
+{
+	PortableServer_ServantBase *servant;
+	PortableServer_ObjectId *new_objid;
+	ORBit_POAObject *new_obj;
+
+	servant = p_servant;
+
+	if(obj->servant_retention != PortableServer_RETAIN
+	   || obj->id_assignment != PortableServer_SYSTEM_ID) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+	
+	/* Servant Already Active */
+	if((obj->id_uniqueness==PortableServer_UNIQUE_ID) &&
+	   (ORBIT_OBJECT_KEY(servant->_private)->object != 0)) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_ServantAlreadyActive,
+				    NULL);
+		return NULL;
+	}
+	
+
+	new_obj = g_new0(ORBit_POAObject, 1);
+	new_obj->object_id = (PortableServer_ObjectId*)CORBA_sequence_octet__alloc();
+
+	new_objid =
+		ORBit_POA_allocate_oid(obj,
+					ORBIT_OBJECT_KEY(servant->_private)->class_info->class_name);
+	
+	new_obj->object_id->_buffer = CORBA_octet_allocbuf(new_objid->_length);
+	new_obj->object_id->_length = new_objid->_length;
+	memcpy(new_obj->object_id->_buffer, new_objid->_buffer,
+		new_objid->_length);
+	CORBA_sequence_set_release(new_obj->object_id, CORBA_TRUE);
+
+	new_obj->servant = p_servant;
+	ORBIT_OBJECT_KEY(servant->_private)->object = new_obj;
+	new_obj->orb = get_orb_for_poa(obj);
+	new_obj->poa = obj;
+	new_obj->objnum = get_objnum_for_obj(obj, new_obj);
+	orbit_genrand(new_obj->rand_data, ORBIT_RAND_KEY_LEN);
+
+	g_hash_table_insert(obj->active_object_map,
+			    new_obj->object_id,
+			    new_obj);
+
+	ev->_major = CORBA_NO_EXCEPTION;
+
+	return new_objid;
+}
+
+void
+PortableServer_POA_activate_object_with_id(PortableServer_POA obj,
+					   PortableServer_ObjectId *id,
+					   PortableServer_Servant p_servant,
+					   CORBA_Environment *ev)
+{
+	PortableServer_ServantBase *servant = p_servant;
+	ORBit_POAObject *newobj;
+
+	if(!obj || !id || !p_servant) {
+		CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	newobj = g_hash_table_lookup(obj->active_object_map,
+				     id);
+
+	if(newobj) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_ObjectAlreadyActive, NULL);
+		return;
+	}
+
+	newobj = g_new0(ORBit_POAObject, 1);
+	newobj->object_id = (PortableServer_ObjectId *)CORBA_sequence_octet__alloc();
+	newobj->object_id->_length = id->_length;
+	newobj->object_id->_buffer = CORBA_octet_allocbuf(id->_length);
+	newobj->object_id->_release = CORBA_TRUE;
+	memcpy(newobj->object_id->_buffer, id->_buffer, id->_length);
+	newobj->poa = obj;
+	newobj->orb = get_orb_for_poa(obj);
+	newobj->objnum = get_objnum_for_obj(obj, newobj);
+	orbit_genrand(newobj->rand_data, ORBIT_RAND_KEY_LEN);
+
+	newobj->servant = p_servant;
+
+	g_hash_table_insert(obj->active_object_map,
+			    newobj->object_id,
+			    newobj);
+
+	ORBIT_OBJECT_KEY(servant->_private)->object = newobj;
+
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+void
+PortableServer_POA_deactivate_object(PortableServer_POA obj,
+				     PortableServer_ObjectId *oid,
+				     CORBA_Environment *ev)
+{
+	ORBit_POAObject *oldobj;
+
+	if(!obj || !oid) {
+		CORBA_exception_set_system(ev, ex_CORBA_BAD_PARAM,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	oldobj = g_hash_table_lookup(obj->active_object_map,
+				     oid);
+
+	if(!oldobj) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_ObjectNotActive,
+				    NULL);
+		return;
+	}
+
+	g_ptr_array_index(obj->objnum_to_obj, oldobj->objnum) = GUINT_TO_POINTER(obj->first_free_id);
+	obj->first_free_id = oldobj->objnum;
+
+	g_hash_table_remove(obj->active_object_map, oid);
+
+	if(obj->request_processing == PortableServer_USE_SERVANT_MANAGER) {
+		POA_PortableServer_ServantActivator__epv *epv;
+		POA_PortableServer_ServantActivator *sm;
+
+		sm = (POA_PortableServer_ServantActivator *)obj->servant_manager;
+		epv = sm->vepv->PortableServer_ServantActivator_epv;
+		epv->etherealize(sm, oldobj->object_id, obj,
+				oldobj->servant,
+				CORBA_FALSE,
+				CORBA_FALSE,
+				ev);
+	}
+
+	CORBA_free(oldobj->object_id);
+
+	g_free(oldobj);
+	ev->_major = CORBA_NO_EXCEPTION;
+}
+
+CORBA_Object
+PortableServer_POA_create_reference(PortableServer_POA obj,
+				    CORBA_RepositoryId intf,
+				    CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+PortableServer_ObjectId *PortableServer_POA_servant_to_id(PortableServer_POA obj, PortableServer_Servant p_servant, CORBA_Environment *ev)
+{
+	PortableServer_ObjectId *retval, *orig;
+	PortableServer_ServantBase *serv = p_servant;
+	g_return_val_if_fail(p_servant != NULL, NULL);
+
+	orig = ORBIT_OBJECT_KEY(serv->_private)->object->object_id;
+	retval = (PortableServer_ObjectId *)CORBA_sequence_octet__alloc();
+	retval->_length = retval->_maximum = orig->_length;
+	retval->_buffer = CORBA_octet_allocbuf(retval->_length);
+	memcpy(retval->_buffer, orig->_buffer, retval->_length);
+	CORBA_sequence_set_release(retval, CORBA_TRUE);
+
+	return retval;
+}
+
+CORBA_Object
+PortableServer_POA_servant_to_reference(PortableServer_POA obj, PortableServer_Servant p_servant, CORBA_Environment *ev)
+{
+	CORBA_Object retval;
+	PortableServer_ObjectId *orig_id;
+	PortableServer_ServantBase *servant = p_servant;
+	ORBit_ObjectKey *obj_key =  ORBIT_OBJECT_KEY(servant->_private);
+	
+	int implicit = (obj->implicit_activation == PortableServer_IMPLICIT_ACTIVATION);
+	int activate_able = (obj_key->object == 0) ||
+		(obj->id_uniqueness==PortableServer_MULTIPLE_ID);
+	/* ImplicitActivationPolicy */
+	if( implicit && activate_able) {
+		orig_id = PortableServer_POA_activate_object(obj, p_servant, ev);
+	} else {
+		orig_id = obj_key->object->object_id;
+	}
+	retval = PortableServer_POA_id_to_reference(obj,orig_id,ev);
+
+	return retval;
+}
+
+PortableServer_Servant
+PortableServer_POA_reference_to_servant(PortableServer_POA obj, CORBA_Object reference, CORBA_Environment *ev)
+{
+	GSList *cur;
+
+	g_assert(reference);
+
+	if(obj->request_processing != PortableServer_USE_DEFAULT_SERVANT
+	   && obj->servant_retention != PortableServer_RETAIN) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+
+	if(reference->servant)
+		return reference->servant;
+
+	for(cur = reference->profile_list; cur; cur = cur->next) {
+		PortableServer_ObjectId *oid;
+		ORBit_Object_info *curprof = cur->data;
+		ORBit_POAObject *objinfo;
+
+		objinfo = ORBit_POA_find_oid_for_object_key(obj, &(curprof->object_key), &oid);
+		CORBA_free(oid);
+		if(objinfo)
+			return objinfo->servant;
+	}
+
+	CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+			    ex_PortableServer_POA_ObjectNotActive,
+			    NULL);
+	return NULL;
+}
+
+PortableServer_ObjectId *PortableServer_POA_reference_to_id(PortableServer_POA obj, CORBA_Object reference, CORBA_Environment *ev)
+{
+	PortableServer_ObjectId *retval;
+	ORBit_POAObject *objinfo;
+
+	g_assert(reference);
+	g_assert(reference->active_profile);
+
+	if(obj->request_processing != PortableServer_USE_DEFAULT_SERVANT
+	   && obj->servant_retention != PortableServer_RETAIN) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+
+	objinfo = ORBit_POA_find_oid_for_object_key(obj, &(reference->active_profile->object_key), &retval);
+	if(objinfo) {
+		CORBA_free(retval);
+		retval = (PortableServer_ObjectId *)CORBA_sequence_octet__alloc();
+		retval->_length = retval->_maximum = objinfo->object_id->_length;
+		retval->_buffer = CORBA_octet_allocbuf(retval->_length);
+		memcpy(retval->_buffer, objinfo->object_id->_buffer, retval->_length);
+		CORBA_sequence_set_release(retval, CORBA_TRUE);
+		return retval;
+	} else if(retval)
+		return retval;
+
+	CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+			    ex_PortableServer_POA_ObjectNotActive,
+			    NULL);
+	return NULL;
+}
+
+PortableServer_Servant PortableServer_POA_id_to_servant(PortableServer_POA obj, PortableServer_ObjectId *oid, CORBA_Environment *ev)
+{
+	ORBit_POAObject *objinfo;
+
+	if(obj->servant_retention != PortableServer_RETAIN) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+
+	objinfo = g_hash_table_lookup(obj->active_object_map,
+				      oid);
+
+	if(!objinfo) {
+		CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
+				    ex_PortableServer_POA_WrongPolicy,
+				    NULL);
+		return NULL;
+	}
+
+	return objinfo->servant;
+}
+
+static CORBA_Object
+my_PortableServer_POA_id_to_reference(PortableServer_POA obj,
+				      PortableServer_ObjectId *oid,
+				      const char *type_id,
+				      CORBA_Environment *ev)
+{
+	GSList *profiles=NULL;
+	ORBit_Object_info *object_info;
+	CORBA_Object retval;
+	CORBA_ORB orb;
+	ORBit_POAObject *pobj;
+	ORBit_ObjectKey *objkey = NULL;
+
+	orb = obj->the_POAManager->orb;
+
+	g_assert(!oid->_buffer[oid->_length - 1]);
+
+	pobj = g_hash_table_lookup(obj->active_object_map, oid);
+
+	if(pobj) {
+		objkey = ORBIT_OBJECT_KEY(((PortableServer_ServantBase *)pobj->servant)->_private);
+		type_id= objkey->class_info->class_name;
+	}
+
+	/* Do the local connection first, so it will be attempted first by
+	   the client parsing the IOR string
+	 */
+	if(orb->cnx.ipv6 || orb->cnx.usock) {
+		object_info = g_new0(ORBit_Object_info, 1);
+
+		object_info->profile_type=IOP_TAG_ORBIT_SPECIFIC;
+		object_info->iiop_major = 1;
+		object_info->iiop_minor = 0;
+
+		ORBit_POA_find_object_key_for_oid(obj, pobj, oid, &object_info->object_key);
+
+#ifdef HAVE_IPV6
+		if(orb->cnx.ipv6) {
+			object_info->tag.orbitinfo.ipv6_port =
+				ntohs(IIOP_CONNECTION(orb->cnx.ipv6)->u.ipv6.location.sin_port);
+		}
+#endif
+		if(orb->cnx.usock) {
+			object_info->tag.orbitinfo.unix_sock_path =
+				g_strdup(IIOP_CONNECTION(orb->cnx.usock)->u.usock.sun_path);
+		}
+		ORBit_set_object_key(object_info);
+		profiles=g_slist_append(profiles, object_info);
+	}
+
+	if(orb->cnx.ipv4) {
+		object_info=g_new0(ORBit_Object_info, 1);
+
+		object_info->profile_type = IOP_TAG_INTERNET_IOP;
+		object_info->iiop_major = 1;
+		object_info->iiop_minor = 0;
+		ORBit_POA_find_object_key_for_oid(obj, pobj, oid, &object_info->object_key);
+
+		object_info->tag.iopinfo.host = g_strdup(IIOP_CONNECTION(orb->cnx.ipv4)->u.ipv4.hostname);
+		object_info->tag.iopinfo.port = ntohs(IIOP_CONNECTION(orb->cnx.ipv4)->u.ipv4.location.sin_port);
+
+		ORBit_set_object_key(object_info);
+		profiles=g_slist_append(profiles, object_info);
+	}
+
+	retval = ORBit_create_object_with_info(profiles, type_id, orb, ev);
+
+	if(retval != CORBA_OBJECT_NIL
+	   && ev->_major == CORBA_NO_EXCEPTION
+	   && objkey && objkey->class_info && objkey->class_info->init_local_objref) {
+		/* XXX potential memleak if we get an already-valid objref */
+		retval->vepv = g_new0(gpointer, ORBit_class_assignment_counter + 1);
+		retval->vepv_size = ORBit_class_assignment_counter + 1;
+		objkey->class_info->init_local_objref(retval, pobj->servant);
+		retval->servant = pobj->servant;
+	} else
+		retval->vepv = retval->servant = NULL;
+
+	return retval;
+}
+
+CORBA_Object PortableServer_POA_id_to_reference(PortableServer_POA obj,
+						PortableServer_ObjectId *oid,
+						CORBA_Environment *ev)
+{
+	return my_PortableServer_POA_id_to_reference(obj, oid, NULL, ev);
+}
+
+CORBA_Object
+PortableServer_POA_create_reference_with_id(PortableServer_POA obj,
+					    PortableServer_ObjectId *oid,
+					    CORBA_RepositoryId intf,
+					    CORBA_Environment *ev)
+{
+	return my_PortableServer_POA_id_to_reference(obj, oid, intf, ev);
+}
+
+PortableServer_POA PortableServer_Current_get_POA(PortableServer_Current obj, CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+PortableServer_ObjectId *PortableServer_Current_get_object_id(PortableServer_Current obj, CORBA_Environment *ev)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+
+CORBA_char *PortableServer_ObjectId_to_string(PortableServer_ObjectId *id, CORBA_Environment *env)
+{
+	return CORBA_string_dup((CORBA_char *)id->_buffer);
+}
+
+CORBA_wchar *PortableServer_ObjectId_to_wstring(PortableServer_ObjectId *id, CORBA_Environment *env)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+PortableServer_ObjectId *PortableServer_string_to_ObjectId(CORBA_char *str, CORBA_Environment *env)
+{
+	PortableServer_ObjectId *retval;
+
+	retval = (PortableServer_ObjectId *)CORBA_sequence_octet__alloc();
+
+	retval->_length = strlen(str) + 1;
+	retval->_buffer = CORBA_octet_allocbuf(retval->_length);
+
+	memcpy(retval->_buffer, str, retval->_length);
+
+	return retval;
+}
+
+PortableServer_ObjectId *PortableServer_wstring_to_ObjectId(CORBA_wchar *str, CORBA_Environment *env)
+{
+	g_assert(!"Not yet implemented");
+	return(NULL);
+}
+
+
+PortableServer_POA PortableServer_ServantBase__default_POA(PortableServer_Servant servant, CORBA_Environment *ev)
+{
+	g_return_val_if_fail(servant, NULL);
+
+	return ORBIT_OBJECT_KEY(((PortableServer_ServantBase *)servant)->_private)->object->poa;
+}
+
+void PortableServer_ServantLocator_preinvoke(PortableServer_ObjectId *oid, PortableServer_POA adapter, CORBA_Identifier op_name, PortableServer_ServantLocator_Cookie *cookie)
+{
+	g_assert(!"Not yet implemented");
+	return;
+}
+
+void PortableServer_ServantLocator_postinvoke(PortableServer_ObjectId *oid, PortableServer_POA adapter, CORBA_Identifier op_name, PortableServer_ServantLocator_Cookie cookie, PortableServer_Servant servant)
+{
+	g_assert(!"Not yet implemented");
+	return;
+}
+
+void PortableServer_ServantBase__init(PortableServer_Servant servant,
+				      CORBA_Environment *ev)
+{
+	PortableServer_ServantBase *serv = servant;
+
+	if(!serv->_private) /* If not already initialized, create the place to
+			       stick our info */
+		serv->_private = g_new0(ORBit_ObjectKey, 1);
+}
+
+void PortableServer_ServantBase__fini(PortableServer_Servant servant,
+				      CORBA_Environment *ev)
+{
+	PortableServer_ServantBase *serv = servant;
+
+	g_free(serv->_private);
+	serv->_private = NULL;
+}
+
+
+/************************ ServerRequest stuff ********************/
+
+CORBA_Identifier CORBA_ServerRequest_operation(CORBA_ServerRequest req, CORBA_Environment *env)
+{
+	return CORBA_string_dup(req->rbuf->message.u.request.operation);
+}
+
+CORBA_Context
+CORBA_ServerRequest_ctx(CORBA_ServerRequest req, CORBA_Environment *env)
+{
+	if(!req->params || req->did_ctx) {
+		CORBA_exception_set_system(env, ex_CORBA_BAD_INV_ORDER,
+					   CORBA_COMPLETED_NO);
+		return NULL;
+	}
+
+	return NULL;
+}
+
+void
+CORBA_ServerRequest_arguments(CORBA_ServerRequest req,
+			      CORBA_NVList *parameters,
+			      CORBA_Environment *env)
+{
+	int i;
+
+	if(req->params) {
+		CORBA_exception_set_system(env, ex_CORBA_BAD_INV_ORDER,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	req->params = parameters;
+
+	for(i = 0; i < parameters->list->len; i++) {
+		CORBA_NamedValue *cur;
+
+		cur = &g_array_index(parameters->list, CORBA_NamedValue, i);
+
+		if(cur->arg_modes & CORBA_ARG_OUT) continue;
+		cur->argument._value = ORBit_demarshal_arg(req->rbuf,
+							   cur->argument._type,
+							   TRUE,
+							   (CORBA_ORB)req->orb);
+		CORBA_any_set_release(&cur->argument, TRUE);
+	}
+}
+
+void
+CORBA_ServerRequest_set_result(CORBA_ServerRequest req,
+			       CORBA_any *value,
+			       CORBA_Environment *env)
+{
+	if(req->sbuf) {
+		CORBA_exception_set_system(env, ex_CORBA_BAD_INV_ORDER,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	req->sbuf = giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(req->rbuf)->connection,
+					       NULL,
+					       req->rbuf->message.u.request.request_id,
+					       CORBA_NO_EXCEPTION);
+	if(!req->sbuf) {
+		CORBA_exception_set_system(env, ex_CORBA_COMM_FAILURE,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+		
+	ORBit_marshal_arg(req->sbuf, value->_value, value->_type);
+}
+
+void
+CORBA_ServerRequest_set_exception(CORBA_ServerRequest req,
+				  CORBA_exception_type major,
+				  CORBA_any *value,
+				  CORBA_Environment *env)
+{
+	if(req->sbuf) {
+		CORBA_exception_set_system(env, ex_CORBA_BAD_INV_ORDER,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	req->sbuf = giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(req->rbuf)->connection,
+					       NULL,
+					       req->rbuf->message.u.request.request_id,
+					       major);
+	if(!req->sbuf) {
+		CORBA_exception_set_system(env, ex_CORBA_COMM_FAILURE,
+					   CORBA_COMPLETED_NO);
+		return;
+	}
+
+	req->did_exc = TRUE;
+
+	/* XXX do we really need to copy the repo_id into the
+	   send buffer? Or is there a way to assume that the CORBA_TypeCode
+	   value->_type will be around until after we send the message? */
+	{
+		CORBA_unsigned_long slen;
+		slen = strlen(value->_type->repo_id) + 1;
+		giop_send_buffer_append_mem_indirect_a(req->sbuf, &slen,
+						       sizeof(slen));
+		giop_send_buffer_append_mem_indirect(req->sbuf,
+						     value->_type->repo_id,
+						     slen);
+	}
+		
+	ORBit_marshal_arg(req->sbuf, value->_value, value->_type);
+}
+
+void
+POA_PortableServer_ServantActivator__init(PortableServer_Servant servant,
+					CORBA_Environment * ev)
+{
+	static const PortableServer_ClassInfo class_info =
+	{NULL,
+	"IDL:omg.org/PortableServer/ServantActivator:1.0",
+	NULL};
+
+	PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant), ev);
+
+	ORBIT_OBJECT_KEY(((PortableServer_ServantBase *)servant)->_private)->class_info = (gpointer)&class_info;
+}
+
+void
+POA_PortableServer_ServantActivator__fini(PortableServer_Servant servant,
+					CORBA_Environment * ev)
+{
+	PortableServer_ServantBase__fini(servant, ev);
+}
+
+void
+POA_PortableServer_ServantLocator__init(PortableServer_Servant servant,
+					CORBA_Environment * ev)
+{
+	static const PortableServer_ClassInfo class_info =
+	{NULL,
+	"IDL:omg.org/PortableServer/ServantLocator:1.0",
+	NULL};
+
+	PortableServer_ServantBase__init(((PortableServer_ServantBase *)servant), ev);
+
+	ORBIT_OBJECT_KEY(((PortableServer_ServantBase *)servant)->_private)->class_info = (gpointer)&class_info;
+}
+
+void
+POA_PortableServer_ServantLocator__fini(PortableServer_Servant servant,
+					CORBA_Environment * ev)
+{
+	PortableServer_ServantBase__fini(servant, ev);
+}
+
+/* POA-related DSI stuff */
+static void
+dynamic_impl_skel(PortableServer_DynamicImpl *_ORBIT_servant,
+		  GIOPRecvBuffer *_ORBIT_recv_buffer,
+		  CORBA_Environment *ev,
+		  PortableServer_DynamicImplRoutine invoke)
+{
+	/* here the magic occurs... */
+	struct CORBA_ServerRequest_type sr;
+
+	ORBit_pseudo_object_init(ORBIT_PSEUDO_OBJECT(&sr),
+				 ORBIT_PSEUDO_SERVERREQUEST, ev);
+
+	CORBA_Object_duplicate((CORBA_Object)&sr, ev); /* just to make
+							  sure it doesn't die
+							  elsewhere */
+
+	sr.rbuf = _ORBIT_recv_buffer;
+	sr.orb = GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->connection->orb_data;
+
+	_ORBIT_servant->vepv->PortableServer_DynamicImpl_epv->invoke(_ORBIT_servant,
+								     &sr);
+
+	if(sr.sbuf) {
+		int i;
+		for(i = 0; i < sr.params->list->len; i++) {
+			CORBA_NamedValue *cur;
+			
+			cur = &g_array_index(sr.params->list, CORBA_NamedValue, i);
+			
+			if(cur->arg_modes & CORBA_ARG_IN) continue;
+
+			ORBit_marshal_arg(sr.sbuf, cur->argument._value,
+					  cur->argument._type);
+		}
+
+		giop_send_buffer_write(sr.sbuf);
+		giop_send_buffer_unuse(sr.sbuf);
+	} else
+		g_warning("Yo, your DSI code is messed up! You forgot to set_result|set_exception");
+
+	CORBA_NVList_free(sr.params, ev);
+}
+
+static ORBitSkeleton 
+dynamic_impl_get_skel(PortableServer_DynamicImpl * servant,
+		      GIOPRecvBuffer * _ORBIT_recv_buffer,
+		      gpointer * impl)
+{
+	*impl = (gpointer)servant->vepv->PortableServer_DynamicImpl_epv->invoke;
+
+	return (ORBitSkeleton)dynamic_impl_skel;
+}
+
+void
+PortableServer_DynamicImpl__init(PortableServer_Servant servant,
+				 CORBA_Environment *ev)
+{
+	static const PortableServer_ClassInfo class_info =
+	{(ORBitSkeleton (*)(PortableServer_ServantBase *, gpointer, gpointer *))
+	 &dynamic_impl_get_skel, "IDL:CORBA/Object:1.0", NULL};
+	
+	PortableServer_ServantBase__init(servant, ev);
+	
+	ORBIT_OBJECT_KEY(((PortableServer_ServantBase *)servant)->_private)->class_info =
+		(PortableServer_ClassInfo *) & class_info;
+	
+}
+
+void PortableServer_DynamicImpl__fini(PortableServer_Servant servant,
+				      CORBA_Environment *ev)
+{
+	PortableServer_ServantBase__fini(servant, ev);
+}
+
diff -urN linux-2.4.1/net/korbit/orb/poa.h linux-2.4.1-korbit/net/korbit/orb/poa.h
--- linux-2.4.1/net/korbit/orb/poa.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/poa.h	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,337 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_POA_H_
+#define _ORBIT_POA_H_
+
+#include "orbit_types.h"
+
+extern PortableServer_ThreadPolicyValue PortableServer_ThreadPolicy__get_value(
+	PortableServer_ThreadPolicy obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_LifespanPolicyValue PortableServer_LifespanPolicy__get_value(
+	PortableServer_LifespanPolicy obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_IdUniquenessPolicyValue PortableServer_IdUniquenessPolicy__get_value(
+	PortableServer_IdUniquenessPolicy obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_IdAssignmentPolicyValue PortableServer_IdAssignmentPolicy__get_value(
+	PortableServer_IdAssignmentPolicy obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_ImplicitActivationPolicyValue PortableServer_ImplicitActivationPolicy__get_value(
+	PortableServer_ImplicitActivationPolicy obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_ServantRetentionPolicyValue PortableServer_ServantRetentionPolicy__get_value(
+	PortableServer_ServantRetentionPolicy obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_RequestProcessingPolicyValue PortableServer_RequestProcessingPolicy__get_value(
+	PortableServer_RequestProcessingPolicy obj,
+	CORBA_Environment *ev);
+
+PortableServer_POAManager_State
+PortableServer_POAManager_get_state(PortableServer_POAManager obj,
+				    CORBA_Environment *ev);
+
+extern void PortableServer_POAManager_activate(
+	PortableServer_POAManager obj,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POAManager_hold_requests(
+	PortableServer_POAManager obj,
+	CORBA_boolean wait_for_completion,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POAManager_discard_requests(
+	PortableServer_POAManager obj,
+	CORBA_boolean wait_for_completion,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POAManager_deactivate(
+	PortableServer_POAManager obj,
+	CORBA_boolean etherealize_objects,
+	CORBA_boolean wait_for_completion,
+	CORBA_Environment *ev);
+
+extern CORBA_boolean PortableServer_AdapterActivator_unknown_adapter(
+	PortableServer_AdapterActivator obj,
+	PortableServer_POA parent,
+	CORBA_char *name,
+	CORBA_Environment *ev);
+
+extern PortableServer_Servant PortableServer_ServantActivator_incarnate(
+	PortableServer_ServantActivator obj,
+	PortableServer_ObjectId *oid,
+	PortableServer_POA adapter,
+	CORBA_Environment *ev);
+
+extern void PortableServer_ServantActivator_etherealize(
+	PortableServer_ServantActivator obj,
+	PortableServer_ObjectId *oid,
+	PortableServer_POA adapter,
+	PortableServer_Servant serv,
+	CORBA_boolean cleanup_in_progress,
+	CORBA_boolean remaining_activations,
+	CORBA_Environment *ev);
+
+extern PortableServer_POA PortableServer_POA_create_POA(
+	PortableServer_POA obj,
+	CORBA_char *adapter_name,
+	PortableServer_POAManager a_POAManager,
+	CORBA_PolicyList *policies,
+	CORBA_Environment *ev);
+
+extern PortableServer_POA PortableServer_POA_find_POA(
+	PortableServer_POA obj,
+	CORBA_char *adapter_name,
+	CORBA_boolean activate_it,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POA_destroy(
+	PortableServer_POA obj,
+	CORBA_boolean etherealize_objects,
+	CORBA_boolean wait_for_completion,
+	CORBA_Environment *ev);
+
+extern PortableServer_ThreadPolicy PortableServer_POA_create_thread_policy(
+	PortableServer_POA obj,
+	PortableServer_ThreadPolicyValue value,
+	CORBA_Environment *ev);
+
+extern PortableServer_LifespanPolicy PortableServer_POA_create_lifespan_policy(
+	PortableServer_POA obj,
+	PortableServer_LifespanPolicyValue value,
+	CORBA_Environment *ev);
+
+extern PortableServer_IdUniquenessPolicy PortableServer_POA_create_id_uniqueness_policy(
+	PortableServer_POA obj,
+	PortableServer_IdUniquenessPolicyValue value,
+	CORBA_Environment *ev);
+
+extern PortableServer_IdAssignmentPolicy PortableServer_POA_create_id_assignment_policy(
+	PortableServer_POA obj,
+	PortableServer_IdAssignmentPolicyValue value,
+	CORBA_Environment *ev);
+
+extern PortableServer_ImplicitActivationPolicy PortableServer_POA_create_implicit_activation_policy(
+	PortableServer_POA obj,
+	PortableServer_ImplicitActivationPolicyValue value,
+	CORBA_Environment *ev);
+
+extern PortableServer_ServantRetentionPolicy PortableServer_POA_create_servant_retention_policy(
+	PortableServer_POA obj,
+	PortableServer_ServantRetentionPolicyValue value,
+	CORBA_Environment *ev);
+
+extern PortableServer_RequestProcessingPolicy PortableServer_POA_create_request_processing_policy(
+	PortableServer_POA obj,
+	PortableServer_RequestProcessingPolicyValue value,
+	CORBA_Environment *ev);
+
+extern CORBA_char *PortableServer_POA__get_the_name(
+	PortableServer_POA obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_POA PortableServer_POA__get_the_parent(
+	PortableServer_POA obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_POAManager PortableServer_POA__get_the_POAManager(
+	PortableServer_POA obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_AdapterActivator PortableServer_POA__get_the_activator(
+	PortableServer_POA obj,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POA__set_the_activator(
+	PortableServer_POA obj,
+	PortableServer_AdapterActivator the_activator,
+	CORBA_Environment *ev);
+
+extern PortableServer_ServantManager PortableServer_POA_get_servant_manager(
+	PortableServer_POA obj,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POA_set_servant_manager(
+	PortableServer_POA obj,
+	PortableServer_ServantManager imgr,
+	CORBA_Environment *ev);
+
+extern PortableServer_Servant PortableServer_POA_get_servant(
+	PortableServer_POA obj,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POA_set_servant(
+	PortableServer_POA obj,
+	PortableServer_Servant p_servant,
+	CORBA_Environment *ev);
+
+extern PortableServer_ObjectId *PortableServer_POA_activate_object(
+	PortableServer_POA obj,
+	PortableServer_Servant p_servant,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POA_activate_object_with_id(
+	PortableServer_POA obj,
+	PortableServer_ObjectId *id,
+	PortableServer_Servant p_servant,
+	CORBA_Environment *ev);
+
+extern void PortableServer_POA_deactivate_object(
+	PortableServer_POA obj,
+	PortableServer_ObjectId *oid,
+	CORBA_Environment *ev);
+
+extern CORBA_Object PortableServer_POA_create_reference(
+	PortableServer_POA obj,
+	CORBA_RepositoryId intf,
+	CORBA_Environment *ev);
+
+extern CORBA_Object PortableServer_POA_create_reference_with_id(
+	PortableServer_POA obj,
+	PortableServer_ObjectId *oid,
+	CORBA_RepositoryId intf,
+	CORBA_Environment *ev);
+
+extern PortableServer_ObjectId *PortableServer_POA_servant_to_id(
+	PortableServer_POA obj,
+	PortableServer_Servant p_servant,
+	CORBA_Environment *ev);
+
+extern CORBA_Object PortableServer_POA_servant_to_reference(
+	PortableServer_POA obj,
+	PortableServer_Servant p_servant,
+	CORBA_Environment *ev);
+
+extern PortableServer_Servant PortableServer_POA_reference_to_servant(
+	PortableServer_POA obj,
+	CORBA_Object reference,
+	CORBA_Environment *ev);
+
+extern PortableServer_ObjectId *PortableServer_POA_reference_to_id(
+	PortableServer_POA obj,
+	CORBA_Object reference,
+	CORBA_Environment *ev);
+
+extern PortableServer_Servant PortableServer_POA_id_to_servant(
+	PortableServer_POA obj,
+	PortableServer_ObjectId *oid,
+	CORBA_Environment *ev);
+
+extern CORBA_Object PortableServer_POA_id_to_reference(
+	PortableServer_POA obj,
+	PortableServer_ObjectId *oid,
+	CORBA_Environment *ev);
+
+extern PortableServer_POA PortableServer_Current_get_POA(
+	PortableServer_Current obj,
+	CORBA_Environment *ev);
+
+extern PortableServer_ObjectId *PortableServer_Current_get_object_id(
+	PortableServer_Current obj,
+	CORBA_Environment *ev);
+
+extern CORBA_char *PortableServer_ObjectId_to_string(
+	PortableServer_ObjectId *id,
+	CORBA_Environment *env);
+
+extern CORBA_wchar *PortableServer_ObjectId_to_wstring(
+	PortableServer_ObjectId *id,
+	CORBA_Environment *env);
+
+extern PortableServer_ObjectId *PortableServer_string_to_ObjectId(
+	CORBA_char *str,
+	CORBA_Environment *env);
+
+extern PortableServer_ObjectId *PortableServer_wstring_to_ObjectId(
+	CORBA_wchar *str,
+	CORBA_Environment *env);
+
+extern PortableServer_POA PortableServer_ServantBase__default_POA(
+	PortableServer_Servant,
+	CORBA_Environment *);
+
+extern void PortableServer_ServantLocator_preinvoke(
+	PortableServer_ObjectId *oid,
+	PortableServer_POA adapter,
+	CORBA_Identifier op_name,
+	PortableServer_ServantLocator_Cookie *cookie);
+
+extern void PortableServer_ServantLocator_postinvoke(
+	PortableServer_ObjectId *oid,
+	PortableServer_POA adapter,
+	CORBA_Identifier op_name,
+	PortableServer_ServantLocator_Cookie cookie,
+	PortableServer_Servant servant);
+
+extern void PortableServer_ServantBase__init(
+	PortableServer_Servant,
+	CORBA_Environment *);
+
+extern void PortableServer_ServantBase__fini(
+	PortableServer_Servant,
+	CORBA_Environment *);
+
+/* 19.27 */
+extern CORBA_Identifier CORBA_ServerRequest_operation(
+	CORBA_ServerRequest req,
+	CORBA_Environment *env);
+
+extern CORBA_Context CORBA_ServerRequest_ctx(
+	CORBA_ServerRequest req,
+	CORBA_Environment *env);
+
+extern void CORBA_ServerRequest_arguments(
+	CORBA_ServerRequest req,
+	CORBA_NVList *parameters,
+	CORBA_Environment *env);
+
+extern void CORBA_ServerRequest_set_result(
+	CORBA_ServerRequest req,
+	CORBA_any *value,
+	CORBA_Environment *env);
+
+extern void CORBA_ServerRequest_set_exception(
+	CORBA_ServerRequest req,
+	CORBA_exception_type major,
+	CORBA_any *value,
+	CORBA_Environment *env);
+
+extern void PortableServer_DynamicImpl__init(PortableServer_Servant,
+					     CORBA_Environment *ev);
+
+extern void PortableServer_DynamicImpl__fini(PortableServer_Servant,
+					     CORBA_Environment *ev);
+
+
+#include "orbit_poa_type.h"
+
+#endif /* !_ORBIT_POA_H_ */
diff -urN linux-2.4.1/net/korbit/orb/sequences.c linux-2.4.1-korbit/net/korbit/orb/sequences.c
--- linux-2.4.1/net/korbit/orb/sequences.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/sequences.c	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,35 @@
+#include "orbit.h"
+#include "sequences.h"
+
+gpointer CORBA_sequence_octet_free(gpointer mem,
+				   gpointer func_data)
+{
+  CORBA_sequence_octet *seqo = mem;
+
+  if(seqo->_release)
+    CORBA_free(seqo->_buffer);
+
+  return (gpointer)((guchar *)mem + sizeof(CORBA_sequence_octet));
+}
+
+CORBA_octet *
+CORBA_octet_allocbuf(CORBA_unsigned_long len)
+{
+  return (CORBA_octet *)ORBit_alloc(len, NULL, NULL);
+}
+
+CORBA_sequence_octet *CORBA_sequence_octet__alloc(void)
+{
+  CORBA_sequence_octet *seqo;
+
+  seqo = ORBit_alloc(sizeof(CORBA_sequence_octet),
+		     (ORBit_free_childvals)CORBA_sequence_octet_free,
+		     GUINT_TO_POINTER(1));
+
+  seqo->_length = seqo->_maximum = 0;
+  seqo->_buffer = NULL;
+  seqo->_release = CORBA_TRUE;
+
+  return seqo;
+}
+
diff -urN linux-2.4.1/net/korbit/orb/sequences.h linux-2.4.1-korbit/net/korbit/orb/sequences.h
--- linux-2.4.1/net/korbit/orb/sequences.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/sequences.h	Thu Feb  1 16:21:19 2001
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_SEQUENCES_H_
+#define _ORBIT_SEQUENCES_H_
+
+/* #include "corba_sequences_type.h" */
+#include "orbit_types.h"
+
+CORBA_octet *CORBA_octet_allocbuf(CORBA_unsigned_long len);
+CORBA_sequence_octet *CORBA_sequence_octet__alloc(void);
+
+#endif /* !_ORBIT_SEQUENCES_H_ */
diff -urN linux-2.4.1/net/korbit/orb/server.c linux-2.4.1-korbit/net/korbit/orb/server.c
--- linux-2.4.1/net/korbit/orb/server.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/server.c	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,217 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* Elliot's stuff */
+/* This is somewhat a mess, because I tried to make it easy to add
+   select() support, and as a result #ifdef's litter the land. */
+
+#include "orbit.h"
+#include "orbit_poa.h"
+#include "orbit_poa_type.h"
+#include <IIOP/IIOP-private.h>
+#ifdef HAVE_SYS_POLL_H
+#include <sys/poll.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+
+/* We need:
+   a way to find out what FD's need to be selected on
+   a dummy main loop to implement the CORBA_ORB_run() routine;
+*/
+
+gboolean orb_server_keep_running = FALSE;
+
+ORBit_request_validate ORBIT_request_validator = NULL;
+
+/* function protos */
+static PortableServer_POA ORBit_find_POA_for_request(PortableServer_POA poa,
+						     GIOPRecvBuffer *recv_buffer);
+static PortableServer_POA ORBit_find_POA_for_locate_request(PortableServer_POA poa,
+						     GIOPRecvBuffer *recv_buffer);
+
+static void ORBit_handle_incoming_message(GIOPRecvBuffer *recv_buffer);
+
+void
+ORBit_custom_run_setup(CORBA_ORB orb, CORBA_Environment *ev)
+{
+	IIOPIncomingMessageHandler = ORBit_handle_incoming_message;
+}
+
+
+#if __KERNEL__
+// Modules don't do anything when they call this...
+void CORBA_ORB_run(CORBA_ORB orb, CORBA_Environment *ev) {
+	// This should probably free the ORB pointer, because it is a 
+	// duplicated pointer from the one true orb.
+
+}
+
+// The ORB thread calls __CORBA_ORB_run by itself.
+#define CORBA_ORB_run __CORBA_ORB_run
+
+#endif
+
+void
+CORBA_ORB_run(CORBA_ORB orb, CORBA_Environment *ev)
+{
+	ORBit_custom_run_setup(orb, ev);
+
+	orb_server_keep_running = TRUE;
+
+	giop_main();
+}
+
+static void
+ORBit_handle_incoming_request(GIOPRecvBuffer *recv_buffer)
+{
+	CORBA_ORB orb;
+	PortableServer_POA poa;
+	GIOPConnection *connection;
+	ORBit_MessageValidationResult mvr;
+	gboolean do_unuse = TRUE;
+
+	g_assert(recv_buffer);
+
+	connection = GIOP_MESSAGE_BUFFER(recv_buffer)->connection;
+	g_return_if_fail(connection != NULL);
+
+	orb = connection->orb_data;
+
+	g_return_if_fail(orb != NULL);
+
+	ORBit_Trace(TraceMod_ORB, TraceLevel_Debug,
+		    "Received request %s, id %d, on %s",
+		    recv_buffer->message.u.request.operation,
+		    recv_buffer->message.u.request.request_id,
+		    recv_buffer->message.u.request.object_key._buffer);
+
+	if(ORBIT_request_validator)
+		mvr = ORBIT_request_validator(recv_buffer->message.u.request.request_id,
+					      &recv_buffer->message.u.request.requesting_principal,
+					      recv_buffer->message.u.request.operation);
+	else
+		mvr = ORBIT_MESSAGE_ALLOW;
+
+	if(mvr == ORBIT_MESSAGE_ALLOW_ALL)
+		connection->is_auth = TRUE;
+
+	if(mvr != ORBIT_MESSAGE_BAD) {
+		/* Find the POA for this incoming request */
+		poa = ORBit_find_POA_for_request((PortableServer_POA)orb->root_poa,
+						 recv_buffer);
+			
+		if(poa)
+			do_unuse = ORBit_POA_handle_request(recv_buffer, poa);
+		else
+			g_warning("No POA found for operation %s [%d]",
+				  recv_buffer->message.u.request.operation,
+				  recv_buffer->message.u.request.request_id);
+	} else {
+		g_warning("Request %s, ID %d was rejected by the authentication mechanism!",
+			  recv_buffer->message.u.request.operation,
+			  recv_buffer->message.u.request.request_id);
+	}
+
+	if(do_unuse)
+		giop_recv_buffer_unuse(recv_buffer);
+}
+
+static void
+ORBit_handle_incoming_locate_request(GIOPRecvBuffer *recv_buffer)
+{
+	CORBA_ORB orb;
+	PortableServer_POA poa;
+	GIOPConnection *connection;
+	GIOPSendBuffer *send_buffer;
+
+	g_assert(recv_buffer!=NULL);
+
+	connection = GIOP_MESSAGE_BUFFER(recv_buffer)->connection;
+	g_return_if_fail(connection != NULL);
+
+	orb = connection->orb_data;
+
+	g_return_if_fail(orb != NULL);
+
+	ORBit_Trace(TraceMod_ORB, TraceLevel_Debug,
+		    "Received locate request id %d, on %s",
+		    recv_buffer->message.u.locate_request.request_id,
+		    recv_buffer->message.u.locate_request.object_key._buffer);
+	/* Find the POA for this incoming request */
+	poa = ORBit_find_POA_for_locate_request((PortableServer_POA)orb->root_poa, recv_buffer);
+		
+	if(poa) {
+		/* Object found, reply with "Object Here" */
+		send_buffer = giop_send_locate_reply_buffer_use(connection,
+			 recv_buffer->message.u.locate_request.request_id,
+			 GIOP_OBJECT_HERE);
+		giop_send_buffer_write(send_buffer);
+		giop_send_buffer_unuse(send_buffer);
+	} else {
+		/* Object not found, reply with "Unknown Object" */
+		send_buffer = giop_send_locate_reply_buffer_use(connection,
+			 recv_buffer->message.u.locate_request.request_id,
+			 GIOP_UNKNOWN_OBJECT);
+		giop_send_buffer_write(send_buffer);
+		giop_send_buffer_unuse(send_buffer);
+	}
+
+	giop_recv_buffer_unuse(recv_buffer);
+}
+
+static void
+ORBit_handle_incoming_message(GIOPRecvBuffer *recv_buffer)
+{
+	GIOPConnection *connection;
+
+	g_assert(recv_buffer);
+
+	connection = GIOP_MESSAGE_BUFFER(recv_buffer)->connection;
+	g_return_if_fail(connection != NULL);
+
+	switch(GIOP_MESSAGE_BUFFER(recv_buffer)->message_header.message_type) {
+	case GIOP_REQUEST:
+		ORBit_handle_incoming_request(recv_buffer);
+		break;
+	case GIOP_LOCATEREQUEST:
+		ORBit_handle_incoming_locate_request(recv_buffer);
+		break;
+	case GIOP_CLOSECONNECTION:
+		/* Lame hack - need to do this in a manner that isn't
+                   IIOP-specific */
+		giop_recv_buffer_unuse(recv_buffer);
+		giop_main_handle_connection_exception(connection);
+		break;
+	case GIOP_REPLY:
+		/* the above comment probably applies here also... */
+		giop_received_list_push(recv_buffer);
+		break;
+	default:
+		g_warning("discarding message type %d (id possibly %d)",
+			  GIOP_MESSAGE_BUFFER(recv_buffer)->message_header.message_type,
+			  GIOP_MESSAGE_BUFFER(recv_buffer)->message_header.message_type?recv_buffer->message.u.reply.request_id:recv_buffer->message.u.request.request_id);
+		break;
+	}
+}
+
+static PortableServer_POA
+ORBit_find_POA_for_request(PortableServer_POA poa,
+			   GIOPRecvBuffer *recv_buffer)
+{
+	return ORBit_POA_find_POA_for_object_key(poa,
+						 &recv_buffer->message.u.request.object_key);
+}
+
+static PortableServer_POA
+ORBit_find_POA_for_locate_request(PortableServer_POA poa,
+			   GIOPRecvBuffer *recv_buffer)
+{
+	return ORBit_POA_find_POA_for_object_key(poa,
+						 &recv_buffer->message.u.locate_request.object_key);
+}
+
+void
+ORBit_set_request_validation_handler(ORBit_request_validate validator)
+{
+	ORBIT_request_validator = validator;
+}
diff -urN linux-2.4.1/net/korbit/orb/typecode.c linux-2.4.1-korbit/net/korbit/orb/typecode.c
--- linux-2.4.1/net/korbit/orb/typecode.c	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/typecode.c	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,104 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter, Red Hat Software
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *          Elliot Lee <sopwith@cuc.edu>
+ *
+ */
+
+#include "orbit.h"
+#include "orbit_typecode.h"
+ 
+const struct CORBA_TypeCode_struct TC_null_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_null, "null", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_void_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_void, "void", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_short_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_short, "short", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_long_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_long, "long", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_longlong_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_longlong, "long long", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_ushort_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_ushort, "unsigned short", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_ulong_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_ulong, "unsigned long", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_ulonglong_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_ulonglong, "unsigned long long", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_float_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_float, "float", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_double_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_double, "double", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_longdouble_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_longdouble, "long double", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_boolean_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_boolean, "boolean", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_char_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_char, "char", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_wchar_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_wchar, "wide char", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_octet_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_octet, "octet", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_any_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_any, "any", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_TypeCode_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_TypeCode, "TypeCode", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_Principal_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_Principal, "Principal", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_Object_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_objref, "Object Reference", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_string_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_string, "string", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_wstring_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_wstring, "wide string", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+const struct CORBA_TypeCode_struct TC_CORBA_NamedValue_struct=
+	{{{(ORBit_RootObject_Interface *)&ORBit_TypeCode_epv, CORBA_FALSE, -1}, ORBIT_PSEUDO_TYPECODE}, CORBA_tk_struct, "CORBA NamedValue", "", 0, 0, NULL, NULL, NULL, NULL, -1, 0, 0, 0};
+
+static const CORBA_TypeCode anon_subtypes_array7[] =
+{(CORBA_TypeCode) & TC_CORBA_string_struct};
+
+#if (TC_IMPL_TC_CORBA_Identifier_0 == '/')
+const struct CORBA_TypeCode_struct TC_CORBA_Identifier_struct =
+{
+   {
+      {(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1}, ORBIT_PSEUDO_TYPECODE},
+   CORBA_tk_alias, "Identifier", "IDL:omg.org/CORBA/Identifier:1.0",
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array7,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
+
+#if (TC_IMPL_TC_CORBA_RepositoryId_0 == '/')
+const struct CORBA_TypeCode_struct TC_CORBA_RepositoryId_struct =
+{
+   {
+      {(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1}, ORBIT_PSEUDO_TYPECODE},
+   CORBA_tk_alias, "RepositoryId", "IDL:omg.org/CORBA/RepositoryId:1.0",
+   0, 1,
+   NULL,
+   (CORBA_TypeCode *) anon_subtypes_array7,
+   NULL,
+   CORBA_OBJECT_NIL, 0, -1, 0, 0
+};
+#endif
diff -urN linux-2.4.1/net/korbit/orb/typecode.h linux-2.4.1-korbit/net/korbit/orb/typecode.h
--- linux-2.4.1/net/korbit/orb/typecode.h	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/orb/typecode.h	Thu Feb  1 11:47:14 2001
@@ -0,0 +1,31 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/*
+ *  ORBit: A CORBA v2.2 ORB
+ *
+ *  Copyright (C) 1998 Richard H. Porter
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Author: Dick Porter <dick@cymru.net>
+ *
+ */
+
+#ifndef _ORBIT_TYPECODE_H_
+#define _ORBIT_TYPECODE_H_
+
+#include "orbit_types.h"
+
+#endif /* !_ORBIT_TYPECODE_H_ */
diff -urN linux-2.4.1/net/korbit/sup/CVS/Entries linux-2.4.1-korbit/net/korbit/sup/CVS/Entries
--- linux-2.4.1/net/korbit/sup/CVS/Entries	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/sup/CVS/Entries	Thu Feb  1 11:47:15 2001
@@ -0,0 +1 @@
+D
diff -urN linux-2.4.1/net/korbit/sup/CVS/Repository linux-2.4.1-korbit/net/korbit/sup/CVS/Repository
--- linux-2.4.1/net/korbit/sup/CVS/Repository	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/sup/CVS/Repository	Thu Feb  1 11:47:15 2001
@@ -0,0 +1 @@
+/cvsroot/korbit/linux/net/korbit/sup
diff -urN linux-2.4.1/net/korbit/sup/CVS/Root linux-2.4.1-korbit/net/korbit/sup/CVS/Root
--- linux-2.4.1/net/korbit/sup/CVS/Root	Thu Jan  1 03:00:00 1970
+++ linux-2.4.1-korbit/net/korbit/sup/CVS/Root	Thu Feb  1 11:47:15 2001
@@ -0,0 +1 @@
+vraalsen@cvs.korbit.sourceforge.net:/cvsroot/korbit
