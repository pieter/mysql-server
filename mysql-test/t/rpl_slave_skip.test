source include/master-slave.inc;

--echo **** On Slave ****
connection slave;
STOP SLAVE;

--echo **** On Master ****
connection master;
SET SESSION BINLOG_FORMAT=ROW;

CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (c INT, d INT);
INSERT INTO t1 VALUES (1,1),(2,4),(3,9);
INSERT INTO t2 VALUES (1,1),(2,8),(3,27);
UPDATE t1,t2 SET b = d, d = b * 2 WHERE a = c;
source include/show_binlog_events.inc;

# These tables should be changed
SELECT * FROM t1;
SELECT * FROM t2;
save_master_pos;

--echo **** On Slave ****
connection slave;

# Stop when reaching the the first table map event.
START SLAVE UNTIL MASTER_LOG_FILE='master-bin.000001', MASTER_LOG_POS=484;
wait_for_slave_to_stop;
--replace_result $MASTER_MYPORT MASTER_PORT
--replace_column 1 # 8 # 9 # 23 # 33 #
query_vertical SHOW SLAVE STATUS;

# Now we skip *one* table map event. If the execution starts right
# after that table map event, *one* of the involved tables will be
# changed.
SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;
START SLAVE;
sync_with_master;

# These values should be what was inserted, not what was
# updated. Since we are skipping the first table map of the group
# representing the UPDATE statement above, we should skip the entire
# group and not start executing at the first table map.
SELECT * FROM t1;
SELECT * FROM t2;

STOP SLAVE;
RESET SLAVE;
connection master;
RESET MASTER;

SET SESSION BINLOG_FORMAT=STATEMENT;
SET @foo = 12;
INSERT INTO t1 VALUES(@foo, 2*@foo);
save_master_pos;
source include/show_binlog_events.inc;

connection slave;
START SLAVE UNTIL MASTER_LOG_FILE='master-bin.000001', MASTER_LOG_POS=106;
wait_for_slave_to_stop;
SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;
START SLAVE;
sync_with_master;
--replace_result $MASTER_MYPORT MASTER_PORT
--replace_column 1 # 8 # 9 # 23 # 33 #
query_vertical SHOW SLAVE STATUS;

--echo **** On Master ****
connection master;
DROP TABLE t1, t2;
sync_slave_with_master;
