***************
*** 286,293 ****
  #undef HAVE_PTHREAD_RWLOCK_RDLOCK
  #undef HAVE_SNPRINTF
  
! #define sigset(A,B) pthread_signal((A),(void (*)(int)) (B))
! #define signal(A,B) pthread_signal((A),(void (*)(int)) (B))
  #define my_pthread_attr_setprio(A,B)
  #endif /* defined(PTHREAD_SCOPE_GLOBAL) && !defined(PTHREAD_SCOPE_SYSTEM) */
  
--- 294,301 ----
  #undef HAVE_PTHREAD_RWLOCK_RDLOCK
  #undef HAVE_SNPRINTF
  
! #define my_sigset(A,B) pthread_signal((A),(void (*)(int)) (B))
! #define my_signal(A,B) pthread_signal((A),(void (*)(int)) (B))
  #define my_pthread_attr_setprio(A,B)
  #endif /* defined(PTHREAD_SCOPE_GLOBAL) && !defined(PTHREAD_SCOPE_SYSTEM) */
  
***************
*** 324,337 ****
  #if !defined(HAVE_SIGWAIT) && !defined(HAVE_mit_thread) && !defined(HAVE_rts_threads) && !defined(sigwait) && !defined(alpha_linux_port) && !defined(HAVE_NONPOSIX_SIGWAIT) && !defined(HAVE_DEC_3_2_THREADS) && !defined(_AIX)
  int sigwait(sigset_t *setp, int *sigp);		/* Use our implemention */
  #endif
! #if !defined(HAVE_SIGSET) && !defined(HAVE_mit_thread) && !defined(sigset)
! #define sigset(A,B) do { struct sigaction s; sigset_t set;              \
!                          sigemptyset(&set);                             \
!                          s.sa_handler = (B);                            \
!                          s.sa_mask    = set;                            \
!                          s.sa_flags   = 0;                              \
!                          sigaction((A), &s, (struct sigaction *) NULL); \
                         } while (0)
  #endif
  
  #ifndef my_pthread_setprio
--- 332,358 ----
  #if !defined(HAVE_SIGWAIT) && !defined(HAVE_mit_thread) && !defined(HAVE_rts_threads) && !defined(sigwait) && !defined(alpha_linux_port) && !defined(HAVE_NONPOSIX_SIGWAIT) && !defined(HAVE_DEC_3_2_THREADS) && !defined(_AIX)
  int sigwait(sigset_t *setp, int *sigp);		/* Use our implemention */
  #endif
! 
! /*
!   We define my_sigset() and use that instead of the system sigset() so that
!   we can favor an implementation based on sigaction(). On some systems, such
!   as Mac OS X, sigset() results in flags such as SA_RESTART being set, and
!   we want to make sure that no such flags are set.
! */
! #if defined(HAVE_SIGACTION) && !defined(my_sigset)
! #define my_sigset(A,B) do { struct sigaction s; sigset_t set; int rc;      \
!                             DBUG_ASSERT((A) != 0);                         \
!                             sigemptyset(&set);                             \
!                             s.sa_handler = (B);                            \
!                             s.sa_mask    = set;                            \
!                             s.sa_flags   = 0;                              \
!                             rc= sigaction((A), &s, (struct sigaction *) NULL); \
!                             DBUG_ASSERT(rc == 0);                          \
                         } while (0)
+ #elif defined(HAVE_SIGSET) && !defined(my_sigset)
+ #define my_sigset(A,B) sigset((A),(B))
+ #elif !defined(my_sigset)
+ #define my_sigset(A,B) signal((A),(B))
  #endif
  
  #ifndef my_pthread_setprio
***************
*** 416,422 ****
  #undef	pthread_detach_this_thread
  #define pthread_detach_this_thread() { pthread_t tmp=pthread_self() ; pthread_detach(tmp); }
  #undef sigset
! #define sigset(A,B) pthread_signal((A),(void (*)(int)) (B))
  #endif
  
  #if ((defined(HAVE_PTHREAD_ATTR_CREATE) && !defined(HAVE_SIGWAIT)) || defined(HAVE_DEC_3_2_THREADS)) && !defined(HAVE_CTHREADS_WRAPPER)
--- 437,443 ----
  #undef	pthread_detach_this_thread
  #define pthread_detach_this_thread() { pthread_t tmp=pthread_self() ; pthread_detach(tmp); }
  #undef sigset
! #define my_sigset(A,B) pthread_signal((A),(void (*)(int)) (B))
  #endif
  
  #if ((defined(HAVE_PTHREAD_ATTR_CREATE) && !defined(HAVE_SIGWAIT)) || defined(HAVE_DEC_3_2_THREADS)) && !defined(HAVE_CTHREADS_WRAPPER)
