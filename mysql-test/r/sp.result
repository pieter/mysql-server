use test;
drop table if exists t1;
create table t1 (
id   char(16) not null default '',
data int not null
);
drop table if exists t2;
create table t2 (
s   char(16),
i   int,
d   double
);
drop procedure if exists foo42;
create procedure foo42()
insert into test.t1 values ("foo", 42);
call foo42();
select * from t1;
id	data
foo	42
delete from t1;
drop procedure foo42;
drop procedure if exists bar;
create procedure bar(x char(16), y int)
insert into test.t1 values (x, y);
call bar("bar", 666);
select * from t1;
id	data
bar	666
delete from t1;
drop procedure if exists empty|
create procedure empty()
begin
end|
call empty()|
drop procedure empty|
drop procedure if exists scope|
create procedure scope(a int, b float)
begin
declare b int;
declare c float;
begin
declare c int;
end;
end|
drop procedure scope|
drop procedure if exists two|
create procedure two(x1 char(16), x2 char(16), y int)
begin
insert into test.t1 values (x1, y);
insert into test.t1 values (x2, y);
end|
call two("one", "two", 3)|
select * from t1|
id	data
one	3
two	3
delete from t1|
drop procedure two|
drop procedure if exists locset|
create procedure locset(x char(16), y int)
begin
declare z1, z2 int;
set z1 = y;
set z2 = z1+2;
insert into test.t1 values (x, z2);
end|
call locset("locset", 19)|
select * from t1|
id	data
locset	21
delete from t1|
drop procedure locset|
drop procedure if exists setcontext|
create procedure setcontext()
begin
declare data int default 2;
insert into t1 (id, data) values ("foo", 1);
replace t1 set data = data, id = "bar";
update t1 set id = "kaka", data = 3 where t1.data = data;
end|
call setcontext()|
select * from t1|
id	data
foo	1
kaka	3
delete from t1|
drop procedure setcontext|
drop table if exists t3|
create table t3 ( d date, i int, f double, s varchar(32) )|
drop procedure if exists nullset|
create procedure nullset()
begin
declare ld date;
declare li int;
declare lf double;
declare ls varchar(32);
set ld = null, li = null, lf = null, ls = null;
insert into t3 values (ld, li, lf, ls);
insert into t3 (i, f, s) values ((ld is null), 1,    "ld is null"),
((li is null), 1,    "li is null"),
((li = 0),     null, "li = 0"),
((lf is null), 1,    "lf is null"),
((lf = 0),     null, "lf = 0"),
((ls is null), 1,    "ls is null");
end|
call nullset()|
select * from t3|
d	i	f	s
NULL	NULL	NULL	NULL
NULL	1	1	ld is null
NULL	1	1	li is null
NULL	NULL	NULL	li = 0
NULL	1	1	lf is null
NULL	NULL	NULL	lf = 0
NULL	1	1	ls is null
drop table t3|
drop procedure nullset|
drop procedure if exists mixset|
create procedure mixset(x char(16), y int)
begin
declare z int;
set @z = y, z = 666, max_join_size = 100;
insert into test.t1 values (x, z);
end|
call mixset("mixset", 19)|
show variables like 'max_join_size'|
Variable_name	Value
max_join_size	100
select id,data,@z from t1|
id	data	@z
mixset	666	19
delete from t1|
drop procedure mixset|
drop procedure if exists zip|
create procedure zip(x char(16), y int)
begin
declare z int;
call zap(y, z);
call bar(x, z);
end|
drop procedure if exists zap|
create procedure zap(x int, out y int)
begin
declare z int;
set z = x+1, y = z;
end|
call zip("zip", 99)|
select * from t1|
id	data
zip	100
delete from t1|
drop procedure zip|
drop procedure bar|
call zap(7, @zap)|
select @zap|
@zap
8
drop procedure zap|
drop procedure if exists c1|
create procedure c1(x int)
call c2("c", x)|
drop procedure if exists c2|
create procedure c2(s char(16), x int)
call c3(x, s)|
drop procedure if exists c3|
create procedure c3(x int, s char(16))
call c4("level", x, s)|
drop procedure if exists c4|
create procedure c4(l char(8), x int, s char(16))
insert into t1 values (concat(l,s), x)|
call c1(42)|
select * from t1|
id	data
levelc	42
delete from t1|
drop procedure c1|
drop procedure c2|
drop procedure c3|
drop procedure c4|
drop procedure if exists iotest|
create procedure iotest(x1 char(16), x2 char(16), y int)
begin
call inc2(x2, y);
insert into test.t1 values (x1, y);
end|
drop procedure if exists inc2|
create procedure inc2(x char(16), y int)
begin
call inc(y);
insert into test.t1 values (x, y);
end|
drop procedure if exists inc|
create procedure inc(inout io int)
set io = io + 1|
call iotest("io1", "io2", 1)|
select * from t1|
id	data
io2	2
io1	1
delete from t1|
drop procedure iotest|
drop procedure inc2|
drop procedure if exists incr|
create procedure incr(inout x int)
call inc(x)|
select @zap|
@zap
8
call incr(@zap)|
select @zap|
@zap
9
drop procedure inc|
drop procedure incr|
drop procedure if exists cbv1|
create procedure cbv1()
begin
declare y int default 3;
call cbv2(y+1, y);
insert into test.t1 values ("cbv1", y);
end|
drop procedure if exists cbv2|
create procedure cbv2(y1 int, inout y2 int)
begin
set y2 = 4711;
insert into test.t1 values ("cbv2", y1);
end|
call cbv1()|
select * from t1|
id	data
cbv2	4
cbv1	4711
delete from t1|
drop procedure cbv1|
drop procedure cbv2|
insert into t2 values ("a", 1, 1.1), ("b", 2, 1.2), ("c", 3, 1.3)|
drop procedure if exists sub1|
create procedure sub1(id char(16), x int)
insert into test.t1 values (id, x)|
drop procedure if exists sub2|
create procedure sub2(id char(16))
begin
declare x int;
set x = (select sum(t.i) from test.t2 t);
insert into test.t1 values (id, x);
end|
drop procedure if exists sub3|
create function sub3(i int) returns int
return i+1|
call sub1("sub1a", (select 7))|
call sub1("sub1b", (select max(i) from t2))|
call sub1("sub1c", (select i,d from t2 limit 1))|
call sub1("sub1d", (select 1 from (select 1) a))|
call sub2("sub2")|
select * from t1|
id	data
sub1a	7
sub1b	3
sub1c	1
sub1d	1
sub2	6
select sub3((select max(i) from t2))|
sub3((select max(i) from t2))
4
drop procedure sub1|
drop procedure sub2|
drop function sub3|
delete from t1|
delete from t2|
drop procedure if exists a0|
create procedure a0(x int)
while x do
set x = x-1;
insert into test.t1 values ("a0", x);
end while|
call a0(3)|
select * from t1|
id	data
a0	2
a0	1
a0	0
delete from t1|
drop procedure a0|
drop procedure if exists a|
create procedure a(x int)
while x > 0 do
set x = x-1;
insert into test.t1 values ("a", x);
end while|
call a(3)|
select * from t1|
id	data
a	2
a	1
a	0
delete from t1|
drop procedure a|
drop procedure if exists b|
create procedure b(x int)
repeat
insert into test.t1 values (repeat("b",3), x);
set x = x-1;
until x = 0 end repeat|
call b(3)|
select * from t1|
id	data
bbb	3
bbb	2
bbb	1
delete from t1|
drop procedure b|
drop procedure if exists b2|
create procedure b2(x int)
repeat(select 1 into outfile 'b2');
insert into test.t1 values (repeat("b2",3), x);
set x = x-1;
until x = 0 end repeat|
drop procedure b2|
drop procedure if exists c|
create procedure c(x int)
hmm: while x > 0 do
insert into test.t1 values ("c", x);
set x = x-1;
iterate hmm;
insert into test.t1 values ("x", x);
end while hmm|
call c(3)|
select * from t1|
id	data
c	3
c	2
c	1
delete from t1|
drop procedure c|
drop procedure if exists d|
create procedure d(x int)
hmm: while x > 0 do
insert into test.t1 values ("d", x);
set x = x-1;
leave hmm;
insert into test.t1 values ("x", x);
end while|
call d(3)|
select * from t1|
id	data
d	3
delete from t1|
drop procedure d|
drop procedure if exists e|
create procedure e(x int)
foo: loop
if x = 0 then
leave foo;
end if;
insert into test.t1 values ("e", x);
set x = x-1;
end loop foo|
call e(3)|
select * from t1|
id	data
e	3
e	2
e	1
delete from t1|
drop procedure e|
drop procedure if exists f|
create procedure f(x int)
if x < 0 then
insert into test.t1 values ("f", 0);
elseif x = 0 then
insert into test.t1 values ("f", 1);
else
insert into test.t1 values ("f", 2);
end if|
call f(-2)|
call f(0)|
call f(4)|
select * from t1|
id	data
f	0
f	1
f	2
delete from t1|
drop procedure f|
drop procedure if exists g|
create procedure g(x int)
case
when x < 0 then
insert into test.t1 values ("g", 0);
when x = 0 then
insert into test.t1 values ("g", 1);
else
insert into test.t1 values ("g", 2);
end case|
call g(-42)|
call g(0)|
call g(1)|
select * from t1|
id	data
g	0
g	1
g	2
delete from t1|
drop procedure g|
drop procedure if exists h|
create procedure h(x int)
case x
when 0 then
insert into test.t1 values ("h0", x);
when 1 then
insert into test.t1 values ("h1", x);
else
insert into test.t1 values ("h?", x);
end case|
call h(0)|
call h(1)|
call h(17)|
select * from t1|
id	data
h0	0
h1	1
h?	17
delete from t1|
drop procedure h|
drop procedure if exists i|
create procedure i(x int)
foo:
begin
if x = 0 then
leave foo;
end if;
insert into test.t1 values ("i", x);
end foo|
call i(0)|
call i(3)|
select * from t1|
id	data
i	3
delete from t1|
drop procedure i|
drop procedure if exists goto1|
create procedure goto1()
begin
declare y int;
label a;
select * from t1;
select count(*) into y from t1;
if y > 2 then
goto b;
end if;
insert into t1 values ("j", y);
goto a;
label b;
end|
call goto1()|
id	data
id	data
j	0
id	data
j	0
j	1
id	data
j	0
j	1
j	2
drop procedure goto1|
drop procedure if exists goto2|
create procedure goto2(a int)
begin
declare x int default 0;
declare continue handler for sqlstate '42S98' set x = 1;
label a;
select * from t1;
b:
while x < 2 do
begin
declare continue handler for sqlstate '42S99' set x = 2;
if a = 0 then
set x = x + 1;
iterate b;
elseif a = 1 then
leave b;
elseif a = 2 then
set a = 1;
goto a;
end if;
end;
end while b;
select * from t1;
end|
call goto2(0)|
id	data
j	0
j	1
j	2
id	data
j	0
j	1
j	2
call goto2(1)|
id	data
j	0
j	1
j	2
id	data
j	0
j	1
j	2
call goto2(2)|
id	data
j	0
j	1
j	2
id	data
j	0
j	1
j	2
id	data
j	0
j	1
j	2
drop procedure goto2|
delete from t1|
drop procedure if exists goto3|
create procedure goto3()
begin
label L1;
begin
end;
goto L1;
end|
drop procedure goto3|
drop procedure if exists goto4|
create procedure goto4()
begin
begin
label lab1;
begin
goto lab1;
end;
end;
end|
drop procedure goto4|
drop procedure if exists goto5|
create procedure goto5()
begin
begin
begin
goto lab1;
end;
label lab1;
end;
end|
drop procedure goto5|
drop procedure if exists goto6|
create procedure goto6()
begin
label L1;
goto L5;
begin
label L2;
goto L1;
goto L5;
begin
label L3;
goto L1;
goto L2;
goto L3;
goto L4;
goto L5;
end;
goto L2;
goto L4;
label L4;
end;
label L5;
goto L1;
end|
drop procedure goto6|
insert into t1 values ("foo", 3), ("bar", 19)|
insert into t2 values ("x", 9, 4.1), ("y", -1, 19.2), ("z", 3, 2.2)|
drop procedure if exists sel1|
create procedure sel1()
begin
select * from t1;
end|
call sel1()|
id	data
foo	3
bar	19
drop procedure sel1|
drop procedure if exists sel2|
create procedure sel2()
begin
select * from t1;
select * from t2;
end|
call sel2()|
id	data
foo	3
bar	19
s	i	d
x	9	4.1
y	-1	19.2
z	3	2.2
drop procedure sel2|
delete from t1|
delete from t2|
drop procedure if exists into_test|
create procedure into_test(x char(16), y int)
begin
insert into test.t1 values (x, y);
select id,data into x,y from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_test("into", 100)|
select * from t1|
id	data
into	100
into2	102
delete from t1|
drop procedure into_test|
drop procedure if exists into_tes2|
create procedure into_test2(x char(16), y int)
begin
insert into test.t1 values (x, y);
select id,data into x,@z from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_test2("into", 100)|
select id,data,@z from t1|
id	data	@z
into	100	100
into2	102	100
delete from t1|
drop procedure into_test2|
drop procedure if exists into_test3|
create procedure into_test3()
begin
declare x char(16);
declare y int;
select * into x,y from test.t1 limit 1;
insert into test.t2 values (x, y, 0.0);
end|
insert into t1 values ("into3", 19)|
call into_test3()|
call into_test3()|
select * from t2|
s	i	d
into3	19	0
into3	19	0
delete from t1|
delete from t2|
drop procedure into_test3|
drop procedure if exists into_test4|
create procedure into_test4()
begin
declare x int;
select data into x from test.t1 limit 1;
insert into test.t3 values ("into4", x);
end|
delete from t1|
drop table if exists t3|
create table t3 ( s char(16), d int)|
call into_test4()|
Warnings:
Warning	1329	No data to FETCH
select * from t3|
s	d
into4	NULL
insert into t1 values ("i4", 77)|
call into_test4()|
select * from t3|
s	d
into4	NULL
into4	77
delete from t1|
drop table t3|
drop procedure into_test4|
drop procedure if exists into_outfile|
create procedure into_outfile(x char(16), y int)
begin
insert into test.t1 values (x, y);
select * into outfile "/tmp/spout" from test.t1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_outfile("ofile", 1)|
delete from t1|
drop procedure into_outfile|
drop procedure if exists into_dumpfile|
create procedure into_dumpfile(x char(16), y int)
begin
insert into test.t1 values (x, y);
select * into dumpfile "/tmp/spdump" from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_dumpfile("dfile", 1)|
delete from t1|
drop procedure into_dumpfile|
drop procedure if exists create_select|
create procedure create_select(x char(16), y int)
begin
insert into test.t1 values (x, y);
create temporary table test.t3 select * from test.t1;
insert into test.t3 values (concat(x, "2"), y+2);
end|
drop table if exists t3|
call create_select("cs", 90)|
select * from t1, t3|
id	data	id	data
cs	90	cs	90
cs	90	cs2	92
drop table if exists t3|
delete from t1|
drop procedure create_select|
drop function if exists e|
create function e() returns double
return 2.7182818284590452354|
set @e = e()|
select e(), @e|
e()	@e
2.718281828459	2.718281828459
drop function if exists inc|
create function inc(i int) returns int
return i+1|
select inc(1), inc(99), inc(-71)|
inc(1)	inc(99)	inc(-71)
2	100	-70
drop function if exists mul|
create function mul(x int, y int) returns int
return x*y|
select mul(1,1), mul(3,5), mul(4711, 666)|
mul(1,1)	mul(3,5)	mul(4711, 666)
1	15	3137526
drop function if exists append|
create function append(s1 char(8), s2 char(8)) returns char(16)
return concat(s1, s2)|
select append("foo", "bar")|
append("foo", "bar")
foobar
drop function if exists fac|
create function fac(n int unsigned) returns bigint unsigned
begin
declare f bigint unsigned default 1;
while n > 1 do
set f = f * n;
set n = n - 1;
end while;
return f;
end|
select fac(1), fac(2), fac(5), fac(10)|
fac(1)	fac(2)	fac(5)	fac(10)
1	2	120	3628800
drop function if exists fun|
create function fun(d double, i int, u int unsigned) returns double
return mul(inc(i), fac(u)) / e()|
select fun(2.3, 3, 5)|
fun(2.3, 3, 5)
176.58213176229
insert into t2 values (append("xxx", "yyy"), mul(4,3), e())|
insert into t2 values (append("a", "b"), mul(2,mul(3,4)), fun(1.7, 4, 6))|
select * from t2 where s = append("a", "b")|
s	i	d
ab	24	1324.36598821719
select * from t2 where i = mul(4,3) or i = mul(mul(3,4),2)|
s	i	d
xxxyyy	12	2.71828182845905
ab	24	1324.36598821719
select * from t2 where d = e()|
s	i	d
xxxyyy	12	2.71828182845905
select * from t2|
s	i	d
xxxyyy	12	2.71828182845905
ab	24	1324.36598821719
delete from t2|
drop function e|
drop function inc|
drop function mul|
drop function append|
drop function fun|
drop procedure if exists hndlr1|
create procedure hndlr1(val int)
begin
declare x int default 0;
declare foo condition for 1136;
declare bar condition for sqlstate '42S98';        # Just for testing syntax
declare zip condition for sqlstate value '42S99';  # Just for testing syntax
declare continue handler for foo set x = 1;
insert into test.t1 values ("hndlr1", val, 2);  # Too many values
if (x) then
insert into test.t1 values ("hndlr1", val);   # This instead then
end if;
end|
call hndlr1(42)|
select * from t1|
id	data
hndlr1	42
delete from t1|
drop procedure hndlr1|
drop procedure if exists hndlr2|
create procedure hndlr2(val int)
begin
declare x int default 0;
begin
declare exit handler for sqlstate '21S01' set x = 1;
insert into test.t1 values ("hndlr2", val, 2); # Too many values
end;
insert into test.t1 values ("hndlr2", x);
end|
call hndlr2(42)|
select * from t1|
id	data
hndlr2	1
delete from t1|
drop procedure hndlr2|
drop procedure if exists hndlr3|
create procedure hndlr3(val int)
begin
declare x int default 0;
declare continue handler for sqlexception        # Any error
begin
declare z int;
set z = 2 * val;
set x = 1;
end;
if val < 10 then
begin
declare y int;
set y = val + 10;
insert into test.t1 values ("hndlr3", y, 2);  # Too many values
if x then
insert into test.t1 values ("hndlr3", y);
end if;
end;
end if;
end|
call hndlr3(3)|
select * from t1|
id	data
hndlr3	13
delete from t1|
drop procedure hndlr3|
drop table if exists t3|
create table t3 ( id   char(16), data int )|
drop procedure if exists hndlr4|
create procedure hndlr4()
begin
declare x int default 0;
declare val int;	                           # No default
declare continue handler for sqlstate '02000' set x=1;
select data into val from test.t3 where id='z' limit 1;  # No hits
insert into test.t3 values ('z', val);
end|
call hndlr4()|
select * from t3|
id	data
z	NULL
drop table t3|
drop procedure hndlr4|
drop procedure if exists cur1|
create procedure cur1()
begin
declare a char(16);
declare b int;
declare c double;
declare done int default 0;
declare c cursor for select * from test.t2;
declare continue handler for sqlstate '02000' set done = 1;
open c;
repeat
fetch c into a, b, c;
if not done then
insert into test.t1 values (a, b+c);
end if;
until done end repeat;
close c;
end|
insert into t2 values ("foo", 42, -1.9), ("bar", 3, 12.1), ("zap", 666, -3.14)|
call cur1()|
select * from t1|
id	data
foo	40
bar	15
zap	663
drop procedure cur1|
drop table if exists t3|
create table t3 ( s char(16), i int )|
drop procedure if exists cur2|
create procedure cur2()
begin
declare done int default 0;
declare c1 cursor for select id,data from test.t1;
declare c2 cursor for select i from test.t2;
declare continue handler for sqlstate '02000' set done = 1;
open c1;
open c2;
repeat
begin
declare a char(16);
declare b,c int;
fetch from c1 into a, b;
fetch next from c2 into c;
if not done then
if b < c then
insert into test.t3 values (a, b);
else
insert into test.t3 values (a, c);
end if;
end if;
end;
until done end repeat;
close c1;
close c2;
end|
call cur2()|
select * from t3|
s	i
foo	40
bar	3
zap	663
delete from t1|
delete from t2|
drop table t3|
drop procedure cur2|
drop procedure if exists chistics|
create procedure chistics()
language sql
modifies sql data
not deterministic
sql security definer
comment 'Characteristics procedure test'
  insert into t1 values ("chistics", 1)|
show create procedure chistics|
Procedure	sql_mode	Create Procedure
chistics		CREATE PROCEDURE `test`.`chistics`()
    MODIFIES SQL DATA
    COMMENT 'Characteristics procedure test'
insert into t1 values ("chistics", 1)
call chistics()|
select * from t1|
id	data
chistics	1
delete from t1|
alter procedure chistics sql security invoker|
show create procedure chistics|
Procedure	sql_mode	Create Procedure
chistics		CREATE PROCEDURE `test`.`chistics`()
    MODIFIES SQL DATA
    SQL SECURITY INVOKER
    COMMENT 'Characteristics procedure test'
insert into t1 values ("chistics", 1)
drop procedure chistics|
drop function if exists chistics|
create function chistics() returns int
language sql
deterministic
sql security invoker
comment 'Characteristics procedure test'
  return 42|
show create function chistics|
Function	sql_mode	Create Function
chistics		CREATE FUNCTION `test`.`chistics`() RETURNS int(11)
    DETERMINISTIC
    SQL SECURITY INVOKER
    COMMENT 'Characteristics procedure test'
return 42
select chistics()|
chistics()
42
alter function chistics
no sql
comment 'Characteristics function test'|
show create function chistics|
Function	sql_mode	Create Function
chistics		CREATE FUNCTION `test`.`chistics`() RETURNS int(11)
    NO SQL
    DETERMINISTIC
    SQL SECURITY INVOKER
    COMMENT 'Characteristics function test'
return 42
drop function chistics|
insert into t1 values ("foo", 1), ("bar", 2), ("zip", 3)|
set @@sql_mode = 'ANSI'|
drop procedure if exists modes$
create procedure modes(out c1 int, out c2 int)
begin
declare done int default 0;
declare x int;
declare c cursor for select data from t1;
declare continue handler for sqlstate '02000' set done = 1;
select 1 || 2 into c1;
set c2 = 0;
open c;
repeat
fetch c into x;
if not done then
set c2 = c2 + 1;
end if;
until done end repeat;
close c;
end$
set @@sql_mode = ''|
set sql_select_limit = 1|
call modes(@c1, @c2)|
set sql_select_limit = default|
select @c1, @c2|
@c1	@c2
12	3
delete from t1|
drop procedure modes|
create database sp_db1|
drop database sp_db1|
create database sp_db2|
use sp_db2|
create table t3 ( s char(4), t int )|
insert into t3 values ("abcd", 42), ("dcba", 666)|
use test|
drop database sp_db2|
create database sp_db3|
use sp_db3|
drop procedure if exists dummy|
create procedure dummy(out x int)
set x = 42|
use test|
drop database sp_db3|
select type,db,name from mysql.proc where db = 'sp_db3'|
type	db	name
drop procedure if exists rc|
create procedure rc()
begin
delete from t1;
insert into t1 values ("a", 1), ("b", 2), ("c", 3);
end|
call rc()|
select row_count()|
row_count()
3
update t1 set data=42 where id = "b";
select row_count()|
row_count()
1
delete from t1|
select row_count()|
row_count()
3
delete from t1|
select row_count()|
row_count()
0
select * from t1|
id	data
select row_count()|
row_count()
-1
drop procedure rc|
drop function if exists f0|
drop function if exists f1|
drop function if exists f2|
drop function if exists f3|
drop function if exists f4|
drop function if exists f5|
drop function if exists f6|
drop function if exists f7|
drop function if exists f8|
drop view if exists v0|
drop view if exists v1|
drop view if exists v2|
delete from t1|
delete from t2|
insert into t1 values ("a", 1), ("b", 2) |
insert into t2 values ("a", 1, 1.0), ("b", 2, 2.0), ("c", 3, 3.0) |
create function f1() returns int
return (select sum(data) from t1)|
select f1()|
f1()
3
select id, f1() from t1|
id	f1()
a	3
b	3
create function f2() returns int
return (select data from t1 where data <= (select sum(data) from t1) limit 1)|
select f2()|
f2()
1
select id, f2() from t1|
id	f2()
a	1
b	1
create function f3() returns int
begin
declare n int;
declare m int;
set n:= (select min(data) from t1);
set m:= (select max(data) from t1);
return n < m;
end|
select f3()|
f3()
1
select id, f3() from t1|
id	f3()
a	1
b	1
select f1(), f3()|
f1()	f3()
3	1
select id, f1(), f3() from t1|
id	f1()	f3()
a	3	1
b	3	1
create function f4() returns double 
return (select d from t1, t2 where t1.data = t2.i and t1.id= "b")|
select f4()|
f4()
2
select s, f4() from t2|
s	f4()
a	2
b	2
c	2
create function f5(i int) returns int
begin
if i <= 0 then
return 0;
elseif i = 1  then
return (select count(*) from t1 where data = i);
else
return (select count(*) + f5( i - 1) from t1 where data = i);
end if;
end|
select f5(1)|
f5(1)
1
create function f6() returns int
begin
declare n int;
set n:= f1();
return (select count(*) from t1 where data <= f7() and data <= n);
end|
create function f7() returns int
return (select sum(data) from t1 where data <= f1())|
select f6()|
f6()
2
select id, f6() from t1|
id	f6()
a	2
b	2
create view v1 (a) as select f1()|
select * from v1|
a
3
select id, a from t1, v1|
id	a
a	3
b	3
select * from v1, v1 as v|
a	a
3	3
create view v2 (a) as select a*10 from v1|
select * from v2|
a
30
select id, a from t1, v2|
id	a
a	30
b	30
select * from v1, v2|
a	a
3	30
create function f8 () returns int
return (select count(*) from v2)|
select *, f8() from v1|
a	f8()
3	1
drop function f1|
select * from v1|
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s)
create function f1() returns int
return (select sum(data) from t1) + (select sum(data) from v1)|
drop function f1|
create function f1() returns int
return (select sum(data) from t1)|
create function f0() returns int
return (select * from (select 100) as r)|
select f0()|
f0()
100
select *, f0() from (select 1) as t|
1	f0()
1	100
create view v0 as select f0()|
select * from v0|
f0()
100
select *, f0() from v0|
f0()	f0()
100	100
lock tables t1 read, t1 as t11 read, mysql.proc read|
select f3()|
f3()
1
select id, f3() from t1 as t11|
id	f3()
a	1
b	1
select f0()|
f0()
100
select * from v0|
f0()
100
select *, f0() from v0, (select 123) as d1|
f0()	123	f0()
100	123	100
select id, f3() from t1|
ERROR HY000: Table 't1' was not locked with LOCK TABLES
select f4()|
ERROR HY000: Table 't2' was not locked with LOCK TABLES
unlock tables|
lock tables v2 read, mysql.proc read|
select * from v2|
a
30
select * from v1|
a
3
select * from v1, v2|
ERROR HY000: Table 't1' was not locked with LOCK TABLES
select f4()|
ERROR HY000: Table 't2' was not locked with LOCK TABLES
unlock tables|
drop function f0|
drop function f1|
drop function f2|
drop function f3|
drop function f4|
drop function f5|
drop function f6|
drop function f7|
drop function f8|
drop view v0|
drop view v1|
drop view v2|
delete from t1 |
delete from t2 |
drop table if exists fac|
create table fac (n int unsigned not null primary key, f bigint unsigned)|
drop procedure if exists ifac|
create procedure ifac(n int unsigned)
begin
declare i int unsigned default 1;
if n > 20 then
set n = 20;		# bigint overflow otherwise
end if;
while i <= n do
begin
insert into test.fac values (i, fac(i));
set i = i + 1;
end;
end while;
end|
call ifac(20)|
select * from fac|
n	f
1	1
2	2
3	6
4	24
5	120
6	720
7	5040
8	40320
9	362880
10	3628800
11	39916800
12	479001600
13	6227020800
14	87178291200
15	1307674368000
16	20922789888000
17	355687428096000
18	6402373705728000
19	121645100408832000
20	2432902008176640000
drop table fac|
show function status like '%f%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	fac	FUNCTION	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
drop procedure ifac|
drop function fac|
show function status like '%f%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
drop table if exists primes|
create table primes (
i int unsigned not null primary key,
p bigint unsigned not null
)|
insert into primes values
( 0,   3), ( 1,   5), ( 2,   7), ( 3,  11), ( 4,  13),
( 5,  17), ( 6,  19), ( 7,  23), ( 8,  29), ( 9,  31),
(10,  37), (11,  41), (12,  43), (13,  47), (14,  53),
(15,  59), (16,  61), (17,  67), (18,  71), (19,  73),
(20,  79), (21,  83), (22,  89), (23,  97), (24, 101),
(25, 103), (26, 107), (27, 109), (28, 113), (29, 127),
(30, 131), (31, 137), (32, 139), (33, 149), (34, 151),
(35, 157), (36, 163), (37, 167), (38, 173), (39, 179),
(40, 181), (41, 191), (42, 193), (43, 197), (44, 199)|
drop procedure if exists opp|
create procedure opp(n bigint unsigned, out pp bool)
begin
declare r double;
declare b, s bigint unsigned default 0;
set r = sqrt(n);
again:
loop
if s = 45 then
set b = b+200, s = 0;
else
begin
declare p bigint unsigned;
select t.p into p from test.primes t where t.i = s;
if b+p > r then
set pp = 1;
leave again;
end if;
if mod(n, b+p) = 0 then
set pp = 0;
leave again;
end if;
set s = s+1;
end;
end if;
end loop;
end|
drop procedure if exists ip|
create procedure ip(m int unsigned)
begin
declare p bigint unsigned;
declare i int unsigned;
set i=45, p=201;
while i < m do
begin
declare pp bool default 0;
call opp(p, pp);
if pp then
insert into test.primes values (i, p);
set i = i+1;
end if;
set p = p+2;
end;
end while;
end|
show create procedure opp|
Procedure	sql_mode	Create Procedure
opp		CREATE PROCEDURE `test`.`opp`(n bigint unsigned, out pp bool)
begin
declare r double;
declare b, s bigint unsigned default 0;
set r = sqrt(n);
again:
loop
if s = 45 then
set b = b+200, s = 0;
else
begin
declare p bigint unsigned;
select t.p into p from test.primes t where t.i = s;
if b+p > r then
set pp = 1;
leave again;
end if;
if mod(n, b+p) = 0 then
set pp = 0;
leave again;
end if;
set s = s+1;
end;
end if;
end loop;
end
show procedure status like '%p%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	ip	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
test	opp	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
call ip(200)|
select * from primes where i=45 or i=100 or i=199|
i	p
45	211
100	557
199	1229
drop table primes|
drop procedure opp|
drop procedure ip|
show procedure status like '%p%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
drop table if exists fib|
create table fib ( f bigint unsigned not null )|
drop procedure if exists fib|
create procedure fib(n int unsigned)
begin
if n > 1 then
begin
declare x, y bigint unsigned;
declare c cursor for select f from fib order by f desc limit 2;
open c;
fetch c into y;
fetch c into x;
close c;
insert into fib values (x+y);
call fib(n-1);
end;
end if;
end|
insert into fib values (0), (1)|
call fib(3)|
select * from fib order by f asc|
f
0
1
1
2
delete from fib|
insert into fib values (0), (1)|
call fib(20)|
select * from fib order by f asc|
f
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
drop table fib|
drop procedure fib|
drop procedure if exists bar|
create procedure bar(x char(16), y int)
comment "111111111111" sql security invoker
insert into test.t1 values (x, y)|
show procedure status like 'bar'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	bar	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	INVOKER	111111111111
alter procedure bar comment "2222222222" sql security definer|
alter procedure bar comment "3333333333"|
alter procedure bar|
show create procedure bar|
Procedure	sql_mode	Create Procedure
bar		CREATE PROCEDURE `test`.`bar`(x char(16), y int)
    COMMENT '3333333333'
insert into test.t1 values (x, y)
show procedure status like 'bar'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	bar	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	3333333333
drop procedure bar|
drop procedure if exists p1|
create procedure p1 ()
select (select s1 from t3) from t3|
create table t3 (s1 int)|
call p1()|
(select s1 from t3)
insert into t3 values (1)|
call p1()|
(select s1 from t3)
1
drop procedure p1|
drop table t3|
drop function if exists foo|
create function `foo` () returns int
return 5|
select `foo` ()|
`foo` ()
5
drop function `foo`|
drop function if exists t1max|
Warnings:
Note	1305	FUNCTION t1max does not exist
create function t1max() returns int
begin
declare x int;
select max(data) into x from t1;
return x;
end|
insert into t1 values ("foo", 3), ("bar", 2), ("zip", 5), ("zap", 1)|
select t1max()|
t1max()
5
drop function t1max|
drop table if exists t3|
create table t3 (
v char(16) not null primary key,
c int unsigned not null
)|
create function getcount(s char(16)) returns int
begin
declare x int;
select count(*) into x from t3 where v = s;
if x = 0 then
insert into t3 values (s, 1);
else
update t3 set c = c+1 where v = s;
end if;
return x;
end|
select * from t1 where data = getcount("bar")|
id	data
zap	1
select * from t3|
v	c
bar	4
select getcount("zip")|
getcount("zip")
0
select getcount("zip")|
getcount("zip")
1
select * from t3|
v	c
bar	4
zip	2
select getcount(id) from t1 where data = 3|
getcount(id)
0
select getcount(id) from t1 where data = 5|
getcount(id)
1
select * from t3|
v	c
bar	4
zip	3
foo	1
drop table t3|
drop function getcount|
drop procedure if exists bug822|
create procedure bug822(a_id char(16), a_data int)
begin
declare n int;
select count(*) into n from t1 where id = a_id and data = a_data;
if n = 0 then
insert into t1 (id, data) values (a_id, a_data);
end if;
end|
delete from t1|
call bug822('foo', 42)|
call bug822('foo', 42)|
call bug822('bar', 666)|
select * from t1|
id	data
foo	42
bar	666
delete from t1|
drop procedure bug822|
drop procedure if exists bug1495|
create procedure bug1495()
begin
declare x int;
select data into x from t1 order by id limit 1;
if x > 10 then
insert into t1 values ("less", x-10);
else
insert into t1 values ("more", x+10);
end if;
end|
insert into t1 values ('foo', 12)|
call bug1495()|
delete from t1 where id='foo'|
insert into t1 values ('bar', 7)|
call bug1495()|
delete from t1 where id='bar'|
select * from t1|
id	data
less	2
more	17
delete from t1|
drop procedure bug1495|
drop procedure if exists bug1547|
create procedure bug1547(s char(16))
begin
declare x int;
select data into x from t1 where s = id limit 1;
if x > 10 then
insert into t1 values ("less", x-10);
else
insert into t1 values ("more", x+10);
end if;
end|
insert into t1 values ("foo", 12), ("bar", 7)|
call bug1547("foo")|
call bug1547("bar")|
select * from t1|
id	data
foo	12
bar	7
less	2
more	17
delete from t1|
drop procedure bug1547|
drop table if exists t70|
create table t70 (s1 int,s2 int)|
insert into t70 values (1,2)|
drop procedure if exists bug1656|
create procedure bug1656(out p1 int, out p2 int)
select * into p1, p1 from t70|
call bug1656(@1, @2)|
select @1, @2|
@1	@2
2	NULL
drop table t70|
drop procedure bug1656|
drop table if exists t3|
create table t3(a int)|
drop procedure if exists bug1862|
create procedure bug1862()
begin
insert into t3 values(2);    
flush tables;
end|
call bug1862()|
call bug1862()|
select * from t3|
a
2
2
drop table t3|
drop procedure bug1862|
drop procedure if exists bug1874|
create procedure bug1874()
begin
declare x int;
declare y double;
select max(data) into x from t1;
insert into t2 values ("max", x, 0);
select min(data) into x from t1;
insert into t2 values ("min", x, 0);
select sum(data) into x from t1;
insert into t2 values ("sum", x, 0);
select avg(data) into y from t1;
insert into t2 values ("avg", 0, y);
end|
insert into t1 (data) values (3), (1), (5), (9), (4)|
call bug1874()|
select * from t2|
s	i	d
max	9	0
min	1	0
sum	22	0
avg	0	4.4
delete from t1|
delete from t2|
drop procedure bug1874|
drop procedure if exists bug2260|
create procedure bug2260()
begin
declare v1 int;
declare c1 cursor for select data from t1;
declare continue handler for not found set @x2 = 1;
open c1;
fetch c1 into v1;
set @x2 = 2;
close c1;
end|
call bug2260()|
select @x2|
@x2
2
drop procedure bug2260|
drop procedure if exists bug2227|
create procedure bug2227(x int)
begin
declare y float default 2.6;
declare z char(16) default "zzz";
select 1.3, x, y, 42, z;
end|
call bug2227(9)|
1.3	x	y	42	z
1.3	9	2.6	42	zzz
drop procedure bug2227|
drop function if exists bug2674|
create function bug2674() returns int
return @@sort_buffer_size|
set @osbs = @@sort_buffer_size|
set @@sort_buffer_size = 262000|
select bug2674()|
bug2674()
262000
drop function bug2674|
set @@sort_buffer_size = @osbs|
drop procedure if exists bug3259_1 |
create procedure bug3259_1 () begin end|
drop procedure if exists BUG3259_2 |
create procedure BUG3259_2 () begin end|
drop procedure if exists Bug3259_3 |
create procedure Bug3259_3 () begin end|
call BUG3259_1()|
call BUG3259_1()|
call bug3259_2()|
call Bug3259_2()|
call bug3259_3()|
call bUG3259_3()|
drop procedure bUg3259_1|
drop procedure BuG3259_2|
drop procedure BUG3259_3|
drop function if exists bug2772|
create function bug2772() returns char(10) character set latin2
return 'a'|
select bug2772()|
bug2772()
a
drop function bug2772|
drop procedure if exists bug2776_1|
create procedure bug2776_1(out x int)
begin
declare v int;
set v = default;
set x = v;
end|
drop procedure if exists bug2776_2|
create procedure bug2776_2(out x int)
begin
declare v int default 42;
set v = default;
set x = v;
end|
set @x = 1|
call bug2776_1(@x)|
select @x|
@x
NULL
call bug2776_2(@x)|
select @x|
@x
42
drop procedure bug2776_1|
drop procedure bug2776_2|
drop table if exists t3|
create table t3 (s1 smallint)|
insert into t3 values (123456789012)|
Warnings:
Warning	1264	Out of range value adjusted for column 's1' at row 1
drop procedure if exists bug2780|
create procedure bug2780()
begin
declare exit handler for sqlwarning set @x = 1; 
set @x = 0;
insert into t3 values (123456789012);
insert into t3 values (0);
end|
call bug2780()|
select @x|
@x
1
select * from t3|
s1
32767
32767
drop procedure bug2780|
drop table t3|
create table t3 (content varchar(10) )|
insert into t3 values ("test1")|
insert into t3 values ("test2")|
create table t4 (f1 int, rc int, t3 int)|
drop procedure if exists bug1863|
create procedure bug1863(in1 int)
begin 
declare ind int default 0;
declare t1 int;
declare t2 int;
declare t3 int;
declare rc int default 0;
declare continue handler for 1065 set rc = 1;
drop temporary table if exists temp_t1;
create temporary table temp_t1 (
f1 int auto_increment, f2 varchar(20), primary key (f1)
);
insert into temp_t1 (f2) select content from t3;
select f2 into t3 from temp_t1 where f1 = 10;
if (rc) then
insert into t4 values (1, rc, t3);
end if;
insert into t4 values (2, rc, t3);
end|
call bug1863(10)|
Warnings:
Note	1051	Unknown table 'temp_t1'
Warning	1329	No data to FETCH
call bug1863(10)|
Warnings:
Warning	1329	No data to FETCH
select * from t4|
f1	rc	t3
2	0	NULL
2	0	NULL
drop procedure bug1863|
drop temporary table temp_t1;
drop table t3, t4|
drop table if exists t3, t4|
create table t3 ( 
OrderID  int not null,
MarketID int,
primary key (OrderID)
)|
create table t4 ( 
MarketID int not null,
Market varchar(60),
Status char(1),
primary key (MarketID)
)|
insert t3 (OrderID,MarketID) values (1,1)|
insert t3 (OrderID,MarketID) values (2,2)|
insert t4 (MarketID,Market,Status) values (1,"MarketID One","A")|
insert t4 (MarketID,Market,Status) values (2,"MarketID Two","A")|
drop procedure if exists bug2656_1|
create procedure bug2656_1()
begin 
select
m.Market
from  t4 m JOIN t3 o 
ON o.MarketID != 1 and o.MarketID = m.MarketID;
end |
drop procedure if exists bug2656_2|
create procedure bug2656_2()
begin 
select
m.Market
from  
t4 m, t3 o
where       
m.MarketID != 1 and m.MarketID = o.MarketID;
end |
call bug2656_1()|
Market
MarketID Two
call bug2656_1()|
Market
MarketID Two
call bug2656_2()|
Market
MarketID Two
call bug2656_2()|
Market
MarketID Two
drop procedure bug2656_1|
drop procedure bug2656_2|
drop table t3, t4|
drop procedure if exists bug3426|
create procedure bug3426(in_time int unsigned, out x int)
begin
if in_time is null then
set @stamped_time=10;
set x=1;
else
set @stamped_time=in_time;
set x=2;
end if;
end|
call bug3426(1000, @i)|
select @i, from_unixtime(@stamped_time, '%d-%m-%Y %h:%i:%s') as time|
@i	time
2	01-01-1970 03:16:40
call bug3426(NULL, @i)|
select @i, from_unixtime(@stamped_time, '%d-%m-%Y %h:%i:%s') as time|
@i	time
1	01-01-1970 03:00:10
alter procedure bug3426 sql security invoker|
call bug3426(NULL, @i)|
select @i, from_unixtime(@stamped_time, '%d-%m-%Y %h:%i:%s') as time|
@i	time
1	01-01-1970 03:00:10
call bug3426(1000, @i)|
select @i, from_unixtime(@stamped_time, '%d-%m-%Y %h:%i:%s') as time|
@i	time
2	01-01-1970 03:16:40
drop procedure bug3426|
drop table if exists t3, t4|
create table t3 (
a int primary key, 
ach char(1)
) engine = innodb|
create table t4 (
b int  primary key , 
bch char(1)
) engine = innodb|
insert into t3 values (1 , 'aCh1' ) , ('2' , 'aCh2')|
Warnings:
Warning	1265	Data truncated for column 'ach' at row 1
Warning	1265	Data truncated for column 'ach' at row 2
insert into t4 values (1 , 'bCh1' )|
Warnings:
Warning	1265	Data truncated for column 'bch' at row 1
drop procedure if exists bug3448|
create procedure bug3448()
select * from t3 inner join t4 on t3.a = t4.b|
select * from t3 inner join t4 on t3.a = t4.b|
a	ach	b	bch
1	a	1	b
call bug3448()|
a	ach	b	bch
1	a	1	b
call bug3448()|
a	ach	b	bch
1	a	1	b
drop procedure bug3448|
drop table t3, t4|
drop table if exists t3|
create table t3 (
id int unsigned auto_increment not null primary key,
title VARCHAR(200),
body text,
fulltext (title,body)
)|
insert into t3 (title,body) values
('MySQL Tutorial','DBMS stands for DataBase ...'),
('How To Use MySQL Well','After you went through a ...'),
('Optimizing MySQL','In this tutorial we will show ...'),
('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
('MySQL vs. YourSQL','In the following database comparison ...'),
('MySQL Security','When configured properly, MySQL ...')|
drop procedure if exists bug3734 |
create procedure bug3734 (param1 varchar(100))
select * from t3 where match (title,body) against (param1)|
call bug3734('database')|
id	title	body
5	MySQL vs. YourSQL	In the following database comparison ...
1	MySQL Tutorial	DBMS stands for DataBase ...
call bug3734('Security')|
id	title	body
6	MySQL Security	When configured properly, MySQL ...
drop procedure bug3734|
drop table t3|
drop procedure if exists bug3863|
create procedure bug3863()
begin
set @a = 0;
while @a < 5 do
set @a = @a + 1;
end while;
end|
call bug3863()|
select @a|
@a
5
call bug3863()|
select @a|
@a
5
drop procedure bug3863|
create table t3 (
id int(10) unsigned not null default 0,
rid int(10) unsigned not null default 0,
msg text not null,
primary key (id),
unique key rid (rid, id)
)|
drop procedure if exists bug2460_1|
create procedure bug2460_1(in v int)
begin
( select n0.id from t3 as n0 where n0.id = v )
union
( select n0.id from t3 as n0, t3 as n1
where n0.id = n1.rid and n1.id = v )
union
( select n0.id from t3 as n0, t3 as n1, t3 as n2
where n0.id = n1.rid and n1.id = n2.rid and n2.id = v );
end|
call bug2460_1(2)|
id
call bug2460_1(2)|
id
insert into t3 values (1, 1, 'foo'), (2, 1, 'bar'), (3, 1, 'zip zap')|
call bug2460_1(2)|
id
2
1
call bug2460_1(2)|
id
2
1
drop procedure if exists bug2460_2|
create procedure bug2460_2()
begin
drop table if exists t3;
create temporary table t3 (s1 int);
insert into t3 select 1 union select 1;
end|
call bug2460_2()|
call bug2460_2()|
select * from t3|
s1
1
drop procedure bug2460_1|
drop procedure bug2460_2|
drop table t3|
set @@sql_mode = ''|
drop procedure if exists bug2564_1|
create procedure bug2564_1()
comment 'Joe''s procedure'
  insert into `t1` values ("foo", 1)|
set @@sql_mode = 'ANSI_QUOTES'|
drop procedure if exists bug2564_2|
create procedure bug2564_2()
insert into "t1" values ('foo', 1)|
set @@sql_mode = ''$
drop function if exists bug2564_3$
create function bug2564_3(x int, y int) returns int
return x || y$
set @@sql_mode = 'ANSI'$
drop function if exists bug2564_4$
create function bug2564_4(x int, y int) returns int
return x || y$
set @@sql_mode = ''|
show create procedure bug2564_1|
Procedure	sql_mode	Create Procedure
bug2564_1		CREATE PROCEDURE `test`.`bug2564_1`()
    COMMENT 'Joe''s procedure'
insert into `t1` values ("foo", 1)
show create procedure bug2564_2|
Procedure	sql_mode	Create Procedure
bug2564_2	ANSI_QUOTES	CREATE PROCEDURE "test"."bug2564_2"()
insert into "t1" values ('foo', 1)
show create function bug2564_3|
Function	sql_mode	Create Function
bug2564_3		CREATE FUNCTION `test`.`bug2564_3`(x int, y int) RETURNS int(11)
return x || y
show create function bug2564_4|
Function	sql_mode	Create Function
bug2564_4	REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ANSI	CREATE FUNCTION "test"."bug2564_4"(x int, y int) RETURNS int(11)
return x || y
drop procedure bug2564_1|
drop procedure bug2564_2|
drop function bug2564_3|
drop function bug2564_4|
drop function if exists bug3132|
create function bug3132(s char(20)) returns char(50)
return concat('Hello, ', s, '!')|
select bug3132('Bob') union all select bug3132('Judy')|
bug3132('Bob')
Hello, Bob!
Hello, Judy!
drop function bug3132|
drop procedure if exists bug3843|
create procedure bug3843()
analyze table t1|
call bug3843()|
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
call bug3843()|
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Table is already up to date
select 1+2|
1+2
3
drop procedure bug3843|
drop table if exists t3|
create table t3 ( s1 char(10) )|
insert into t3 values ('a'), ('b')|
drop procedure if exists bug3368|
create procedure bug3368(v char(10))
begin
select group_concat(v) from t3;
end|
call bug3368('x')|
group_concat(v)
x,x
call bug3368('yz')|
group_concat(v)
yz,yz
drop procedure bug3368|
drop table t3|
drop table if exists t3|
create table t3 (f1 int, f2 int)|
insert into t3 values (1,1)|
drop procedure if exists bug4579_1|
create procedure bug4579_1 ()
begin
declare sf1 int;
select f1 into sf1 from t3 where f1=1 and f2=1;
update t3 set f2 = f2 + 1 where f1=1 and f2=1;
call bug4579_2();
end|
drop procedure if exists bug4579_2|
create procedure bug4579_2 ()
begin
end|
call bug4579_1()|
call bug4579_1()|
Warnings:
Warning	1329	No data to FETCH
call bug4579_1()|
Warnings:
Warning	1329	No data to FETCH
drop procedure bug4579_1|
drop procedure bug4579_2|
drop table t3|
drop table if exists t3|
drop procedure if exists bug2773|
create function bug2773() returns int return null|
create table t3 as select bug2773()|
show create table t3|
Table	Create Table
t3	CREATE TABLE `t3` (
  `bug2773()` int(11) default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
drop table t3|
drop function bug2773|
drop procedure if exists bug3788|
create function bug3788() returns date return cast("2005-03-04" as date)|
select bug3788()|
bug3788()
2005-03-04
drop function bug3788|
create function bug3788() returns binary(5) return 5|
select bug3788()|
bug3788()
5
drop function bug3788|
drop table if exists t3|
create table t3 (f1 int, f2 int, f3 int)|
insert into t3 values (1,1,1)|
drop procedure if exists bug4726|
create procedure bug4726()
begin
declare tmp_o_id INT;
declare tmp_d_id INT default 1;
while tmp_d_id <= 2 do
begin
select f1 into tmp_o_id from t3 where f2=1 and f3=1;
set tmp_d_id = tmp_d_id + 1;
end;
end while;
end|
call bug4726()|
call bug4726()|
call bug4726()|
drop procedure bug4726|
drop table t3|
drop procedure if exists bug4902|
create procedure bug4902()
begin
show charset like 'foo';
show collation like 'foo';
show column types;
show create table t1;
show create database test;
show databases like 'foo';
show errors;
show columns from t1;
show grants for 'root'@'localhost';
show keys from t1;
show open tables like 'foo';
show privileges;
show status like 'foo';
show tables like 'foo';
show variables like 'foo';
show warnings;
end|
call bug4902()|
Charset	Description	Default collation	Maxlen
Collation	Charset	Id	Default	Compiled	Sortlen
Type	Size	Min_Value	Max_Value	Prec	Scale	Nullable	Auto_Increment	Unsigned	Zerofill	Searchable	Case_Sensitive	Default	Comment
tinyint	1	-128	127	0	0	YES	YES	NO	YES	YES	NO	NULL,0	A very small integer
tinyint unsigned	1	0	255	0	0	YES	YES	YES	YES	YES	NO	NULL,0	A very small integer
Table	Create Table
t1	CREATE TABLE `t1` (
  `id` char(16) NOT NULL default '',
  `data` int(11) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
Database	Create Database
test	CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET latin1 */
Database (foo)
Level	Code	Message
Field	Type	Null	Key	Default	Extra
id	char(16)	NO			
data	int(11)	NO			
Grants for root@localhost
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION
Table	Non_unique	Key_name	Seq_in_index	Column_name	Collation	Cardinality	Sub_part	Packed	Null	Index_type	Comment
Database	Table	In_use	Name_locked
Privilege	Context	Comment
Alter	Tables	To alter the table
Alter routine	Functions,Procedures	To alter or drop stored functions/procedures
Create	Databases,Tables,Indexes	To create new databases and tables
Create routine	Functions,Procedures	To use CREATE FUNCTION/PROCEDURE
Create temporary tables	Databases	To use CREATE TEMPORARY TABLE
Create view	Tables	To create new views
Create user	Server Admin	To create new users
Delete	Tables	To delete existing rows
Drop	Databases,Tables	To drop databases, tables, and views
Execute	Functions,Procedures	To execute stored routines
File	File access on server	To read and write files on the server
Grant option	Databases,Tables,Functions,Procedures	To give to other users those privileges you possess
Index	Tables	To create or drop indexes
Insert	Tables	To insert data into tables
Lock tables	Databases	To use LOCK TABLES (together with SELECT privilege)
Process	Server Admin	To view the plain text of currently executing queries
References	Databases,Tables	To have references on tables
Reload	Server Admin	To reload or refresh tables, logs and privileges
Replication client	Server Admin	To ask where the slave or master servers are
Replication slave	Server Admin	To read binary log events from the master
Select	Tables	To retrieve rows from table
Show databases	Server Admin	To see all databases with SHOW DATABASES
Show view	Tables	To see views with SHOW CREATE VIEW
Shutdown	Server Admin	To shut down the server
Super	Server Admin	To use KILL thread, SET GLOBAL, CHANGE MASTER, etc.
Update	Tables	To update existing rows
Usage	Server Admin	No privileges - allow connect only
Variable_name	Value
Tables_in_test (foo)
Variable_name	Value
Level	Code	Message
call bug4902()|
Charset	Description	Default collation	Maxlen
Collation	Charset	Id	Default	Compiled	Sortlen
Type	Size	Min_Value	Max_Value	Prec	Scale	Nullable	Auto_Increment	Unsigned	Zerofill	Searchable	Case_Sensitive	Default	Comment
tinyint	1	-128	127	0	0	YES	YES	NO	YES	YES	NO	NULL,0	A very small integer
tinyint unsigned	1	0	255	0	0	YES	YES	YES	YES	YES	NO	NULL,0	A very small integer
Table	Create Table
t1	CREATE TABLE `t1` (
  `id` char(16) NOT NULL default '',
  `data` int(11) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
Database	Create Database
test	CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET latin1 */
Database (foo)
Level	Code	Message
Field	Type	Null	Key	Default	Extra
id	char(16)	NO			
data	int(11)	NO			
Grants for root@localhost
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION
Table	Non_unique	Key_name	Seq_in_index	Column_name	Collation	Cardinality	Sub_part	Packed	Null	Index_type	Comment
Database	Table	In_use	Name_locked
Privilege	Context	Comment
Alter	Tables	To alter the table
Alter routine	Functions,Procedures	To alter or drop stored functions/procedures
Create	Databases,Tables,Indexes	To create new databases and tables
Create routine	Functions,Procedures	To use CREATE FUNCTION/PROCEDURE
Create temporary tables	Databases	To use CREATE TEMPORARY TABLE
Create view	Tables	To create new views
Create user	Server Admin	To create new users
Delete	Tables	To delete existing rows
Drop	Databases,Tables	To drop databases, tables, and views
Execute	Functions,Procedures	To execute stored routines
File	File access on server	To read and write files on the server
Grant option	Databases,Tables,Functions,Procedures	To give to other users those privileges you possess
Index	Tables	To create or drop indexes
Insert	Tables	To insert data into tables
Lock tables	Databases	To use LOCK TABLES (together with SELECT privilege)
Process	Server Admin	To view the plain text of currently executing queries
References	Databases,Tables	To have references on tables
Reload	Server Admin	To reload or refresh tables, logs and privileges
Replication client	Server Admin	To ask where the slave or master servers are
Replication slave	Server Admin	To read binary log events from the master
Select	Tables	To retrieve rows from table
Show databases	Server Admin	To see all databases with SHOW DATABASES
Show view	Tables	To see views with SHOW CREATE VIEW
Shutdown	Server Admin	To shut down the server
Super	Server Admin	To use KILL thread, SET GLOBAL, CHANGE MASTER, etc.
Update	Tables	To update existing rows
Usage	Server Admin	No privileges - allow connect only
Variable_name	Value
Tables_in_test (foo)
Variable_name	Value
Level	Code	Message
drop procedure bug4902|
drop procedure if exists bug4902_2|
create procedure bug4902_2()
begin
show processlist;
end|
call bug4902_2()|
Id	User	Host	db	Command	Time	State	Info
#	root	localhost	test	Query	#	NULL	show processlist
call bug4902_2()|
Id	User	Host	db	Command	Time	State	Info
#	root	localhost	test	Query	#	NULL	show processlist
drop procedure bug4902_2|
drop table if exists t3|
drop procedure if exists bug4904|
create procedure bug4904()
begin
declare continue handler for sqlstate 'HY000' begin end;
create table t2 as select * from t3;
end|
call bug4904()|
ERROR 42S02: Table 'test.t3' doesn't exist
drop procedure bug4904|
create table t3 (s1 char character set latin1, s2 char character set latin2)|
drop procedure if exists bug4904|
create procedure bug4904 ()
begin
declare continue handler for sqlstate 'HY000' begin end;
select s1 from t3 union select s2 from t3; 
end|
call bug4904()|
drop procedure bug4904|
drop table t3|
drop procedure if exists bug336|
create procedure bug336(out y int)
begin
declare x int;
set x = (select sum(t.data) from test.t1 t);
set y = x;
end|
insert into t1 values ("a", 2), ("b", 3)|
call bug336(@y)|
select @y|
@y
5
delete from t1|
drop procedure bug336|
drop procedure if exists bug3157|
create procedure bug3157()
begin
if exists(select * from t1) then
set @n= @n + 1;
end if;
if (select count(*) from t1) then
set @n= @n + 1;
end if;
end|
set @n = 0|
insert into t1 values ("a", 1)|
call bug3157()|
select @n|
@n
2
delete from t1|
drop procedure bug3157|
drop procedure if exists bug5251|
create procedure bug5251()
begin
end|
select created into @c1 from mysql.proc
where db='test' and name='bug5251'|
alter procedure bug5251 comment 'foobar'|
select count(*) from mysql.proc
where  db='test' and name='bug5251' and created = @c1|
count(*)
1
drop procedure bug5251|
drop procedure if exists bug5251|
create procedure bug5251()
checksum table t1|
call bug5251()|
Table	Checksum
test.t1	0
call bug5251()|
Table	Checksum
test.t1	0
drop procedure bug5251|
drop procedure if exists bug5287|
create procedure bug5287(param1 int)
label1:
begin
declare c cursor for select 5;
loop
if param1 >= 0 then
leave label1;
end if;
end loop;
end|
call bug5287(1)|
drop procedure bug5287|
drop procedure if exists bug5307|
create procedure bug5307()
begin
end; set @x = 3|
call bug5307()|
select @x|
@x
3
drop procedure bug5307|
drop procedure if exists bug5258|
create procedure bug5258()
begin
end|
drop procedure if exists bug5258_aux|
create procedure bug5258_aux()
begin
declare c, m char(19);
select created,modified into c,m from mysql.proc where name = 'bug5258';
if c = m then
select 'Ok';
else
select c, m;
end if;
end|
call bug5258_aux()|
Ok
Ok
drop procedure bug5258|
drop procedure bug5258_aux|
drop function if exists bug4487|
create function bug4487() returns char
begin
declare v char;
return v;
end|
select bug4487()|
bug4487()
NULL
drop function bug4487|
drop procedure if exists bug4941|
drop procedure if exists bug4941|
create procedure bug4941(out x int)
begin
declare c cursor for select i from t2 limit 1;
open c;
fetch c into x;
close c;
end|
insert into t2 values (null, null, null)|
set @x = 42|
call bug4941(@x)|
select @x|
@x
NULL
delete from t1|
drop procedure bug4941|
drop procedure if exists bug3583|
drop procedure if exists bug3583|
create procedure bug3583()
begin
declare c int;
select * from t1;
select count(*) into c from t1;
select c;
end|
insert into t1 values ("x", 3), ("y", 5)|
set @x = @@query_cache_size|
set global query_cache_size = 10*1024*1024|
flush status|
flush query cache|
show status like 'Qcache_hits'|
Variable_name	Value
Qcache_hits	0
call bug3583()|
id	data
x	3
y	5
c
2
show status like 'Qcache_hits'|
Variable_name	Value
Qcache_hits	0
call bug3583()|
id	data
x	3
y	5
c
2
call bug3583()|
id	data
x	3
y	5
c
2
show status like 'Qcache_hits'|
Variable_name	Value
Qcache_hits	2
set global query_cache_size = @x|
flush status|
flush query cache|
delete from t1|
drop procedure bug3583|
drop table if exists t3|
drop procedure if exists bug4905|
create table t3 (s1 int,primary key (s1))|
drop procedure if exists bug4905|
create procedure bug4905()
begin
declare v int;
declare continue handler for sqlstate '23000' set v = 5;
insert into t3 values (1);
end|
call bug4905()|
select row_count()|
row_count()
1
call bug4905()|
select row_count()|
row_count()
0
call bug4905()|
select row_count()|
row_count()
0
select * from t3|
s1
1
drop procedure bug4905|
drop table t3|
drop function if exists bug6022|
drop function if exists bug6022|
create function bug6022(x int) returns int
begin
if x < 0 then
return 0;
else
return bug6022(x-1);
end if;
end|
select bug6022(5)|
bug6022(5)
0
drop function bug6022|
drop procedure if exists bug6029|
drop procedure if exists bug6029|
create procedure bug6029()
begin
declare exit handler for 1136  select '1136';
declare exit handler for sqlstate '23000'  select 'sqlstate 23000';
declare continue handler for sqlexception  select 'sqlexception';
insert into t3 values (1);
insert into t3 values (1,2);
end|
create table t3 (s1 int, primary key (s1))|
insert into t3 values (1)|
call bug6029()|
sqlstate 23000
sqlstate 23000
delete from t3|
call bug6029()|
1136
1136
drop procedure bug6029|
drop table t3|
drop procedure if exists bug8540|
create procedure bug8540()
begin
declare x int default 1;
select x as y, x+0 as z;
end|
call bug8540()|
y	z
1	1
drop procedure bug8540|
drop table if exists t3|
create table t3 (s1 int)|
drop procedure if exists bug6642|
create procedure bug6642()
select abs(count(s1)) from t3|
call bug6642()|
abs(count(s1))
0
call bug6642()|
abs(count(s1))
0
drop procedure bug6642|
insert into t3 values (0),(1)|
drop procedure if exists bug7013|
create procedure bug7013()
select s1,count(s1) from t3 group by s1 with rollup|
call bug7013()|
s1	count(s1)
0	1
1	1
NULL	2
call bug7013()|
s1	count(s1)
0	1
1	1
NULL	2
drop procedure bug7013|
drop table if exists t4|
create table t4 (
a mediumint(8) unsigned not null auto_increment,
b smallint(5) unsigned not null,
c char(32) not null,
primary key  (a)
) engine=myisam default charset=latin1|
insert into t4 values (1, 2, 'oneword')|
insert into t4 values (2, 2, 'anotherword')|
drop procedure if exists bug7743|
create procedure bug7743 ( searchstring char(28) )
begin
declare var mediumint(8) unsigned;
select a into var from t4 where b = 2 and c = binary searchstring limit 1;
select var;
end|
call bug7743("oneword")|
var
1
call bug7743("OneWord")|
var
NULL
Warnings:
Warning	1329	No data to FETCH
call bug7743("anotherword")|
var
2
call bug7743("AnotherWord")|
var
NULL
Warnings:
Warning	1329	No data to FETCH
drop procedure bug7743|
drop table t4|
delete from t3|
insert into t3 values(1)|
drop procedure if exists bug7992_1|
Warnings:
Note	1305	PROCEDURE bug7992_1 does not exist
drop procedure if exists bug7992_2|
Warnings:
Note	1305	PROCEDURE bug7992_2 does not exist
create procedure bug7992_1()
begin
declare i int;
select max(s1)+1 into i from t3;
end|
create procedure bug7992_2()
insert into t3 (s1) select max(t4.s1)+1 from t3 as t4|
call bug7992_1()|
call bug7992_1()|
call bug7992_2()|
call bug7992_2()|
drop procedure bug7992_1|
drop procedure bug7992_2|
drop table t3|
drop table if exists t3|
create table t3 (  userid bigint(20) not null default 0 )|
drop procedure if exists bug8116|
create procedure bug8116(in _userid int)
select * from t3 where userid = _userid|
call bug8116(42)|
userid
call bug8116(42)|
userid
drop procedure bug8116|
drop table t3|
drop procedure if exists bug6857|
create procedure bug6857(counter int)
begin
declare t0, t1 int;
declare plus bool default 0;
set t0 = current_time();
while counter > 0 do
set counter = counter - 1;
end while;
set t1 = current_time();
if t1 > t0 then
set plus = 1;
end if;
select plus;
end|
drop procedure bug6857|
drop procedure if exists bug8757|
create procedure bug8757()
begin
declare x int;
declare c1 cursor for select data from t1 limit 1;
begin
declare y int;
declare c2 cursor for select i from t2 limit 1;
open c2;
fetch c2 into y;
close c2;
select 2,y;
end;
open c1;
fetch c1 into x;
close c1;
select 1,x;
end|
delete from t1|
delete from t2|
insert into t1 values ("x", 1)|
insert into t2 values ("y", 2, 0.0)|
call bug8757()|
2	y
2	2
1	x
1	1
delete from t1|
delete from t2|
drop procedure bug8757|
drop procedure if exists bug8762|
drop procedure if exists bug8762; create procedure bug8762() begin end|
drop procedure if exists bug8762; create procedure bug8762() begin end|
drop procedure bug8762|
drop function if exists bug5240|
create function bug5240 () returns int
begin
declare x int;
declare c cursor for select data from t1 limit 1;
open c;
fetch c into x;
close c;
return x;
end|
delete from t1|
insert into t1 values ("answer", 42)|
select id, bug5240() from t1|
id	bug5240()
answer	42
drop function bug5240|
drop function if exists bug5278|
create function bug5278 () returns char
begin
SET PASSWORD FOR 'bob'@'%.loc.gov' = PASSWORD('newpass');
return 'okay';
end|
select bug5278()|
ERROR 42000: Can't find any matching row in the user table
select bug5278()|
ERROR 42000: Can't find any matching row in the user table
drop function bug5278|
drop procedure if exists p1|
create table t3(id int)|
insert into t3 values(1)|
create procedure bug7992()
begin
declare i int;
select max(id)+1 into i from t3;
end|
call bug7992()|
call bug7992()|
drop procedure bug7992|
drop table t3|
create table t3 (
lpitnumber int(11) default null,
lrecordtype int(11) default null
)|
create table t4 (
lbsiid int(11) not null default '0',
ltradingmodeid int(11) not null default '0',
ltradingareaid int(11) not null default '0',
csellingprice decimal(19,4) default null,
primary key  (lbsiid,ltradingmodeid,ltradingareaid)
)|
create table t5 (
lbsiid int(11) not null default '0',
ltradingareaid int(11) not null default '0',
primary key  (lbsiid,ltradingareaid)
)|
drop procedure if exists bug8849|
create procedure bug8849()
begin
insert into t5
(
t5.lbsiid,
t5.ltradingareaid
)
select distinct t3.lpitnumber, t4.ltradingareaid
from
t4 join t3 on
t3.lpitnumber = t4.lbsiid
and t3.lrecordtype = 1
left join t4 as price01 on
price01.lbsiid = t4.lbsiid and
price01.ltradingmodeid = 1 and
t4.ltradingareaid = price01.ltradingareaid;
end|
call bug8849()|
call bug8849()|
call bug8849()|
drop procedure bug8849|
drop tables t3,t4,t5|
drop procedure if exists bug8937|
create procedure bug8937()
begin
declare s,x,y,z int;
declare a float;
select sum(data),avg(data),min(data),max(data) into s,x,y,z from t1;
select s,x,y,z;
select avg(data) into a from t1;
select a;
end|
delete from t1|
insert into t1 (data) values (1), (2), (3), (4), (6)|
call bug8937()|
s	x	y	z
16	3	1	6
a
3.2000
drop procedure bug8937|
delete from t1|
drop procedure if exists bug6900|
drop procedure if exists bug9074|
drop procedure if exists bug6900_9074|
drop table if exists t3|
create table t3 (w char unique, x char)|
insert into t3 values ('a', 'b')|
create procedure bug6900()
begin
declare exit handler for sqlexception select '1';
begin
declare exit handler for sqlexception select '2';
insert into t3 values ('x', 'y', 'z');
end;
end|
create procedure bug9074()
begin
declare x1, x2, x3, x4, x5, x6 int default 0;
begin    
declare continue handler for sqlstate '23000' set x5 = 1;      
insert into t3 values ('a', 'b');      
set x6 = 1;      
end;
begin1_label:
begin
declare continue handler for sqlstate '23000' set x1 = 1;      
insert into t3 values ('a', 'b');      
set x2 = 1;      
begin2_label:
begin  
declare exit handler for sqlstate '23000' set x3 = 1;         
set x4= 1;         
insert into t3 values ('a','b');
set x4= 0;
end begin2_label;
end begin1_label;
select x1, x2, x3, x4, x5, x6;
end|
create procedure bug6900_9074(z int)
begin
declare exit handler for sqlstate '23000' select '23000';
begin
declare exit handler for sqlexception select 'sqlexception';
if z = 1 then
insert into t3 values ('a', 'b');
else
insert into t3 values ('x', 'y', 'z');
end if;
end;
end|
call bug6900()|
2
2
call bug9074()|
x1	x2	x3	x4	x5	x6
1	1	1	1	1	1
call bug6900_9074(0)|
sqlexception
sqlexception
call bug6900_9074(1)|
23000
23000
drop procedure bug6900|
drop procedure bug9074|
drop procedure bug6900_9074|
drop table t3|
drop procedure if exists avg|
create procedure avg ()
begin
end|
call avg ()|
drop procedure avg|
drop procedure if exists bug6129|
set @@sql_mode = 'traditional'|
create procedure bug6129(mode text)
select @@sql_mode = mode|
call bug6129(@@sql_mode)|
@@sql_mode = mode
1
set @@sql_mode = ''|
call bug6129(@@sql_mode)|
@@sql_mode = mode
0
drop procedure bug6129|
drop procedure if exists bug9856|
create procedure bug9856()
begin
declare v int;
declare c cursor for select data from t1;
declare exit handler for sqlexception, not found select '16';
open c;
fetch c into v;
select v;
end|
delete from t1|
call bug9856()|
16
16
call bug9856()|
16
16
drop procedure bug9856|
drop procedure if exists bug9674_1|
drop procedure if exists bug9674_2|
create procedure bug9674_1(out arg int)
begin
declare temp_in1 int default 0;
declare temp_fl1 int default 0;
set temp_in1 = 100;
set temp_fl1 = temp_in1/10;
set arg = temp_fl1;
end|
create procedure bug9674_2()
begin
declare v int default 100;
select v/10;
end|
call bug9674_1(@sptmp)|
call bug9674_1(@sptmp)|
select @sptmp|
@sptmp
10
call bug9674_2()|
v/10
10.0000
call bug9674_2()|
v/10
10.0000
drop procedure bug9674_1|
drop procedure bug9674_2|
drop procedure if exists bug9598_1|
drop procedure if exists bug9598_2|
create procedure bug9598_1(in var_1 char(16),
out var_2 integer, out var_3 integer)
begin
set var_2 = 50;
set var_3 = 60;
end|
create procedure bug9598_2(in v1 char(16),
in v2 integer,
in v3 integer,
in v4 integer,
in v5 integer)
begin
select v1,v2,v3,v4,v5;
call bug9598_1(v1,@tmp1,@tmp2);
select v1,v2,v3,v4,v5;
end|
call bug9598_2('Test',2,3,4,5)|
v1	v2	v3	v4	v5
Test	2	3	4	5
v1	v2	v3	v4	v5
Test	2	3	4	5
select @tmp1, @tmp2|
@tmp1	@tmp2
50	60
drop procedure bug9598_1|
drop procedure bug9598_2|
drop procedure if exists bug9902|
create function bug9902() returns int(11)
begin
set @x = @x + 1;
return @x;
end|
set @qcs1 = @@query_cache_size|
set global query_cache_size = 100000|
set @x = 1|
insert into t1 values ("qc", 42)|
select bug9902() from t1|
bug9902()
2
select bug9902() from t1|
bug9902()
3
select @x|
@x
3
set global query_cache_size = @qcs1|
delete from t1|
drop function bug9902|
drop procedure if exists bug6898|
create procedure bug6898()
begin
goto label1;
label label1;
begin end;
goto label1;
end|
drop procedure bug6898|
drop function if exists bug9102|
create function bug9102() returns blob return 'a'|
select bug9102()|
bug9102()
a
drop function bug9102|
drop function if exists bug7648|
create function bug7648() returns bit(8) return 'a'|
select bug7648()|
bug7648()
a
drop function bug7648|
drop function if exists bug9775|
create function bug9775(v1 char(1)) returns enum('a','b') return v1|
select bug9775('a'),bug9775('b'),bug9775('c')|
bug9775('a')	bug9775('b')	bug9775('c')
a	b	
drop function bug9775|
create function bug9775(v1 int) returns enum('a','b') return v1|
select bug9775(1),bug9775(2),bug9775(3)|
bug9775(1)	bug9775(2)	bug9775(3)
a	b	
drop function bug9775|
create function bug9775(v1 char(1)) returns set('a','b') return v1|
select bug9775('a'),bug9775('b'),bug9775('a,b'),bug9775('c')|
bug9775('a')	bug9775('b')	bug9775('a,b')	bug9775('c')
a	b	a,b	
drop function bug9775|
create function bug9775(v1 int) returns set('a','b') return v1|
select bug9775(1),bug9775(2),bug9775(3),bug9775(4)|
bug9775(1)	bug9775(2)	bug9775(3)	bug9775(4)
a	b	a,b	
drop function bug9775|
drop function if exists bug8861|
create function bug8861(v1 int) returns year return v1|
select bug8861(05)|
bug8861(05)
2005
set @x = bug8861(05)|
select @x|
@x
2005
drop function bug8861|
drop procedure if exists bug9004_1|
drop procedure if exists bug9004_2|
create procedure bug9004_1(x char(16))
begin
insert into t1 values (x, 42);
insert into t1 values (x, 17);
end|
create procedure bug9004_2(x char(16))
call bug9004_1(x)|
call bug9004_1('12345678901234567')|
Warnings:
Warning	1265	Data truncated for column 'id' at row 1
Warning	1265	Data truncated for column 'id' at row 2
call bug9004_2('12345678901234567890')|
Warnings:
Warning	1265	Data truncated for column 'id' at row 1
Warning	1265	Data truncated for column 'id' at row 2
delete from t1|
drop procedure bug9004_1|
drop procedure bug9004_2|
drop procedure if exists bug7293|
insert into t1 values ('secret', 0)|
create procedure bug7293(p1 varchar(100))
begin
if exists (select id from t1 where soundex(p1)=soundex(id)) then
select 'yes';
end if;
end;|
call bug7293('secret')|
yes
yes
call bug7293 ('secrete')|
yes
yes
drop procedure bug7293|
delete from t1|
drop procedure if exists bug9841|
drop view if exists v1|
create view v1 as select * from t1, t2 where id = s|
create procedure bug9841 ()
update v1 set data = 10|
call bug9841()|
drop view v1|
drop procedure bug9841|
drop procedure if exists bug5963|
create procedure bug5963_1 () begin declare v int; set v = (select s1 from t3); select v; end;|
create table t3 (s1 int)|
insert into t3 values (5)|
call bug5963_1()|
v
5
call bug5963_1()|
v
5
drop procedure bug5963_1|
drop table t3|
create procedure bug5963_2 (cfk_value int) 
begin 
if cfk_value in (select cpk from t3) then 
set @x = 5; 
end if; 
end; 
|
create table t3 (cpk int)|
insert into t3 values (1)|
call bug5963_2(1)|
call bug5963_2(1)|
drop procedure bug5963_2|
drop table t3|
drop function if exists bug9559|
create function bug9559()
returns int
begin
set @y = -6/2;
return @y;
end|
select bug9559()|
bug9559()
-3
drop function bug9559|
drop procedure if exists bug10961|
create procedure bug10961()
begin
declare v char;
declare x int;
declare c cursor for select * from dual;
declare continue handler for sqlexception select x;
set x = 1;
open c;
set x = 2;
fetch c into v;
set x = 3;
close c;
end|
call bug10961()|
x
1
x
2
x
3
call bug10961()|
x
1
x
2
x
3
drop procedure bug10961|
DROP PROCEDURE IF EXISTS bug6866|
DROP VIEW IF EXISTS tv|
Warnings:
Note	1051	Unknown table 'test.tv'
DROP TABLE IF EXISTS tt1,tt2,tt3|
Warnings:
Note	1051	Unknown table 'tt1'
Note	1051	Unknown table 'tt2'
Note	1051	Unknown table 'tt3'
CREATE TABLE tt1 (a1 int, a2 int, a3 int, data varchar(10))|
CREATE TABLE tt2 (a2 int, data2 varchar(10))|
CREATE TABLE tt3 (a3 int, data3 varchar(10))|
INSERT INTO tt1 VALUES (1, 1, 4, 'xx')|
INSERT INTO tt2 VALUES (1, 'a')|
INSERT INTO tt2 VALUES (2, 'b')|
INSERT INTO tt2 VALUES (3, 'c')|
INSERT INTO tt3 VALUES (4, 'd')|
INSERT INTO tt3 VALUES (5, 'e')|
INSERT INTO tt3 VALUES (6, 'f')|
CREATE VIEW tv AS
SELECT tt1.*, tt2.data2, tt3.data3
FROM tt1 INNER JOIN tt2 ON tt1.a2 = tt2.a2
LEFT JOIN tt3 ON tt1.a3 = tt3.a3
ORDER BY tt1.a1, tt2.a2, tt3.a3|
CREATE PROCEDURE bug6866 (_a1 int)
BEGIN
SELECT * FROM tv WHERE a1 = _a1;
END|
CALL bug6866(1)|
a1	a2	a3	data	data2	data3
1	1	4	xx	a	d
CALL bug6866(1)|
a1	a2	a3	data	data2	data3
1	1	4	xx	a	d
CALL bug6866(1)|
a1	a2	a3	data	data2	data3
1	1	4	xx	a	d
DROP PROCEDURE bug6866;
DROP VIEW tv|
DROP TABLE tt1, tt2, tt3|
DROP PROCEDURE IF EXISTS bug10136|
create table t3 ( name char(5) not null primary key, val float not null)|
insert into t3 values ('aaaaa', 1), ('bbbbb', 2), ('ccccc', 3)|
create procedure bug10136()
begin
declare done int default 3;
repeat
select * from t3;
set done = done - 1;
until done <= 0 end repeat;
end|
call bug10136()|
name	val
aaaaa	1
bbbbb	2
ccccc	3
name	val
aaaaa	1
bbbbb	2
ccccc	3
name	val
aaaaa	1
bbbbb	2
ccccc	3
call bug10136()|
name	val
aaaaa	1
bbbbb	2
ccccc	3
name	val
aaaaa	1
bbbbb	2
ccccc	3
name	val
aaaaa	1
bbbbb	2
ccccc	3
call bug10136()|
name	val
aaaaa	1
bbbbb	2
ccccc	3
name	val
aaaaa	1
bbbbb	2
ccccc	3
name	val
aaaaa	1
bbbbb	2
ccccc	3
drop procedure bug10136|
drop table t3|
drop procedure if exists bug11529|
create procedure bug11529()
begin
declare c cursor for select id, data from t1 where data in (10,13);
open c;
begin
declare vid char(16);
declare vdata int;
declare exit handler for not found begin end;
while true do
fetch c into vid, vdata;
end while;
end;
close c;
end|
insert into t1 values
('Name1', 10),
('Name2', 11),
('Name3', 12),
('Name4', 13),
('Name5', 14)|
call bug11529()|
call bug11529()|
delete from t1|
drop procedure bug11529|
drop table t1,t2;
