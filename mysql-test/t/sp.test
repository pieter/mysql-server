#
# Basic stored PROCEDURE tests
#
#

use test;

--disable_warnings
drop table if exists t1;
--enable_warnings

create table t1 (
	id   char(16) not null,
        data int not null
);

# Single statement, no params.
create procedure foo42()
  insert into test.t1 values ("foo", 42);

# Single statement, two IN params.
create procedure bar(x char(16), y int)
  insert into test.t1 values (x, y);

# Now for multiple statements...

delimiter |;

# Two statements.
create procedure two(x1 char(16), x2 char(16), y int)
begin
  insert into test.t1 values (x1, y);
  insert into test.t1 values (x2, y);
end|

# Simple test of local variables and SET.
create procedure locset(x char(16), y int)
begin
  declare z1, z2 int;
  set z1 = y;
  set z2 = z1+2;
  insert into test.t1 values (x, z2);
end|

# The peculiar (non-standard) mixture of variables types in SET.
create procedure mixset(x char(16), y int)
begin
  declare z int;

  set @z = y, z = 666, max_join_size = 100;
  insert into test.t1 values (x, z);
end|

# Multiple CALL statements, one with OUT parameter.
create procedure zip(x char(16), y int)
begin
  declare z int;
  call zap(y, z);
  call bar(x, z);
end|

# SET local variables and OUT parameter.
create procedure zap(x int, out y int)
begin
  declare z int;
  set z = x+1, y = z;
end|


# INOUT test
create procedure iotest(x1 char(16), x2 char(16), y int)
begin
  call inc2(x2, y);
  insert into test.t1 values (x1, y);
end|

create procedure inc2(x char(16), y int)
begin
  call inc(y);
  insert into test.t1 values (x, y);
end|

create procedure inc(inout io int)
  set io = io + 1|


# Call-by-value test
#  The expected result is:
#    ("cbv2", 4)
#    ("cbv1", 4711)
create procedure cbv1()
begin
  declare y int;

  set y = 3;
  call cbv2(y+1, y);
  insert into test.t1 values ("cbv1", y);
end|

create procedure cbv2(y1 int, inout y2 int)
begin
  set y2 = 4711;
  insert into test.t1 values ("cbv2", y1);
end|


# Minimal tests of the flow control construts

# Just test on 'x'...
create procedure a0(x int)
while x do
  set x = x-1;
  insert into test.t1 values ("a0", x);
end while|

# The same, but with a more traditional test.
create procedure a(x int)
while x > 0 do
  set x = x-1;
  insert into test.t1 values ("a", x);
end while|

# REPEAT
create procedure b(x int)
sprepeat
  insert into test.t1 values ("b", x);
  set x = x-1;
until x = 0 end sprepeat|

# Labelled WHILE with ITERATE (pointless really)
create procedure c(x int)
hmm: while x > 0 do
  insert into test.t1 values ("c", x);
  set x = x-1;
  iterate hmm;
  insert into test.t1 values ("x", x);
end while hmm|

# Labelled WHILE with LEAVE
create procedure d(x int)
hmm: while x > 0 do
  insert into test.t1 values ("d", x);
  set x = x-1;
  leave hmm;
  insert into test.t1 values ("x", x);
end while hmm|

# LOOP, with simple IF statement
create procedure e(x int)
foo: loop
  if x = 0 then
    leave foo;
  end if;
  insert into test.t1 values ("e", x);
  set x = x-1;
end loop foo|

# A full IF statement
create procedure f(x int)
if x < 0 then
  insert into test.t1 values ("f", 0);
elseif x = 0 then
  insert into test.t1 values ("f", 1);
else
  insert into test.t1 values ("f", 2);
end if|

# This form of CASE is really just syntactic sugar for IF-ELSEIF-...
create procedure g(x int)
case
when x < 0 then
  insert into test.t1 values ("g", 0);
when x = 0 then
  insert into test.t1 values ("g", 1);
else
  insert into test.t1 values ("g", 2);
end case|

# The "simple CASE"
create procedure h(x int)
case x
when 0 then
  insert into test.t1 values ("h0", x);
when 1 then
  insert into test.t1 values ("h1", x);
else
  insert into test.t1 values ("h?", x);
end case|

create procedure into_test()
begin
  declare x char(16);
  declare y int;
  set x="aaaaa";
  set y=22;
  select id,data into x,y from test.t1 limit 2,1;
  insert into test.t1 values (x, y);
end|

delimiter ;|

# Now, the CALL tests...
call foo42();
select * from t1;
delete from t1;

call bar("bar", 666);
select * from t1;
delete from t1;

call two("one", "two", 3);
select * from t1;
delete from t1;

call locset("locset", 19);
select * from t1;
delete from t1;

call mixset("mixset", 19);
show variables like 'max_join_size';
select id,data,@z from t1;
delete from t1;

call zip("zip", 99);
select * from t1;
delete from t1;

call iotest("io1", "io2", 1);
select * from t1;
delete from t1;

call cbv1();
select * from t1;
delete from t1;

call a0(3);
select * from t1;
delete from t1;

call a(3);
select * from t1;
delete from t1;

call b(3);
select * from t1;
delete from t1;

call c(3);
select * from t1;
delete from t1;

call d(3);
select * from t1;
delete from t1;

call e(3);
select * from t1;
delete from t1;

call f(-2);
call f(0);
call f(4);
select * from t1;
delete from t1;

call g(-42);
call g(0);
call g(1);
select * from t1;
delete from t1;

call h(0);
call h(1);
call h(17);
select * from t1;
call into_test();
select * from t1;
delete from t1;

drop procedure foo42;
drop procedure bar;
drop procedure two;
drop procedure locset;
drop procedure mixset;
drop procedure zip;
drop procedure zap;
drop procedure iotest;
drop procedure inc2;
drop procedure inc;
drop procedure cbv1;
drop procedure cbv2;
drop procedure a0;
drop procedure a;
drop procedure b;
drop procedure c;
drop procedure d;
drop procedure e;
drop procedure f;
drop procedure g;
drop procedure h;
drop procedure into_test;

drop table t1;
