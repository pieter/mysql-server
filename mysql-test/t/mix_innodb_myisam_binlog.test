# Check that binlog is ok when a transaction mixes updates to InnoDB and
# MyISAM. It would be nice to make this a replication test, but in 4.0 the slave
# is always with --skip-innodb in the testsuite. I (Guilhem) however did some
# tests manually on a slave; tables are replicated fine and Exec_master_log_pos
# advances as expected.

-- source include/have_innodb.inc

connect (con1,localhost,root,,);
connect (con2,localhost,root,,);

connection con1;

drop table if exists ti, tm;
create table ti (a int) type=innodb;
create table tm (a int) type=myisam;

reset master;

begin;
insert into ti values(1);
insert into tm select * from ti;
commit;

show binlog events from 79;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(2);
insert into tm select * from ti;
# should say some changes to non-transactional tables couldn't be rolled back
--error 1196
rollback;

show binlog events from 79;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(3);
savepoint my_savepoint;
insert into ti values(4);
insert into tm select * from ti;
--error 1196
rollback to savepoint my_savepoint;
commit;

show binlog events from 79;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(5);
savepoint my_savepoint;
insert into ti values(6);
insert into tm select * from ti;
--error 1196
rollback to savepoint my_savepoint;
insert into ti values(7);
commit;
select a from ti order by a; # check that savepoints work :)

show binlog events from 79;

# and when ROLLBACK is not explicit?
delete from ti;
delete from tm;
reset master;

select get_lock("a",10);
begin;
insert into ti values(8);
insert into tm select * from ti;
disconnect con1;

connection con2;
# We want to SHOW BINLOG EVENTS, to know what was logged. But there is no
# guarantee that logging of the terminated con1 has been done yet (it may not
# even be started, so con1 may have not even attempted to lock the binlog yet;
# so SHOW BINLOG EVENTS may come before con1 does the loggin. To be sure that
# logging has been done, we use a user lock.
select get_lock("a",10);
show binlog events from 79;

# and when not in a transaction?
delete from ti;
delete from tm;
reset master;

insert into ti values(9);
insert into tm select * from ti;

show binlog events from 79;

# Check that when the query updating the MyISAM table is the first in the
# transaction, we log it immediately.
delete from ti;
delete from tm;
reset master;

insert into ti values(10); # first make ti non-empty
begin;
insert into tm select * from ti;
show binlog events from 79;
insert into ti values(11);
commit;

show binlog events from 79;


# Check that things work like before this BEGIN/ROLLBACK code was added, when tm
# is INNODB 

alter table tm type=INNODB;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(12);
insert into tm select * from ti;
commit;

show binlog events from 79;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(13);
insert into tm select * from ti;
rollback;

show binlog events from 79;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(14);
savepoint my_savepoint;
insert into ti values(15);
insert into tm select * from ti;
rollback to savepoint my_savepoint;
commit;

show binlog events from 79;

delete from ti;
delete from tm;
reset master;

begin;
insert into ti values(16);
savepoint my_savepoint;
insert into ti values(17);
insert into tm select * from ti;
rollback to savepoint my_savepoint;
insert into ti values(18);
commit;
select a from ti order by a; # check that savepoints work :)

show binlog events from 79;

drop table ti,tm;
