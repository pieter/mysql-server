use test;
drop table if exists t1;
drop table if exists t2;
create table t1 (
id   char(16) not null,
data int not null
);
create table t2 (
s   char(16) not null,
i   int not null,
d   double not null
);
create procedure foo42()
insert into test.t1 values ("foo", 42);
call foo42();
select * from t1;
id	data
foo	42
delete from t1;
drop procedure foo42;
create procedure u()
use sptmp;
drop database if exists sptmp;
create database sptmp;
use test;
call u();
select database();
database()
test
drop database sptmp;
drop procedure u;
create procedure bar(x char(16), y int)
insert into test.t1 values (x, y);
call bar("bar", 666);
select * from t1;
id	data
bar	666
delete from t1;
create procedure empty()
begin
end;
call empty();
drop procedure empty;
create procedure scope(a int, b float)
begin
declare b int;
declare c float;
begin
declare c int;
end;
end;
drop procedure scope;
create procedure two(x1 char(16), x2 char(16), y int)
begin
insert into test.t1 values (x1, y);
insert into test.t1 values (x2, y);
end;
call two("one", "two", 3);
select * from t1;
id	data
one	3
two	3
delete from t1;
drop procedure two;
create procedure locset(x char(16), y int)
begin
declare z1, z2 int;
set z1 = y;
set z2 = z1+2;
insert into test.t1 values (x, z2);
end;
call locset("locset", 19);
select * from t1;
id	data
locset	21
delete from t1;
drop procedure locset;
create procedure mixset(x char(16), y int)
begin
declare z int;
set @z = y, z = 666, max_join_size = 100;
insert into test.t1 values (x, z);
end;
call mixset("mixset", 19);
show variables like 'max_join_size';
Variable_name	Value
max_join_size	100
select id,data,@z from t1;
id	data	@z
mixset	666	19
delete from t1;
drop procedure mixset;
create procedure zip(x char(16), y int)
begin
declare z int;
call zap(y, z);
call bar(x, z);
end;
create procedure zap(x int, out y int)
begin
declare z int;
set z = x+1, y = z;
end;
call zip("zip", 99);
select * from t1;
id	data
zip	100
delete from t1;
drop procedure zip;
drop procedure bar;
call zap(7, @zap);
select @zap;
@zap
8
drop procedure zap;
create procedure c1(x int)
call c2("c", x);
create procedure c2(s char(16), x int)
call c3(x, s);
create procedure c3(x int, s char(16))
call c4("level", x, s);
create procedure c4(l char(8), x int, s char(16))
insert into t1 values (concat(l,s), x);
call c1(42);
select * from t1;
id	data
levelc	42
delete from t1;
drop procedure c1;
drop procedure c2;
drop procedure c3;
drop procedure c4;
create procedure iotest(x1 char(16), x2 char(16), y int)
begin
call inc2(x2, y);
insert into test.t1 values (x1, y);
end;
create procedure inc2(x char(16), y int)
begin
call inc(y);
insert into test.t1 values (x, y);
end;
create procedure inc(inout io int)
set io = io + 1;
call iotest("io1", "io2", 1);
select * from t1;
id	data
io2	2
io1	1
delete from t1;
drop procedure iotest;
drop procedure inc2;
create procedure incr(inout x int)
call inc(x);
select @zap;
@zap
8
call incr(@zap);
select @zap;
@zap
9
drop procedure inc;
drop procedure incr;
create procedure cbv1()
begin
declare y int default 3;
call cbv2(y+1, y);
insert into test.t1 values ("cbv1", y);
end;
create procedure cbv2(y1 int, inout y2 int)
begin
set y2 = 4711;
insert into test.t1 values ("cbv2", y1);
end;
call cbv1();
select * from t1;
id	data
cbv2	4
cbv1	4711
delete from t1;
drop procedure cbv1;
drop procedure cbv2;
insert into t2 values ("a", 1, 1.1), ("b", 2, 1.2), ("c", 3, 1.3);
create procedure sub1(id char(16), x int)
insert into test.t1 values (id, x);
create function sub3(i int) returns int
return i+1;
call sub1("sub1a", (select 7));
call sub1("sub1b", (select max(i) from t2));
call sub1("sub1c", (select i,d from t2 limit 1));
call sub1("sub1d", (select 1 from (select 1) a));
select * from t1;
id	data
sub1a	7
sub1b	3
sub1c	1
sub1d	1
select sub3((select max(i) from t2));
sub3((select max(i) from t2))
4
drop procedure sub1;
drop function sub3;
create procedure a0(x int)
while x do
set x = x-1;
insert into test.t1 values ("a0", x);
end while;
call a0(3);
select * from t1;
id	data
sub1a	7
sub1b	3
sub1c	1
sub1d	1
a0	2
a0	1
a0	0
delete from t1;
drop procedure a0;
create procedure a(x int)
while x > 0 do
set x = x-1;
insert into test.t1 values ("a", x);
end while;
call a(3);
select * from t1;
id	data
a	2
a	1
a	0
delete from t1;
drop procedure a;
create procedure b(x int)
repeat
insert into test.t1 values (repeat("b",3), x);
set x = x-1;
until x = 0 end repeat;
call b(3);
select * from t1;
id	data
bbb	3
bbb	2
bbb	1
delete from t1;
drop procedure b;
create procedure b2(x int)
repeat(select 1 into outfile 'b2');
insert into test.t1 values (repeat("b2",3), x);
set x = x-1;
until x = 0 end repeat;
drop procedure b2;
create procedure c(x int)
hmm: while x > 0 do
insert into test.t1 values ("c", x);
set x = x-1;
iterate hmm;
insert into test.t1 values ("x", x);
end while hmm;
call c(3);
select * from t1;
id	data
c	3
c	2
c	1
delete from t1;
drop procedure c;
create procedure d(x int)
hmm: while x > 0 do
insert into test.t1 values ("d", x);
set x = x-1;
leave hmm;
insert into test.t1 values ("x", x);
end while;
call d(3);
select * from t1;
id	data
d	3
delete from t1;
drop procedure d;
create procedure e(x int)
foo: loop
if x = 0 then
leave foo;
end if;
insert into test.t1 values ("e", x);
set x = x-1;
end loop foo;
call e(3);
select * from t1;
id	data
e	3
e	2
e	1
delete from t1;
drop procedure e;
create procedure f(x int)
if x < 0 then
insert into test.t1 values ("f", 0);
elseif x = 0 then
insert into test.t1 values ("f", 1);
else
insert into test.t1 values ("f", 2);
end if;
call f(-2);
call f(0);
call f(4);
select * from t1;
id	data
f	0
f	1
f	2
delete from t1;
drop procedure f;
create procedure g(x int)
case
when x < 0 then
insert into test.t1 values ("g", 0);
when x = 0 then
insert into test.t1 values ("g", 1);
else
insert into test.t1 values ("g", 2);
end case;
call g(-42);
call g(0);
call g(1);
select * from t1;
id	data
g	0
g	1
g	2
delete from t1;
drop procedure g;
create procedure h(x int)
case x
when 0 then
insert into test.t1 values ("h0", x);
when 1 then
insert into test.t1 values ("h1", x);
else
insert into test.t1 values ("h?", x);
end case;
call h(0);
call h(1);
call h(17);
select * from t1;
id	data
h0	0
h1	1
h?	17
delete from t1;
drop procedure h;
create procedure i(x int)
foo:
begin
if x = 0 then
leave foo;
end if;
insert into test.t1 values ("i", x);
end foo;
call i(0);
call i(3);
select * from t1;
id	data
i	3
delete from t1;
drop procedure i;
create procedure into_test(x char(16), y int)
begin
insert into test.t1 values (x, y);
select id,data into x,y from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end;
call into_test("into", 100);
select * from t1;
id	data
into	100
into2	102
delete from t1;
drop procedure into_test;
create procedure into_test2(x char(16), y int)
begin
insert into test.t1 values (x, y);
select id,data into x,@z from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end;
call into_test2("into", 100);
select id,data,@z from t1;
id	data	@z
into	100	100
into2	102	100
delete from t1;
drop procedure into_test2;
create procedure into_outfile(x char(16), y int)
begin
insert into test.t1 values (x, y);
select * into outfile "/tmp/spout" from test.t1;
insert into test.t1 values (concat(x, "2"), y+2);
end;
call into_outfile("ofile", 1);
delete from t1;
drop procedure into_outfile;
create procedure into_dumpfile(x char(16), y int)
begin
insert into test.t1 values (x, y);
select * into dumpfile "/tmp/spdump" from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end;
call into_dumpfile("dfile", 1);
delete from t1;
drop procedure into_dumpfile;
create procedure create_select(x char(16), y int)
begin
insert into test.t1 values (x, y);
create table test.t3 select * from test.t1;
insert into test.t3 values (concat(x, "2"), y+2);
end;
drop table if exists t3;
call create_select("cs", 90);
select * from t1, t3;
id	data	id	data
cs	90	cs	90
cs	90	cs2	92
drop table if exists t3;
delete from t1;
drop procedure create_select;
create function e() returns double
return 2.7182818284590452354;
set @e = e();
select e(), @e;
e()	@e
2.718281828459	2.718281828459
create function inc(i int) returns int
return i+1;
select inc(1), inc(99), inc(-71);
inc(1)	inc(99)	inc(-71)
2	100	-70
create function mul(x int, y int) returns int
return x*y;
select mul(1,1), mul(3,5), mul(4711, 666);
mul(1,1)	mul(3,5)	mul(4711, 666)
1	15	3137526
create function append(s1 char(8), s2 char(8)) returns char(16)
return concat(s1, s2);
select append("foo", "bar");
append("foo", "bar")
foobar
create function fac(n int unsigned) returns bigint unsigned
begin
declare f bigint unsigned default 1;
while n > 1 do
set f = f * n;
set n = n - 1;
end while;
return f;
end;
select fac(1), fac(2), fac(5), fac(10);
fac(1)	fac(2)	fac(5)	fac(10)
1	2	120	3628800
create function fun(d double, i int, u int unsigned) returns double
return mul(inc(i), fac(u)) / e();
select fun(2.3, 3, 5);
fun(2.3, 3, 5)
176.58213176229
insert into t2 values (append("xxx", "yyy"), mul(4,3), e());
insert into t2 values (append("a", "b"), mul(2,mul(3,4)), fun(1.7, 4, 6));
select * from t2 where s = append("a", "b");
s	i	d
ab	24	1324.36598821719
select * from t2 where i = mul(4,3) or i = mul(mul(3,4),2);
s	i	d
xxxyyy	12	2.71828182845905
ab	24	1324.36598821719
select * from t2 where d = e();
s	i	d
xxxyyy	12	2.71828182845905
select * from t2;
s	i	d
a	1	1.1
b	2	1.2
c	3	1.3
xxxyyy	12	2.71828182845905
ab	24	1324.36598821719
delete from t2;
drop function e;
drop function inc;
drop function mul;
drop function append;
drop function fun;
create procedure hndlr1(val int)
begin
declare x int default 0;
declare foo condition for 1146;
declare bar condition for sqlstate '42S98';        # Just for testing syntax
declare zip condition for sqlstate value '42S99';  # Just for testing syntax
declare continue handler for foo set x = 1;
insert into test.t666 values ("hndlr1", val);   # Non-existing table
if (x) then
insert into test.t1 values ("hndlr1", val);   # This instead then
end if;
end;
call hndlr1(42);
select * from t1;
id	data
hndlr1	42
delete from t1;
drop procedure hndlr1;
create procedure hndlr2(val int)
begin
declare x int default 0;
begin
declare exit handler for sqlstate '42S02' set x = 1;
insert into test.t666 values ("hndlr2", val); # Non-existing table
end;
insert into test.t1 values ("hndlr2", x);
end;
call hndlr2(42);
select * from t1;
id	data
hndlr2	1
delete from t1;
drop procedure hndlr2;
create procedure hndlr3(val int)
begin
declare x int default 0;
declare continue handler for sqlexception        # Any error
begin
declare z int;
set z = 2 * val;
set x = 1;
end;
if val < 10 then
begin
declare y int;
set y = val + 10;
insert into test.t666 values ("hndlr3", y);  # Non-existing table
if x then
insert into test.t1 values ("hndlr3", y);
end if;
end;
end if;
end;
call hndlr3(3);
select * from t1;
id	data
hndlr3	13
delete from t1;
drop procedure hndlr3;
drop table if exists t3;
create table t3 ( id   char(16), data int );
create procedure hndlr4()
begin
declare x int default 0;
declare val int;	                           # No default
declare continue handler for sqlexception set x=1;
select data into val from test.t3 where id='z' limit 1;  # No hits
insert into test.t3 values ('z', val);
end;
call hndlr4();
select * from t3;
id	data
z	NULL
drop table t3;
drop procedure hndlr4;
create procedure cur1()
begin
declare done int default 0;
declare continue handler for 1306 set done = 1;
declare c cursor for select * from test.t2;
declare a char(16);
declare b int;
declare c double;
open c;
repeat
fetch c into a, b, c;
if not done then
insert into test.t1 values (a, b+c);
end if;
until done end repeat;
close c;
end;
insert into t2 values ("foo", 42, -1.9), ("bar", 3, 12.1), ("zap", 666, -3.14);
call cur1();
select * from t1;
id	data
foo	40
bar	15
zap	663
drop procedure cur1;
drop table if exists t3;
create table t3 ( s char(16), i int );
create procedure cur2()
begin
declare done int default 0;
declare continue handler for 1306 set done = 1;
declare c1 cursor for select id,data from test.t1;
declare c2 cursor for select i from test.t2;
open c1;
open c2;
repeat
begin
declare a char(16);
declare b,c int;
fetch c1 into a, b;
fetch c2 into c;
if not done then
if b < c then
insert into test.t3 values (a, b);
else
insert into test.t3 values (a, c);
end if;
end if;
end;
until done end repeat;
close c1;
close c2;
end;
call cur2();
select * from t3;
s	i
foo	40
bar	3
zap	663
delete from t1;
delete from t2;
drop table t3;
drop procedure cur2;
create procedure bug822(a_id char(16), a_data int)
begin
declare n int;
select count(*) into n from t1 where id = a_id and data = a_data;
if n = 0 then
insert into t1 (id, data) values (a_id, a_data);
end if;
end;
call bug822('foo', 42);
call bug822('foo', 42);
call bug822('bar', 666);
select * from t1;
id	data
foo	42
bar	666
delete from t1;
drop procedure bug822;
create procedure bug1495()
begin
declare x int;
select data into x from t1 order by id limit 1;
if x > 10 then
insert into t1 values ("less", x-10);
else
insert into t1 values ("more", x+10);
end if;
end;
insert into t1 values ('foo', 12);
call bug1495();
delete from t1 where id='foo';
insert into t1 values ('bar', 7);
call bug1495();
delete from t1 where id='bar';
select * from t1;
id	data
less	2
more	17
delete from t1;
drop procedure bug1495;
create procedure bug1547(s char(16))
begin
declare x int;
select data into x from t1 where s = id limit 1;
if x > 10 then
insert into t1 values ("less", x-10);
else
insert into t1 values ("more", x+10);
end if;
end;
insert into t1 values ("foo", 12), ("bar", 7);
call bug1547("foo");
call bug1547("bar");
select * from t1;
id	data
foo	12
bar	7
less	2
more	17
delete from t1;
drop procedure bug1547;
drop table if exists t70;
create table t70 (s1 int,s2 int);
insert into t70 values (1,2);
create procedure bug1656(out p1 int, out p2 int)
select * into p1, p1 from t70;
call bug1656(@1, @2);
select @1, @2;
@1	@2
2	NULL
drop table t70;
drop procedure bug1656;
drop table if exists fac;
create table fac (n int unsigned not null primary key, f bigint unsigned);
create procedure ifac(n int unsigned)
begin
declare i int unsigned default 1;
if n > 20 then
set n = 20;		# bigint overflow otherwise
end if;
while i <= n do
begin
insert into test.fac values (i, fac(i));
set i = i + 1;
end;
end while;
end;
call ifac(20);
select * from fac;
n	f
1	1
2	2
3	6
4	24
5	120
6	720
7	5040
8	40320
9	362880
10	3628800
11	39916800
12	479001600
13	6227020800
14	87178291200
15	1307674368000
16	20922789888000
17	355687428096000
18	6402373705728000
19	121645100408832000
20	2432902008176640000
drop table fac;
drop procedure ifac;
drop function fac;
drop table if exists primes;
create table primes (
i int unsigned not null primary key,
p bigint unsigned not null
);
insert into primes values
( 0,   3), ( 1,   5), ( 2,   7), ( 3,  11), ( 4,  13),
( 5,  17), ( 6,  19), ( 7,  23), ( 8,  29), ( 9,  31),
(10,  37), (11,  41), (12,  43), (13,  47), (14,  53),
(15,  59), (16,  61), (17,  67), (18,  71), (19,  73),
(20,  79), (21,  83), (22,  89), (23,  97), (24, 101),
(25, 103), (26, 107), (27, 109), (28, 113), (29, 127),
(30, 131), (31, 137), (32, 139), (33, 149), (34, 151),
(35, 157), (36, 163), (37, 167), (38, 173), (39, 179),
(40, 181), (41, 191), (42, 193), (43, 197), (44, 199);
create procedure opp(n bigint unsigned, out pp bool)
begin
declare r double;
declare b, s bigint unsigned default 0;
set r = sqrt(n);
again:
loop
if s = 45 then
set b = b+200, s = 0;
else
begin
declare p bigint unsigned;
select t.p into p from test.primes t where t.i = s;
if b+p > r then
set pp = 1;
leave again;
end if;
if mod(n, b+p) = 0 then
set pp = 0;
leave again;
end if;
set s = s+1;
end;
end if;
end loop;
end;
create procedure ip(m int unsigned)
begin
declare p bigint unsigned;
declare i int unsigned;
set i=45, p=201;
while i < m do
begin
declare pp bool default 0;
call opp(p, pp);
if pp then
insert into test.primes values (i, p);
set i = i+1;
end if;
set p = p+2;
end;
end while;
end;
call ip(200);
select * from primes where i=45 or i=100 or i=199;
i	p
45	211
100	557
199	1229
drop table primes;
drop procedure opp;
drop procedure ip;
drop table t1;
drop table t2;
