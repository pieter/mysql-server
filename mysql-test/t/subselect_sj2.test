#
# DuplicateElimination strategy test
#
--source include/have_innodb.inc
--disable_warnings
drop table if exists t0, t1, t2, t3;
--enable_warnings


create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

# First test simple cases: I20 order, no join buffering.

create table t1 (
  a int, 
  b int
);
insert into t1 values (1,1),(1,1),(2,2);

create table t2 (
  a int,
  b int,
  key(b)
);
insert into t2 select a, a/2 from t0;

select * from t1;
select * from t2;
explain select * from t2 where b in (select a from t1);
select * from t2 where b in (select a from t1);

# Try an InnoDB table with very long rowid
create table t3 (
   a int, 
   b int,
   key(b),
   pk1 char(200), pk2 char(200), pk3 char(200),
   primary key(pk1, pk2, pk3)
) engine=innodb;
insert into t3 select a,a, a,a,a from t0;

explain select * from t3 where b in (select a from t1);
select * from t3 where b in (select a from t1);

# Test overflow to MyISAM:
set @save_max_heap_table_size= @@max_heap_table_size;
set max_heap_table_size=16384;
set @save_join_buffer_size = @@join_buffer_size;
set join_buffer_size= 8000;

drop table t3;
create table t3 (
   a int, 
   b int,
   key(b),
   pk1 char(200), pk2 char(200),
   primary key(pk1, pk2)
) engine=innodb;
insert into t3 select 
  A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a 
from t0 A, t0 B where B.a <5;

explain select * from t3 where b in (select a from t0);
select * from t3 where b in (select A.a+B.a from t0 A, t0 B where B.a<5);

set join_buffer_size= @save_join_buffer_size;
set max_heap_table_size= @save_max_heap_table_size;

# O2I join orders, with shortcutting: 
explain select * from t1 where a in (select b from t2);
select * from t1;
select * from t1 where a in (select b from t2);

drop table t1, t2, t3;
# (no need for anything in range/index_merge/DS-MRR) 

#
# Test join buffering
#
set @save_join_buffer_size = @@join_buffer_size;
set join_buffer_size= 8000;

create table t1 (a int, filler1 binary(200), filler2 binary(200));
insert into t1 select a, 'filler123456', 'filler123456' from t0;
insert into t1 select a+10, 'filler123456', 'filler123456' from t0;

create table t2 as select * from t1;
insert into t1 select a+20, 'filler123456', 'filler123456' from t0;

insert into t1 values (2, 'duplicate ok', 'duplicate ok');
insert into t1 values (18, 'duplicate ok', 'duplicate ok');

insert into t2 values (3, 'duplicate ok', 'duplicate ok');
insert into t2 values (19, 'duplicate ok', 'duplicate ok');

explain select 
 a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);
select 
 a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);

explain select 
  a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);
select 
  a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);

# Now let the buffer overfill:
insert into t1 select a+20, 'filler123456', 'filler123456' from t0;
insert into t1 select a+20, 'filler123456', 'filler123456' from t0;

explain select 
 a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);
select 
 a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);

explain select 
  a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);
select 
  a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);

drop table t1, t2;

# Check ref access to tables inside the OJ nest inside the SJ nest
create table t1 (a int, b int, key(a));
create table t2 (a int, b int, key(a));
create table t3 (a int, b int, key(a));

insert into t1 select a,a from t0;
insert into t2 select a,a from t0;
insert into t3 select a,a from t0;

--echo t2 and t3 must be use 'ref', not 'ALL':
explain select * 
from t0 where a in
  (select t2.a+t3.a from t1 left join (t2 join t3) on t2.a=t1.a and t3.a=t1.a);

drop table t0, t1,t2,t3;


