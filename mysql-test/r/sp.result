use test;
drop table if exists t1;
drop table if exists t2;
create table t1 (
id   char(16) not null,
data int not null
);
create table t2 (
s   char(16),
i   int,
d   double
);
create procedure foo42()
insert into test.t1 values ("foo", 42);
call foo42();
select * from t1;
id	data
foo	42
delete from t1;
drop procedure foo42;
create procedure bar(x char(16), y int)
insert into test.t1 values (x, y);
call bar("bar", 666);
select * from t1;
id	data
bar	666
delete from t1;
create procedure empty()
begin
end|
call empty()|
drop procedure empty|
create procedure scope(a int, b float)
begin
declare b int;
declare c float;
begin
declare c int;
end;
end|
drop procedure scope|
create procedure two(x1 char(16), x2 char(16), y int)
begin
insert into test.t1 values (x1, y);
insert into test.t1 values (x2, y);
end|
call two("one", "two", 3)|
select * from t1|
id	data
one	3
two	3
delete from t1|
drop procedure two|
create procedure locset(x char(16), y int)
begin
declare z1, z2 int;
set z1 = y;
set z2 = z1+2;
insert into test.t1 values (x, z2);
end|
call locset("locset", 19)|
select * from t1|
id	data
locset	21
delete from t1|
drop procedure locset|
create procedure setcontext()
begin
declare data int default 2;
insert into t1 (id, data) values ("foo", 1);
replace t1 set data = data, id = "bar";
update t1 set id = "kaka", data = 3 where t1.data = data;
end|
call setcontext()|
select * from t1|
id	data
foo	1
kaka	3
delete from t1|
drop procedure setcontext|
drop table if exists t3|
create table t3 ( d date, i int, f double, s varchar(32) )|
create procedure nullset()
begin
declare ld date;
declare li int;
declare lf double;
declare ls varchar(32);
set ld = null, li = null, lf = null, ls = null;
insert into t3 values (ld, li, lf, ls);
insert into t3 (i, f, s) values ((ld is null), 1,    "ld is null"),
((li is null), 1,    "li is null"),
((li = 0),     null, "li = 0"),
((lf is null), 1,    "lf is null"),
((lf = 0),     null, "lf = 0"),
((ls is null), 1,    "ls is null");
end|
call nullset()|
select * from t3|
d	i	f	s
NULL	NULL	NULL	NULL
NULL	1	1	ld is null
NULL	1	1	li is null
NULL	NULL	NULL	li = 0
NULL	1	1	lf is null
NULL	NULL	NULL	lf = 0
NULL	1	1	ls is null
drop table t3|
drop procedure nullset|
create procedure mixset(x char(16), y int)
begin
declare z int;
set @z = y, z = 666, max_join_size = 100;
insert into test.t1 values (x, z);
end|
call mixset("mixset", 19)|
show variables like 'max_join_size'|
Variable_name	Value
max_join_size	100
select id,data,@z from t1|
id	data	@z
mixset	666	19
delete from t1|
drop procedure mixset|
create procedure zip(x char(16), y int)
begin
declare z int;
call zap(y, z);
call bar(x, z);
end|
create procedure zap(x int, out y int)
begin
declare z int;
set z = x+1, y = z;
end|
call zip("zip", 99)|
select * from t1|
id	data
zip	100
delete from t1|
drop procedure zip|
drop procedure bar|
call zap(7, @zap)|
select @zap|
@zap
8
drop procedure zap|
create procedure c1(x int)
call c2("c", x)|
create procedure c2(s char(16), x int)
call c3(x, s)|
create procedure c3(x int, s char(16))
call c4("level", x, s)|
create procedure c4(l char(8), x int, s char(16))
insert into t1 values (concat(l,s), x)|
call c1(42)|
select * from t1|
id	data
levelc	42
delete from t1|
drop procedure c1|
drop procedure c2|
drop procedure c3|
drop procedure c4|
create procedure iotest(x1 char(16), x2 char(16), y int)
begin
call inc2(x2, y);
insert into test.t1 values (x1, y);
end|
create procedure inc2(x char(16), y int)
begin
call inc(y);
insert into test.t1 values (x, y);
end|
create procedure inc(inout io int)
set io = io + 1|
call iotest("io1", "io2", 1)|
select * from t1|
id	data
io2	2
io1	1
delete from t1|
drop procedure iotest|
drop procedure inc2|
create procedure incr(inout x int)
call inc(x)|
select @zap|
@zap
8
call incr(@zap)|
select @zap|
@zap
9
drop procedure inc|
drop procedure incr|
create procedure cbv1()
begin
declare y int default 3;
call cbv2(y+1, y);
insert into test.t1 values ("cbv1", y);
end|
create procedure cbv2(y1 int, inout y2 int)
begin
set y2 = 4711;
insert into test.t1 values ("cbv2", y1);
end|
call cbv1()|
select * from t1|
id	data
cbv2	4
cbv1	4711
delete from t1|
drop procedure cbv1|
drop procedure cbv2|
insert into t2 values ("a", 1, 1.1), ("b", 2, 1.2), ("c", 3, 1.3)|
create procedure sub1(id char(16), x int)
insert into test.t1 values (id, x)|
create function sub3(i int) returns int
return i+1|
call sub1("sub1a", (select 7))|
call sub1("sub1b", (select max(i) from t2))|
call sub1("sub1c", (select i,d from t2 limit 1))|
call sub1("sub1d", (select 1 from (select 1) a))|
select * from t1|
id	data
sub1a	7
sub1b	3
sub1c	1
sub1d	1
select sub3((select max(i) from t2))|
sub3((select max(i) from t2))
4
drop procedure sub1|
drop function sub3|
delete from t2|
create procedure a0(x int)
while x do
set x = x-1;
insert into test.t1 values ("a0", x);
end while|
call a0(3)|
select * from t1|
id	data
sub1a	7
sub1b	3
sub1c	1
sub1d	1
a0	2
a0	1
a0	0
delete from t1|
drop procedure a0|
create procedure a(x int)
while x > 0 do
set x = x-1;
insert into test.t1 values ("a", x);
end while|
call a(3)|
select * from t1|
id	data
a	2
a	1
a	0
delete from t1|
drop procedure a|
create procedure b(x int)
repeat
insert into test.t1 values (repeat("b",3), x);
set x = x-1;
until x = 0 end repeat|
call b(3)|
select * from t1|
id	data
bbb	3
bbb	2
bbb	1
delete from t1|
drop procedure b|
create procedure b2(x int)
repeat(select 1 into outfile 'b2');
insert into test.t1 values (repeat("b2",3), x);
set x = x-1;
until x = 0 end repeat|
drop procedure b2|
create procedure c(x int)
hmm: while x > 0 do
insert into test.t1 values ("c", x);
set x = x-1;
iterate hmm;
insert into test.t1 values ("x", x);
end while hmm|
call c(3)|
select * from t1|
id	data
c	3
c	2
c	1
delete from t1|
drop procedure c|
create procedure d(x int)
hmm: while x > 0 do
insert into test.t1 values ("d", x);
set x = x-1;
leave hmm;
insert into test.t1 values ("x", x);
end while|
call d(3)|
select * from t1|
id	data
d	3
delete from t1|
drop procedure d|
create procedure e(x int)
foo: loop
if x = 0 then
leave foo;
end if;
insert into test.t1 values ("e", x);
set x = x-1;
end loop foo|
call e(3)|
select * from t1|
id	data
e	3
e	2
e	1
delete from t1|
drop procedure e|
create procedure f(x int)
if x < 0 then
insert into test.t1 values ("f", 0);
elseif x = 0 then
insert into test.t1 values ("f", 1);
else
insert into test.t1 values ("f", 2);
end if|
call f(-2)|
call f(0)|
call f(4)|
select * from t1|
id	data
f	0
f	1
f	2
delete from t1|
drop procedure f|
create procedure g(x int)
case
when x < 0 then
insert into test.t1 values ("g", 0);
when x = 0 then
insert into test.t1 values ("g", 1);
else
insert into test.t1 values ("g", 2);
end case|
call g(-42)|
call g(0)|
call g(1)|
select * from t1|
id	data
g	0
g	1
g	2
delete from t1|
drop procedure g|
create procedure h(x int)
case x
when 0 then
insert into test.t1 values ("h0", x);
when 1 then
insert into test.t1 values ("h1", x);
else
insert into test.t1 values ("h?", x);
end case|
call h(0)|
call h(1)|
call h(17)|
select * from t1|
id	data
h0	0
h1	1
h?	17
delete from t1|
drop procedure h|
create procedure i(x int)
foo:
begin
if x = 0 then
leave foo;
end if;
insert into test.t1 values ("i", x);
end foo|
call i(0)|
call i(3)|
select * from t1|
id	data
i	3
delete from t1|
drop procedure i|
insert into t1 values ("foo", 3), ("bar", 19)|
insert into t2 values ("x", 9, 4.1), ("y", -1, 19.2), ("z", 3, 2.2)|
create procedure sel1()
begin
select * from t1;
end|
call sel1()|
id	data
foo	3
bar	19
drop procedure sel1|
create procedure sel2()
begin
select * from t1;
select * from t2;
end|
call sel2()|
id	data
foo	3
bar	19
s	i	d
x	9	4.1
y	-1	19.2
z	3	2.2
drop procedure sel2|
delete from t1|
delete from t2|
create procedure into_test(x char(16), y int)
begin
insert into test.t1 values (x, y);
select id,data into x,y from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_test("into", 100)|
select * from t1|
id	data
into	100
into2	102
delete from t1|
drop procedure into_test|
create procedure into_test2(x char(16), y int)
begin
insert into test.t1 values (x, y);
select id,data into x,@z from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_test2("into", 100)|
select id,data,@z from t1|
id	data	@z
into	100	100
into2	102	100
delete from t1|
drop procedure into_test2|
create procedure into_test3()
begin
declare x char(16);
declare y int;
select * into x,y from test.t1 limit 1;
insert into test.t2 values (x, y, 0.0);
end|
insert into t1 values ("into3", 19)|
call into_test3()|
call into_test3()|
select * from t2|
s	i	d
into3	19	0
into3	19	0
delete from t1|
delete from t2|
drop procedure into_test3|
create procedure into_test4()
begin
declare x int;
select data into x from test.t1 limit 1;
insert into test.t3 values ("into4", x);
end|
delete from t1|
drop table if exists t3|
create table t3 ( s char(16), d int)|
call into_test4()|
Warnings:
select * from t3|
s	d
into4	NULL
insert into t1 values ("i4", 77)|
call into_test4()|
select * from t3|
s	d
into4	NULL
into4	77
delete from t1|
drop table t3|
drop procedure into_test4|
create procedure into_outfile(x char(16), y int)
begin
insert into test.t1 values (x, y);
select * into outfile "/tmp/spout" from test.t1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_outfile("ofile", 1)|
delete from t1|
drop procedure into_outfile|
create procedure into_dumpfile(x char(16), y int)
begin
insert into test.t1 values (x, y);
select * into dumpfile "/tmp/spdump" from test.t1 limit 1;
insert into test.t1 values (concat(x, "2"), y+2);
end|
call into_dumpfile("dfile", 1)|
delete from t1|
drop procedure into_dumpfile|
create procedure create_select(x char(16), y int)
begin
insert into test.t1 values (x, y);
create table test.t3 select * from test.t1;
insert into test.t3 values (concat(x, "2"), y+2);
end|
drop table if exists t3|
call create_select("cs", 90)|
select * from t1, t3|
id	data	id	data
cs	90	cs	90
cs	90	cs2	92
drop table if exists t3|
delete from t1|
drop procedure create_select|
create function e() returns double
return 2.7182818284590452354|
set @e = e()|
select e(), @e|
e()	@e
2.718281828459	2.718281828459
create function inc(i int) returns int
return i+1|
select inc(1), inc(99), inc(-71)|
inc(1)	inc(99)	inc(-71)
2	100	-70
create function mul(x int, y int) returns int
return x*y|
select mul(1,1), mul(3,5), mul(4711, 666)|
mul(1,1)	mul(3,5)	mul(4711, 666)
1	15	3137526
create function append(s1 char(8), s2 char(8)) returns char(16)
return concat(s1, s2)|
select append("foo", "bar")|
append("foo", "bar")
foobar
create function fac(n int unsigned) returns bigint unsigned
begin
declare f bigint unsigned default 1;
while n > 1 do
set f = f * n;
set n = n - 1;
end while;
return f;
end|
select fac(1), fac(2), fac(5), fac(10)|
fac(1)	fac(2)	fac(5)	fac(10)
1	2	120	3628800
create function fun(d double, i int, u int unsigned) returns double
return mul(inc(i), fac(u)) / e()|
select fun(2.3, 3, 5)|
fun(2.3, 3, 5)
176.58213176229
insert into t2 values (append("xxx", "yyy"), mul(4,3), e())|
insert into t2 values (append("a", "b"), mul(2,mul(3,4)), fun(1.7, 4, 6))|
select * from t2 where s = append("a", "b")|
s	i	d
ab	24	1324.36598821719
select * from t2 where i = mul(4,3) or i = mul(mul(3,4),2)|
s	i	d
xxxyyy	12	2.71828182845905
ab	24	1324.36598821719
select * from t2 where d = e()|
s	i	d
xxxyyy	12	2.71828182845905
select * from t2|
s	i	d
xxxyyy	12	2.71828182845905
ab	24	1324.36598821719
delete from t2|
drop function e|
drop function inc|
drop function mul|
drop function append|
drop function fun|
create procedure hndlr1(val int)
begin
declare x int default 0;
declare foo condition for 1146;
declare bar condition for sqlstate '42S98';        # Just for testing syntax
declare zip condition for sqlstate value '42S99';  # Just for testing syntax
declare continue handler for foo set x = 1;
insert into test.t666 values ("hndlr1", val);   # Non-existing table
if (x) then
insert into test.t1 values ("hndlr1", val);   # This instead then
end if;
end|
call hndlr1(42)|
select * from t1|
id	data
hndlr1	42
delete from t1|
drop procedure hndlr1|
create procedure hndlr2(val int)
begin
declare x int default 0;
begin
declare exit handler for sqlstate '42S02' set x = 1;
insert into test.t666 values ("hndlr2", val); # Non-existing table
end;
insert into test.t1 values ("hndlr2", x);
end|
call hndlr2(42)|
select * from t1|
id	data
hndlr2	1
delete from t1|
drop procedure hndlr2|
create procedure hndlr3(val int)
begin
declare x int default 0;
declare continue handler for sqlexception        # Any error
begin
declare z int;
set z = 2 * val;
set x = 1;
end;
if val < 10 then
begin
declare y int;
set y = val + 10;
insert into test.t666 values ("hndlr3", y);  # Non-existing table
if x then
insert into test.t1 values ("hndlr3", y);
end if;
end;
end if;
end|
call hndlr3(3)|
select * from t1|
id	data
hndlr3	13
delete from t1|
drop procedure hndlr3|
drop table if exists t3|
create table t3 ( id   char(16), data int )|
create procedure hndlr4()
begin
declare x int default 0;
declare val int;	                           # No default
declare continue handler for sqlstate '02000' set x=1;
select data into val from test.t3 where id='z' limit 1;  # No hits
insert into test.t3 values ('z', val);
end|
call hndlr4()|
select * from t3|
id	data
z	NULL
drop table t3|
drop procedure hndlr4|
create procedure cur1()
begin
declare done int default 0;
declare continue handler for sqlstate '02000' set done = 1;
declare c cursor for select * from test.t2;
declare a char(16);
declare b int;
declare c double;
open c;
repeat
fetch c into a, b, c;
if not done then
insert into test.t1 values (a, b+c);
end if;
until done end repeat;
close c;
end|
insert into t2 values ("foo", 42, -1.9), ("bar", 3, 12.1), ("zap", 666, -3.14)|
call cur1()|
select * from t1|
id	data
foo	40
bar	15
zap	663
drop procedure cur1|
drop table if exists t3|
create table t3 ( s char(16), i int )|
create procedure cur2()
begin
declare done int default 0;
declare continue handler for sqlstate '02000' set done = 1;
declare c1 cursor for select id,data from test.t1;
declare c2 cursor for select i from test.t2;
open c1;
open c2;
repeat
begin
declare a char(16);
declare b,c int;
fetch c1 into a, b;
fetch c2 into c;
if not done then
if b < c then
insert into test.t3 values (a, b);
else
insert into test.t3 values (a, c);
end if;
end if;
end;
until done end repeat;
close c1;
close c2;
end|
call cur2()|
select * from t3|
s	i
foo	40
bar	3
zap	663
delete from t1|
delete from t2|
drop table t3|
drop procedure cur2|
create procedure chistics()
language sql
not deterministic
sql security definer
comment 'Characteristics procedure test'
 insert into t1 values ("chistics", 1)|
call chistics()|
select * from t1|
id	data
chistics	1
delete from t1|
alter procedure chistics sql security invoker name chistics2|
show create procedure chistics2|
Procedure	Create Procedure
chistics2	CREATE PROCEDURE `test`.`chistics2`()
    SQL SECURITY INVOKER
    COMMENT 'Characteristics procedure test'
insert into t1 values ("chistics", 1)
drop procedure chistics2|
create function chistics() returns int
language sql
deterministic
sql security invoker
comment 'Characteristics procedure test'
 return 42|
select chistics()|
chistics()
42
alter function chistics name chistics2 comment 'Characteristics function test'|
show create function chistics2|
Function	Create Function
chistics2	CREATE FUNCTION `test`.`chistics2`() RETURNS int
    DETERMINISTIC
    SQL SECURITY INVOKER
    COMMENT 'Characteristics function test'
return 42
drop function chistics2|
insert into t1 values ("foo", 1), ("bar", 2), ("zip", 3)|
set @@sql_mode = 'ANSI'|
create procedure modes(out c1 int, out c2 int)
begin
declare done int default 0;
declare x int;
declare continue handler for sqlstate '02000' set done = 1;
declare c cursor for select data from t1;
select 1 || 2 into c1;
set c2 = 0;
open c;
repeat
fetch c into x;
if not done then
set c2 = c2 + 1;
end if;
until done end repeat;
close c;
end$
set @@sql_mode = ''|
set sql_select_limit = 1|
call modes(@c1, @c2)|
set sql_select_limit = default|
select @c1, @c2|
@c1	@c2
12	3
delete from t1|
drop procedure modes|
create procedure bug822(a_id char(16), a_data int)
begin
declare n int;
select count(*) into n from t1 where id = a_id and data = a_data;
if n = 0 then
insert into t1 (id, data) values (a_id, a_data);
end if;
end|
call bug822('foo', 42)|
call bug822('foo', 42)|
call bug822('bar', 666)|
select * from t1|
id	data
foo	42
bar	666
delete from t1|
drop procedure bug822|
create procedure bug1495()
begin
declare x int;
select data into x from t1 order by id limit 1;
if x > 10 then
insert into t1 values ("less", x-10);
else
insert into t1 values ("more", x+10);
end if;
end|
insert into t1 values ('foo', 12)|
call bug1495()|
delete from t1 where id='foo'|
insert into t1 values ('bar', 7)|
call bug1495()|
delete from t1 where id='bar'|
select * from t1|
id	data
less	2
more	17
delete from t1|
drop procedure bug1495|
create procedure bug1547(s char(16))
begin
declare x int;
select data into x from t1 where s = id limit 1;
if x > 10 then
insert into t1 values ("less", x-10);
else
insert into t1 values ("more", x+10);
end if;
end|
insert into t1 values ("foo", 12), ("bar", 7)|
call bug1547("foo")|
call bug1547("bar")|
select * from t1|
id	data
foo	12
bar	7
less	2
more	17
delete from t1|
drop procedure bug1547|
drop table if exists t70|
create table t70 (s1 int,s2 int)|
insert into t70 values (1,2)|
create procedure bug1656(out p1 int, out p2 int)
select * into p1, p1 from t70|
call bug1656(@1, @2)|
select @1, @2|
@1	@2
2	NULL
drop table t70|
drop procedure bug1656|
drop table if exists t3|
create table t3(a int)|
create procedure bug1862()
begin
insert into t3 values(2);    
flush tables;
end|
call bug1862()|
call bug1862()|
select * from t3|
a
2
2
drop table t3|
drop procedure bug1862|
create procedure bug1874()
begin
declare x int;
declare y double;
select max(data) into x from t1;
insert into t2 values ("max", x, 0);
select min(data) into x from t1;
insert into t2 values ("min", x, 0);
select sum(data) into x from t1;
insert into t2 values ("sum", x, 0);
select avg(data) into y from t1;
insert into t2 values ("avg", 0, y);
end|
insert into t1 (data) values (3), (1), (5), (9), (4)|
call bug1874()|
select * from t2|
s	i	d
max	9	0
min	1	0
sum	22	0
avg	0	4.4
delete from t1|
delete from t2|
drop procedure bug1874|
create procedure bug2260()
begin
declare v1 int;
declare continue handler for not found set @x2 = 1;
declare c1 cursor for select data from t1;
open c1;
fetch c1 into v1;
set @x2 = 2;
close c1;
end|
call bug2260()|
select @x2|
@x2
2
drop procedure bug2260|
create procedure bug2267_1()
begin
show procedure status;
end|
create procedure bug2267_2()
begin
show function status;
end|
create procedure bug2267_3()
begin
show create procedure bug2267_1;
end|
create procedure bug2267_4()
begin
show create function fac;
end|
call bug2267_1()|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	bug2267_1	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
test	bug2267_2	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
test	bug2267_3	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
test	bug2267_4	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
call bug2267_2()|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	fac	FUNCTION	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
call bug2267_3()|
Procedure	Create Procedure
bug2267_1	CREATE PROCEDURE `test`.`bug2267_1`()
begin
show procedure status;
end
call bug2267_4()|
Function	Create Function
fac	CREATE FUNCTION `test`.`fac`(n int unsigned) RETURNS bigint unsigned
begin
declare f bigint unsigned default 1;
while n > 1 do
set f = f * n;
set n = n - 1;
end while;
return f;
end
drop procedure bug2267_1|
drop procedure bug2267_2|
drop procedure bug2267_3|
drop procedure bug2267_4|
create procedure bug2227(x int)
begin
declare y float default 2.6;
declare z char(16) default "zzz";
select 1.3, x, y, 42, z;
end|
call bug2227(9)|
1.3	x	y	42	z
1.3	9	2.6	42	zzz
drop procedure bug2227|
create procedure bug2614()
begin
drop table if exists t3;
create table t3 (id int default '0' not null);
insert into t3 select 12;
insert into t3 select * from t3;
end|
call bug2614()|
call bug2614()|
drop table t3|
drop procedure bug2614|
drop table if exists fac|
create table fac (n int unsigned not null primary key, f bigint unsigned)|
create procedure ifac(n int unsigned)
begin
declare i int unsigned default 1;
if n > 20 then
set n = 20;		# bigint overflow otherwise
end if;
while i <= n do
begin
insert into test.fac values (i, fac(i));
set i = i + 1;
end;
end while;
end|
call ifac(20)|
select * from fac|
n	f
1	1
2	2
3	6
4	24
5	120
6	720
7	5040
8	40320
9	362880
10	3628800
11	39916800
12	479001600
13	6227020800
14	87178291200
15	1307674368000
16	20922789888000
17	355687428096000
18	6402373705728000
19	121645100408832000
20	2432902008176640000
drop table fac|
show function status like '%f%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	fac	FUNCTION	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
drop procedure ifac|
drop function fac|
show function status like '%f%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
drop table if exists primes|
create table primes (
i int unsigned not null primary key,
p bigint unsigned not null
)|
insert into primes values
( 0,   3), ( 1,   5), ( 2,   7), ( 3,  11), ( 4,  13),
( 5,  17), ( 6,  19), ( 7,  23), ( 8,  29), ( 9,  31),
(10,  37), (11,  41), (12,  43), (13,  47), (14,  53),
(15,  59), (16,  61), (17,  67), (18,  71), (19,  73),
(20,  79), (21,  83), (22,  89), (23,  97), (24, 101),
(25, 103), (26, 107), (27, 109), (28, 113), (29, 127),
(30, 131), (31, 137), (32, 139), (33, 149), (34, 151),
(35, 157), (36, 163), (37, 167), (38, 173), (39, 179),
(40, 181), (41, 191), (42, 193), (43, 197), (44, 199)|
create procedure opp(n bigint unsigned, out pp bool)
begin
declare r double;
declare b, s bigint unsigned default 0;
set r = sqrt(n);
again:
loop
if s = 45 then
set b = b+200, s = 0;
else
begin
declare p bigint unsigned;
select t.p into p from test.primes t where t.i = s;
if b+p > r then
set pp = 1;
leave again;
end if;
if mod(n, b+p) = 0 then
set pp = 0;
leave again;
end if;
set s = s+1;
end;
end if;
end loop;
end|
create procedure ip(m int unsigned)
begin
declare p bigint unsigned;
declare i int unsigned;
set i=45, p=201;
while i < m do
begin
declare pp bool default 0;
call opp(p, pp);
if pp then
insert into test.primes values (i, p);
set i = i+1;
end if;
set p = p+2;
end;
end while;
end|
show create procedure opp|
Procedure	Create Procedure
opp	CREATE PROCEDURE `test`.`opp`(n bigint unsigned, out pp bool)
begin
declare r double;
declare b, s bigint unsigned default 0;
set r = sqrt(n);
again:
loop
if s = 45 then
set b = b+200, s = 0;
else
begin
declare p bigint unsigned;
select t.p into p from test.primes t where t.i = s;
if b+p > r then
set pp = 1;
leave again;
end if;
if mod(n, b+p) = 0 then
set pp = 0;
leave again;
end if;
set s = s+1;
end;
end if;
end loop;
end
show procedure status like '%p%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	ip	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
test	opp	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	
call ip(200)|
select * from primes where i=45 or i=100 or i=199|
i	p
45	211
100	557
199	1229
drop table primes|
drop procedure opp|
drop procedure ip|
show procedure status like '%p%'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
drop table if exists fib|
create table fib ( f bigint unsigned not null )|
insert into fib values (1), (1)|
create procedure fib(n int unsigned)
begin
if n > 0 then
begin
declare x, y bigint unsigned;
declare c cursor for select f from fib order by f desc limit 2;
open c;
fetch c into y;
fetch c into x;
close c;
insert into fib values (x+y);
call fib(n-1);
end;
end if;
end|
call fib(20)|
select * from fib order by f asc|
f
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
drop table fib|
drop procedure fib|
create procedure bar(x char(16), y int)
comment "111111111111" sql security invoker
insert into test.t1 values (x, y)|
show procedure status like 'bar'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	bar	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	INVOKER	111111111111
alter procedure bar name bar2 comment "2222222222" sql security definer|
alter procedure bar2 name bar comment "3333333333"|
alter procedure bar|
show create procedure bar|
Procedure	Create Procedure
bar	CREATE PROCEDURE `test`.`bar`(x char(16), y int)
    COMMENT '3333333333'
insert into test.t1 values (x, y)
show procedure status like 'bar'|
Db	Name	Type	Definer	Modified	Created	Security_type	Comment
test	bar	PROCEDURE	root@localhost	0000-00-00 00:00:00	0000-00-00 00:00:00	DEFINER	3333333333
drop procedure bar|
drop table t1;
drop table t2;
