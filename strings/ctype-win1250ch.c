/*
	File strings/ctype-win1250ch.c for MySQL.

	Copyright: (C) 2001 Jan Pazdziora.

	This software is released under the terms of GNU General
        Public License.

        Development of this software was supported by Neocortex, s.r.o.

        Bug reports and suggestions are always welcome.

	This file implements the collating sequence for Windows-1250
	character set. It merely extends the binary sorting of US-ASCII
	by adding characters with diacritical marks into proper places.
	In addition, it sorts 'ch' between 'h' and 'i', and the sorting
	is case sensitive, with uppercase being sorted first, in the
	second pass.

	Bug reports and suggestions are always welcome.
*/

/*
 * This comment is parsed by configure to create ctype.c,
 * so don't change it unless you know what you are doing.
 *
 * .configure. strxfrm_multiply_win1250ch=2
 */

#define REAL_MYSQL

#ifdef REAL_MYSQL

#include "my_global.h"
#include "m_string.h"
#include "m_ctype.h"

uchar NEAR ctype_win1250ch[] = {
0x00,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x28, 0x28, 0x28, 0x28, 0x28, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x48, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
0x84, 0x84, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
0x10, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x10, 0x10, 0x10, 0x10, 0x10,
0x10, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x10, 0x10, 0x10, 0x10, 0x20,
0x20, 0x20, 0x10, 0x20, 0x10, 0x10, 0x10, 0x10,
0x20, 0x10, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01,
0x20, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
0x20, 0x10, 0x02, 0x10, 0x02, 0x02, 0x02, 0x02,
0x48, 0x10, 0x10, 0x01, 0x10, 0x01, 0x10, 0x01,
0x10, 0x10, 0x01, 0x10, 0x10, 0x10, 0x10, 0x01,
0x10, 0x10, 0x10, 0x02, 0x10, 0x10, 0x10, 0x10,
0x10, 0x02, 0x02, 0x10, 0x01, 0x10, 0x02, 0x02,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x10,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x10
};

uchar NEAR to_lower_win1250ch[] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x9a, 0x8b, 0x9c, 0x9d, 0x9e, 0x9f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xb3, 0xa4, 0xb9, 0xa6, 0xdf,
0xa8, 0xa9, 0xba, 0xab, 0xac, 0xad, 0xae, 0xbf,
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb, 0xbe, 0xbd, 0xbe, 0xbf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7,
0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

uchar NEAR to_upper_win1250ch[] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x8a, 0x9b, 0x8c, 0x8d, 0x8e, 0x8f,
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xa3, 0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xa5, 0xaa, 0xbb, 0xbc, 0xbd, 0xbc, 0xaf,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xa7,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7,
0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xff
};

#else

#include <stdio.h>
#define uchar unsigned char

#endif


uchar NEAR sort_order_win1250ch[] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
};

uchar NEAR _sort_order_win1250ch1[] = {
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
/* space ord 32 0x20 */
0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91,
/* 0 ord 48 0x30 */
0x92, 0x93, 0x94, 0x95, 0x95, 0x97, 0x98, 0x99,
0x9a, 0x9b,
	    /* colon ord 58 0x3a */
	    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1,
0xa2,
      /* A ord 65 0x41 */
      0xa4, 0xa5,
		  /* C ord 67 0x43 */
		  0xff, 0xa8, 0xa9, 0xaa, 0xab,
0xac, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4,
0xb5, 0xb6,
	    /* R ord 82 0x52 */
	    0xb7, 
		  /* S ord 83 0x53 */
		  0xb9, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2,
		  /* [ ord 91 0x5b */
		  0xc4, 0xc5, 0xc6, 0xc7, 0xc8,
0xc9,
      /* a ord 97 0x61 */
      0xa4, 0xa5, 0xff, 0xa8, 0xa9, 0xaa, 0xab,
0xac, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4,
0xb5, 0xb6, 0xb7, 0xb9, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2,
		  /* { ord 123 0x7b */
		  0xca, 0xcb, 0xcc, 0xcd, 0x81,
0x81, 0x81, 0xce, 0x81, 0xcf, 0xd0, 0xd1, 0xd2,
0x81, 0xd3,
	    /* Scaron ord 138 0x8a */
	    0xba, 0xd4, 0xb9, 0xbc, 0xc3, 0xc2,
0x81, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
0x81, 0xdc, 0xba, 0xdd, 0xb9, 0xbc, 0xc3, 0xc2,
/* nobreakspace ord 160 0xa0 */
0x82, 0xde, 0xdf, 0xb1, 0xe0, 0xa4, 0xe1, 0xe2,
0xe3, 0xe4, 0xb9, 0xe5, 0xe6, 0xe7, 0xe8, 0xc2,
0xe9, 0xea, 0xeb, 0xb1, 0xed, 0xee, 0x81, 0xef,
/* cedilla ord 183 0xb8 */
0xf0, 0xa4, 0xb9, 0xf1, 0xb1, 0xf2, 0xb1, 0xc2,
0xb7, 0xa4, 0xa4, 0xa4, 0xa4, 0xb1, 0xa6, 0xa6,
0xa7, 0xa9, 0xa9, 0xa9, 0xa9, 0xae, 0xae, 0xa8,
/* Eth ord 208 0xd0 */
0xa8, 0xb3, 0xb3, 0xb4, 0xb4, 0xb4, 0xb4, 0xf3,
0xb8, 0xbd, 0xbd, 0xbd, 0xbd, 0xc1, 0xbc, 0xbb,
/* racute ord 224 0xe0 */
0xb7, 0xa4, 0xa4, 0xa4, 0xa4, 0xb1, 0xa6, 0xa6,
0xa7, 0xa9, 0xa9, 0xa9, 0xa9, 0xae, 0xae, 0xa8,
/* eth ord 240 0xf0 */
0xa8, 0xb3, 0xb3, 0xb4, 0xb4, 0xb4, 0xb4, 0xf4,
0xb8, 0xbd, 0xbd, 0xbd, 0xbd, 0xc1, 0xbc, 0xf5
};

uchar NEAR _sort_order_win1250ch2[] = {
0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,
0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
/* space ord 32 0x20 */
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
/* 0 ord 48 0x30 */
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01,
	    /* colon ord 58 0x3a */
	    0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01,
      /* A ord 65 0x41 */
      0x01, 0x01,
		  /* C ord 67 0x43 */
		  0xff, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01,
	    /* R ord 82 0x52 */
	    0x01, 
		  /* S ord 83 0x53 */
		  0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01,
		  /* [ ord 91 0x5b */
		  0x01, 0x01, 0x01, 0x01, 0x01,
0x01,
      /* a ord 97 0x61 */
      0x02, 0x02, 0xff, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02,
		  /* { ord 123 0x7b */
		  0x01, 0x01, 0x01, 0x01, 0x22,
0x23, 0x24, 0x01, 0x25, 0x01, 0x01, 0x01, 0x01,
0x26, 0x01,
	    /* Scaron ord 138 0x8a */
	    0x01, 0x01, 0x03, 0x03, 0x01, 0x05,
0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x28, 0x01, 0x02, 0x01, 0x04, 0x04, 0x02, 0x06,
/* nobreakspace ord 160 0xa0 */
0x02, 0x01, 0x01, 0x07, 0x01, 0x11, 0x01, 0x01,
0x01, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x03,
0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x29, 0x01,
/* cedilla ord 184 0xb8 */
0x01, 0x12, 0x06, 0x01, 0x05, 0x01, 0x06, 0x04,
0x03, 0x03, 0x05, 0x07, 0x09, 0x03, 0x03, 0x05,
0x01, 0x03, 0x09, 0x07, 0x05, 0x03, 0x05, 0x03,
/* Eth ord 208 0xd0 */
0x05, 0x03, 0x05, 0x03, 0x05, 0x09, 0x07, 0x01,
0x01, 0x05, 0x03, 0x09, 0x07, 0x03, 0x05, 0x01,
/* racute ord 224 0xe0 */
0x04, 0x04, 0x06, 0x08, 0x0a, 0x04, 0x04, 0x06,
0x02, 0x04, 0x0a, 0x08, 0x06, 0x04, 0x06, 0x04,
/* eth ord 240 0xf0 */
0x06, 0x04, 0x06, 0x04, 0x06, 0x0a, 0x08, 0x01,
0x02, 0x06, 0x04, 0x0a, 0x08, 0x04, 0x06, 0x01
};

struct wordvalue {
	const char * word;
	uchar pass1;
	uchar pass2;
};
static struct wordvalue doubles[] = {
	{ "ch", 0xad, 0x03 },
	{ "c",  0xa6, 0x02 },
	{ "Ch", 0xad, 0x02 },
	{ "CH", 0xad, 0x01 },
	{ "C",  0xa6, 0x01 },
};

#define NEXT_CMP_VALUE(src, p, pass, value, len)			\
	while (1) {							\
		if (IS_END(p, src, len)) {				\
			if (pass == 0) { p = src; pass++; }		\
			else { value = 0; break; }			\
		}							\
		value = ((pass == 0) ? _sort_order_win1250ch1[*p]	\
			: _sort_order_win1250ch2[*p]);			\
		if (value == 0xff) {					\
			int i;						\
			for (i = 0; i < (int) sizeof(doubles); i++) {	\
				const uchar * patt = doubles[i].word;	\
				const uchar * q = (const char *) p;	\
				while (*patt				\
					&& !(IS_END(q, src, len))	\
					&& (*patt == *q)) {		\
					patt++; q++;			\
				}					\
				if (!(*patt)) {				\
					value = (int)((pass == 0)	\
						? doubles[i].pass1	\
						: doubles[i].pass2);	\
					p = (const uchar *) q - 1;	\
					break;				\
				}					\
			}						\
		}							\
		p++;							\
		break;							\
	}

#define IS_END(p, src, len)	(!(*p))

int my_strcoll_win1250ch(const uchar * s1, const uchar * s2) {
	int v1, v2;
	const uchar * p1, * p2;
	int pass1 = 0, pass2 = 0;
	int diff;

	p1 = s1;	p2 = s2;

	do {
		NEXT_CMP_VALUE(s1, p1, pass1, v1, 0);
		NEXT_CMP_VALUE(s2, p2, pass2, v2, 0);
		diff = v1 - v2;
		if (diff != 0)		return diff;
	} while (v1);
	return 0;
}

#ifdef UNUSED
int my_strxfrm_win1250ch(uchar * dest, const uchar * src, int len) {
	int value;
	const uchar * p;
	int pass = 0;
	int totlen = 0;
	p = src;

	do {
		NEXT_CMP_VALUE(src, p, pass, value, 0);
		if (totlen <= len)
			dest[totlen] = value;
		totlen++;
	} while (value);
	return totlen;
}
#endif

#undef IS_END

#define IS_END(p, src, len)	(((char *)p - (char *)src) >= (len))

int my_strnncoll_win1250ch(CHARSET_INFO *cs __attribute__((unused)), 
				const uchar * s1, uint len1,
				const uchar * s2, uint len2) {
	int v1, v2;
	const uchar * p1, * p2;
	int pass1 = 0, pass2 = 0;
	int diff;

	p1 = s1;	p2 = s2;

	do {
		NEXT_CMP_VALUE(s1, p1, pass1, v1, (int)len1);
		NEXT_CMP_VALUE(s2, p2, pass2, v2, (int)len2);
		diff = v1 - v2;
		if (diff != 0)		return diff;
	} while (v1);
	return 0;
}

int my_strnxfrm_win1250ch(CHARSET_INFO * cs  __attribute__((unused)),
			  uchar * dest, uint len, 
			  const uchar * src, uint srclen) {
	int value;
	const uchar * p;
	int pass = 0;
	uint totlen = 0;
	p = src;

	do {
		NEXT_CMP_VALUE(src, p, pass, value, (int)srclen);
		if (totlen <= len)
			dest[totlen] = value;
		totlen++;
	} while (value) ;
	return totlen;
}

#undef IS_END


#ifdef REAL_MYSQL

static uchar NEAR like_range_prefix_min_win1250ch[] = {
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
96, 54, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 165, 124, 125, 126, 0,
0, 0, 130, 0, 132, 133, 134, 135, 0, 137, 138, 139, 83, 84, 142, 90,
0, 145, 146, 147, 148, 149, 150, 151, 0, 153, 138, 155, 83, 84, 142, 90,
32, 161, 162, 76, 164, 165, 166, 167, 168, 65, 83, 171, 172, 173, 174, 90,
176, 177, 178, 76, 180, 181, 0, 183, 184, 65, 83, 187, 76, 189, 76, 90,
82, 65, 65, 65, 65, 76, 67, 67, 200, 69, 69, 69, 69, 73, 73, 68,
68, 78, 78, 79, 79, 79, 79, 215, 216, 85, 85, 85, 85, 89, 84, 223,
82, 65, 65, 65, 65, 76, 67, 67, 200, 69, 69, 69, 69, 73, 73, 68,
68, 78, 78, 79, 79, 79, 79, 247, 216, 85, 85, 85, 85, 89, 84, 255,
};
static uchar NEAR like_range_prefix_max_win1250ch[] = {
182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182,
182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182,
160, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
64, 185, 98, 73, 240, 234, 102, 103, 104, 238, 106, 107, 179, 109, 242, 245,
112, 113, 224, 186, 254, 251, 118, 119, 120, 253, 159, 91, 92, 93, 94, 95,
96, 54, 98, 73, 240, 234, 102, 103, 104, 238, 106, 107, 179, 109, 242, 245,
112, 113, 224, 186, 254, 251, 118, 119, 120, 253, 159, 165, 124, 125, 126, 182,
182, 182, 130, 182, 132, 133, 134, 135, 182, 137, 154, 139, 186, 254, 158, 159,
182, 145, 146, 147, 148, 149, 150, 151, 182, 153, 154, 155, 186, 254, 158, 159,
32, 161, 162, 179, 164, 165, 166, 167, 168, 185, 186, 171, 172, 173, 174, 159,
176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 179, 189, 179, 159,
224, 185, 185, 185, 185, 179, 238, 238, 200, 234, 234, 234, 234, 238, 238, 240,
240, 242, 242, 245, 245, 245, 245, 215, 248, 251, 251, 251, 251, 253, 254, 223,
224, 185, 185, 185, 185, 179, 238, 238, 200, 234, 234, 234, 234, 238, 238, 240,
240, 242, 242, 245, 245, 245, 245, 247, 248, 251, 251, 251, 251, 253, 254, 255,
};

#define min_sort_char '\x00'
#define max_sort_char '\xff'
#define wild_one '_'
#define wild_many '%'

/*
** Calculate min_str and max_str that ranges a LIKE string.
** Arguments:
** ptr		Pointer to LIKE string.
** ptr_length	Length of LIKE string.
** escape	Escape character in LIKE.  (Normally '\').
**		All escape characters should be removed from min_str and max_str
** res_length   Length of min_str and max_str.
** min_str      Smallest case sensitive string that ranges LIKE.
**		Should be space padded to res_length.
** max_str	Largest case sensitive string that ranges LIKE.
**		Normally padded with the biggest character sort value.
**
** The function should return 0 if ok and 1 if the LIKE string can't be
** optimized !
*/

my_bool my_like_range_win1250ch(CHARSET_INFO *cs __attribute__((unused)),
	const char *ptr, uint ptr_length,
	pchar escape, uint res_length,
	char *min_str, char *max_str,
	uint *min_length, uint *max_length) {

	int was_other_than_min = 0;
	const char *end = ptr + ptr_length;
	char *min_org = min_str;
	char *min_end = min_str + res_length;

	/* return 1; */

	for (; ptr != end && min_str != min_end ; ptr++) {
		if (*ptr == wild_one) {		/* '_' in SQL */
			break;
		}
		if (*ptr == wild_many) {	/* '%' in SQL */
			break;
		}
		if (*ptr == escape && ptr + 1 != end) {	/* Skip escape */
			ptr++;
		}
		*min_str = like_range_prefix_min_win1250ch[(uint)(*ptr)];
		if (*min_str != min_sort_char) {
			was_other_than_min = 1;
		}
		min_str++;
		*max_str++ = like_range_prefix_max_win1250ch[(uint)(*ptr)];
	}

	*min_length = (uint) (min_str - min_org);
	*max_length = res_length;
	while (min_str != min_end) {
		*min_str++ = min_sort_char;
		*max_str++ = max_sort_char;
	}
	if (! was_other_than_min) {
		return 1;
	}

	return 0;
}

#endif
